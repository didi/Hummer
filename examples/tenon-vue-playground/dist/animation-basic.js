/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/animation-basic/app.vue":
/*!*************************************!*\
  !*** ./src/animation-basic/app.vue ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _app_vue_vue_type_template_id_791d83ee_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app.vue?vue&type=template&id=791d83ee&scoped=true& */ "./src/animation-basic/app.vue?vue&type=template&id=791d83ee&scoped=true&");
/* harmony import */ var _app_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app.vue?vue&type=script&lang=js& */ "./src/animation-basic/app.vue?vue&type=script&lang=js&");
/* harmony import */ var _app_vue_vue_type_style_index_0_id_791d83ee_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app.vue?vue&type=style&index=0&id=791d83ee&lang=less&scoped=true& */ "./src/animation-basic/app.vue?vue&type=style&index=0&id=791d83ee&lang=less&scoped=true&");




;
_app_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"].render = _app_vue_vue_type_template_id_791d83ee_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render
_app_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"].__scopeId = "data-v-791d83ee"
/* hot reload */
if (false) {}

_app_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"].__file = "src/animation-basic/app.vue"

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_app_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./src/component/CommonPage.vue":
/*!**************************************!*\
  !*** ./src/component/CommonPage.vue ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CommonPage_vue_vue_type_template_id_5acf4ce5___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CommonPage.vue?vue&type=template&id=5acf4ce5& */ "./src/component/CommonPage.vue?vue&type=template&id=5acf4ce5&");
/* harmony import */ var _CommonPage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CommonPage.vue?vue&type=script&lang=js& */ "./src/component/CommonPage.vue?vue&type=script&lang=js&");
/* harmony import */ var _CommonPage_vue_vue_type_style_index_0_lang_less___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CommonPage.vue?vue&type=style&index=0&lang=less& */ "./src/component/CommonPage.vue?vue&type=style&index=0&lang=less&");




;
_CommonPage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"].render = _CommonPage_vue_vue_type_template_id_5acf4ce5___WEBPACK_IMPORTED_MODULE_0__.render
_CommonPage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"].__scopeId = "data-v-5acf4ce5"
/* hot reload */
if (false) {}

_CommonPage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"].__file = "src/component/CommonPage.vue"

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_CommonPage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./src/animation-basic/app.vue?vue&type=template&id=791d83ee&scoped=true&":
/*!********************************************************************************!*\
  !*** ./src/animation-basic/app.vue?vue&type=template&id=791d83ee&scoped=true& ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_loader_dist_templateLoader_js_ruleSet_1_rules_2_cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_loader_dist_index_js_ruleSet_1_rules_7_use_0_app_vue_vue_type_template_id_791d83ee_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_loader_dist_templateLoader_js_ruleSet_1_rules_2_cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_loader_dist_index_js_ruleSet_1_rules_7_use_0_app_vue_vue_type_template_id_791d83ee_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./app.vue?vue&type=template&id=791d83ee&scoped=true& */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/animation-basic/app.vue?vue&type=template&id=791d83ee&scoped=true&");


/***/ }),

/***/ "./src/component/CommonPage.vue?vue&type=template&id=5acf4ce5&":
/*!*********************************************************************!*\
  !*** ./src/component/CommonPage.vue?vue&type=template&id=5acf4ce5& ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_loader_dist_templateLoader_js_ruleSet_1_rules_2_cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_loader_dist_index_js_ruleSet_1_rules_7_use_0_CommonPage_vue_vue_type_template_id_5acf4ce5___WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_loader_dist_templateLoader_js_ruleSet_1_rules_2_cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_loader_dist_index_js_ruleSet_1_rules_7_use_0_CommonPage_vue_vue_type_template_id_5acf4ce5___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./CommonPage.vue?vue&type=template&id=5acf4ce5& */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/component/CommonPage.vue?vue&type=template&id=5acf4ce5&");


/***/ }),

/***/ "./src/animation-basic/app.vue?vue&type=style&index=0&id=791d83ee&lang=less&scoped=true&":
/*!***********************************************************************************************!*\
  !*** ./src/animation-basic/app.vue?vue&type=style&index=0&id=791d83ee&lang=less&scoped=true& ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_style_loader_dist_index_js_clonedRuleSet_1_use_0_cli_hummer_cli_packages_plugin_build_node_modules_less_loader_dist_cjs_js_cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_loader_dist_index_js_ruleSet_1_rules_7_use_0_app_vue_vue_type_style_index_0_id_791d83ee_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_style_loader_dist_index_js_clonedRuleSet_1_use_0_cli_hummer_cli_packages_plugin_build_node_modules_less_loader_dist_cjs_js_cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_loader_dist_index_js_ruleSet_1_rules_7_use_0_app_vue_vue_type_style_index_0_id_791d83ee_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-style-loader/dist/index.js??clonedRuleSet-1.use[0]!../../../../../cli/hummer-cli/packages/plugin-build/node_modules/less-loader/dist/cjs.js!../../../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./app.vue?vue&type=style&index=0&id=791d83ee&lang=less&scoped=true& */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-style-loader/dist/index.js??clonedRuleSet-1.use[0]!../../../cli/hummer-cli/packages/plugin-build/node_modules/less-loader/dist/cjs.js!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/animation-basic/app.vue?vue&type=style&index=0&id=791d83ee&lang=less&scoped=true&");
 

/***/ }),

/***/ "./src/component/CommonPage.vue?vue&type=style&index=0&lang=less&":
/*!************************************************************************!*\
  !*** ./src/component/CommonPage.vue?vue&type=style&index=0&lang=less& ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_style_loader_dist_index_js_clonedRuleSet_1_use_0_cli_hummer_cli_packages_plugin_build_node_modules_less_loader_dist_cjs_js_cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_loader_dist_index_js_ruleSet_1_rules_7_use_0_CommonPage_vue_vue_type_style_index_0_lang_less___WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_style_loader_dist_index_js_clonedRuleSet_1_use_0_cli_hummer_cli_packages_plugin_build_node_modules_less_loader_dist_cjs_js_cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_loader_dist_index_js_ruleSet_1_rules_7_use_0_CommonPage_vue_vue_type_style_index_0_lang_less___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-style-loader/dist/index.js??clonedRuleSet-1.use[0]!../../../../../cli/hummer-cli/packages/plugin-build/node_modules/less-loader/dist/cjs.js!../../../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./CommonPage.vue?vue&type=style&index=0&lang=less& */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-style-loader/dist/index.js??clonedRuleSet-1.use[0]!../../../cli/hummer-cli/packages/plugin-build/node_modules/less-loader/dist/cjs.js!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/component/CommonPage.vue?vue&type=style&index=0&lang=less&");
 

/***/ }),

/***/ "./src/animation-basic/app.vue?vue&type=script&lang=js&":
/*!**************************************************************!*\
  !*** ./src/animation-basic/app.vue?vue&type=script&lang=js& ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _cli_hummer_cli_packages_plugin_build_node_modules_babel_loader_lib_index_js_clonedRuleSet_3_use_cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_loader_dist_index_js_ruleSet_1_rules_7_use_0_app_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _cli_hummer_cli_packages_plugin_build_node_modules_babel_loader_lib_index_js_clonedRuleSet_3_use_cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_loader_dist_index_js_ruleSet_1_rules_7_use_0_app_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../cli/hummer-cli/packages/plugin-build/node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!../../../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./app.vue?vue&type=script&lang=js& */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/animation-basic/app.vue?vue&type=script&lang=js&");
 

/***/ }),

/***/ "./src/component/CommonPage.vue?vue&type=script&lang=js&":
/*!***************************************************************!*\
  !*** ./src/component/CommonPage.vue?vue&type=script&lang=js& ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _cli_hummer_cli_packages_plugin_build_node_modules_babel_loader_lib_index_js_clonedRuleSet_3_use_cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_loader_dist_index_js_ruleSet_1_rules_7_use_0_CommonPage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _cli_hummer_cli_packages_plugin_build_node_modules_babel_loader_lib_index_js_clonedRuleSet_3_use_cli_hummer_cli_packages_plugin_build_node_modules_hummer_tenon_loader_dist_index_js_ruleSet_1_rules_7_use_0_CommonPage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../cli/hummer-cli/packages/plugin-build/node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!../../../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./CommonPage.vue?vue&type=script&lang=js& */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/component/CommonPage.vue?vue&type=script&lang=js&");
 

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/animation-basic/app.vue?vue&type=template&id=791d83ee&scoped=true&":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/animation-basic/app.vue?vue&type=template&id=791d83ee&scoped=true& ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var _hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hummer/tenon-vue */ "./node_modules/@hummer/tenon-vue/dist/tenon-vue.es.js");


(0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.pushScopeId)("data-v-791d83ee")
const _hoisted_1 = ["onTap"]
;(0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.popScopeId)()

function render(_ctx, _cache) {
  const _component_CommonPage = (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("CommonPage")

  return ((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("view", {
    class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("page")
  }, [
    (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_CommonPage, {
      titleText: "基础动画",
      showDisplayLayout: false,
      showOption: false
    }, {
      content: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(() => [
        (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("scroller", {
          class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("scrollContentView")
        }, [
          (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
            class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("demo-container")
          }, [
            (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
              class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("demo-item")
            }, [
              (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-title"),
                onTap: _ctx.cons
              }, [
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("text", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-title-text")
                }, "透明度(opacity)", 2 /* CLASS */)
              ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_1),
              (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-container")
              }, [
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("box-container")
                }, [
                  (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                    class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("box")
                  }, null, 2 /* CLASS */), [
                    [_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.vAnimation, _ctx.animFadeOut]
                  ]),
                  (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                    class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("box box-opacity-hide")
                  }, null, 2 /* CLASS */), [
                    [_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.vAnimation, _ctx.animFadeIn]
                  ])
                ], 2 /* CLASS */)
              ], 2 /* CLASS */)
            ], 2 /* CLASS */),
            (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
              class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("demo-item")
            }, [
              (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-title")
              }, [
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("text", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-title-text")
                }, "旋转(rotate)", 2 /* CLASS */)
              ], 2 /* CLASS */),
              (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-container")
              }, [
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("box-container")
                }, [
                  (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                    class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("box")
                  }, null, 2 /* CLASS */), [
                    [_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.vAnimation, _ctx.animRotation]
                  ])
                ], 2 /* CLASS */)
              ], 2 /* CLASS */)
            ], 2 /* CLASS */),
            (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
              class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("demo-item")
            }, [
              (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-title")
              }, [
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("text", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-title-text")
                }, "位移(position)", 2 /* CLASS */)
              ], 2 /* CLASS */),
              (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-container")
              }, [
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("box-container")
                }, [
                  (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                    class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("box")
                  }, null, 2 /* CLASS */), [
                    [_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.vAnimation, _ctx.animTranslate]
                  ])
                ], 2 /* CLASS */)
              ], 2 /* CLASS */)
            ], 2 /* CLASS */),
            (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
              class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("demo-item")
            }, [
              (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-title")
              }, [
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("text", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-title-text")
                }, "放缩(scale)", 2 /* CLASS */)
              ], 2 /* CLASS */),
              (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-container")
              }, [
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("box-container")
                }, [
                  (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                    class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("box")
                  }, null, 2 /* CLASS */), [
                    [_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.vAnimation, _ctx.animScale]
                  ])
                ], 2 /* CLASS */)
              ], 2 /* CLASS */)
            ], 2 /* CLASS */),
            (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
              class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("demo-item")
            }, [
              (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-title")
              }, [
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("text", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-title-text")
                }, "背景色(backgroundColor)", 2 /* CLASS */)
              ], 2 /* CLASS */),
              (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-container")
              }, [
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("box-container")
                }, [
                  (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                    class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("box")
                  }, null, 2 /* CLASS */), [
                    [_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.vAnimation, _ctx.animBackground]
                  ])
                ], 2 /* CLASS */)
              ], 2 /* CLASS */)
            ], 2 /* CLASS */),
            (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
              class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("demo-item")
            }, [
              (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-title")
              }, [
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("text", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-title-text")
                }, "宽度(width)", 2 /* CLASS */)
              ], 2 /* CLASS */),
              (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-container")
              }, [
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("box-container")
                }, [
                  (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                    class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("box")
                  }, null, 2 /* CLASS */), [
                    [_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.vAnimation, _ctx.animWidth]
                  ])
                ], 2 /* CLASS */)
              ], 2 /* CLASS */)
            ], 2 /* CLASS */),
            (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
              class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("demo-item")
            }, [
              (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-title")
              }, [
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("text", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-title-text")
                }, "高度(height)", 2 /* CLASS */)
              ], 2 /* CLASS */),
              (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("item-container")
              }, [
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("box-container")
                }, [
                  (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                    class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("box")
                  }, null, 2 /* CLASS */), [
                    [_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.vAnimation, _ctx.animHeight]
                  ])
                ], 2 /* CLASS */)
              ], 2 /* CLASS */)
            ], 2 /* CLASS */)
          ], 2 /* CLASS */)
        ], 2 /* CLASS */)
      ]),
      _: 1 /* STABLE */
    })
  ], 2 /* CLASS */))
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/component/CommonPage.vue?vue&type=template&id=5acf4ce5&":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/component/CommonPage.vue?vue&type=template&id=5acf4ce5& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var _hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hummer/tenon-vue */ "./node_modules/@hummer/tenon-vue/dist/tenon-vue.es.js");


(0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.pushScopeId)("data-v-5acf4ce5")
const _hoisted_1 = ["onTap"]
const _hoisted_2 = ["onTap"]
const _hoisted_3 = ["onTap"]
const _hoisted_4 = ["onTap"]
const _hoisted_5 = ["onTap"]
;(0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.popScopeId)()

function render(_ctx, _cache) {
  return ((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("view", {
    class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("page")
  }, [
    (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
      class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("titleBar")
    }, [
      (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
        class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("imageWrapper"),
        onTap: _ctx.goBack
      }, [
        (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("image", {
          class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("navigatorBackImage"),
          resize: "contain",
          src: "https://pt-starimg.didistatic.com/static/starimg/img/vbcsZOJMB51642409516103.png"
        }, null, 2 /* CLASS */)
      ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_1),
      (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("text", {
        class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("titleView")
      }, (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.titleText), 3 /* TEXT, CLASS */),
      (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
        class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("line")
      }, null, 2 /* CLASS */)
    ], 2 /* CLASS */),
    (_ctx.showDisplayLayout)
      ? ((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("view", {
          key: 0,
          class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("displayLayout")
        }, [
          (_ctx.showDefaultLayout)
            ? ((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("view", {
                key: 0,
                class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("displayView"),
                style: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)(`backgroundColor:${
          _ctx.displayViewBackground || _ctx.bgColors[0]
        };borderRadius:${_ctx.displayViewRadius || _ctx.cornerRadiuses[0]};borderStyle:${
          _ctx.displayViewBorder || _ctx.borderStyles[0]
        };borderColor:${
          _ctx.selectBorderIndex === 0 ? '#00000000' : '#000000'
        };borderWidth:${_ctx.selectBorderIndex === 0 ? 0 : 2};boxShadow:${
          (_ctx.displayViewShadow || _ctx.shadows[0]) === 'none'
            ? '0 0 0 #00000000'
            : _ctx.displayViewShadow
        }`)
              }, [
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "displayView")
              ], 6 /* CLASS, STYLE */))
            : (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "displayView", { key: 1 })
        ], 2 /* CLASS */))
      : (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("v-if", true),
    (_ctx.showOption)
      ? ((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("scroller", {
          key: 1,
          class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("scrollContentView")
        }, [
          (_ctx.showDefaultOption)
            ? ((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, { key: 0 }, [
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("text", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("groupTitle")
                }, "背景", 2 /* CLASS */),
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("groupContent")
                }, [
                  ((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(_ctx.bgColors, (item, index) => {
                    return ((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("text", {
                      class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("groupText"),
                      onTap: $event => (_ctx.selectBackground(index)),
                      style: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)(`backgroundColor:${
              index === 3 ? '#15D0B420' : item
            };borderWidth:${
              _ctx.selectBackGroundIndex === index ? 1.5 : 0
            };borderColor:${
              _ctx.selectBackGroundIndex === index ? '#FF0000' : '#00000000'
            }`),
                      key: index
                    }, (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(index === 3 ? "无" : ""), 47 /* TEXT, CLASS, STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_2))
                  }), 128 /* KEYED_FRAGMENT */))
                ], 2 /* CLASS */),
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("text", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("groupTitle")
                }, "圆角", 2 /* CLASS */),
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("groupContent")
                }, [
                  ((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(_ctx.cornerRadiuses, (item, index) => {
                    return ((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("view", {
                      class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("groupRadius"),
                      onTap: $event => (_ctx.selectRadius(index)),
                      style: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)(`borderRadius:${(item * 3) / 10};borderWidth:${
              _ctx.selectRadiusIndex === index ? 1.5 : 0
            };borderColor:${
              _ctx.selectRadiusIndex === index ? '#FF0000' : '#00000000'
            }`),
                      key: index
                    }, null, 46 /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_3))
                  }), 128 /* KEYED_FRAGMENT */))
                ], 2 /* CLASS */),
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("text", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("groupTitle")
                }, "边框", 2 /* CLASS */),
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("groupContent")
                }, [
                  ((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(_ctx.borderStyles, (item, index) => {
                    return ((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("view", {
                      class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("groupBorder"),
                      onTap: $event => (_ctx.selectBorder(index)),
                      style: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)(`borderStyle:${item};backgroundColor:${
              _ctx.selectBorderIndex === index ? '#FF0000' : '#15D0B4'
            }`),
                      key: index
                    }, null, 46 /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_4))
                  }), 128 /* KEYED_FRAGMENT */))
                ], 2 /* CLASS */),
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("text", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("groupTitle")
                }, "阴影", 2 /* CLASS */),
                (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("view", {
                  class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("groupContent")
                }, [
                  ((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(_ctx.shadows, (item, index) => {
                    return ((0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("view", {
                      class: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)("groupShadow"),
                      onTap: $event => (_ctx.selectShadow(index)),
                      style: (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)(`boxShadow:${item};borderWidth:${
              _ctx.selectShadowIndex === index ? 1.5 : 0
            };borderColor:${
              _ctx.selectShadowIndex === index ? '#FF0000' : '#00000000'
            }`),
                      key: index
                    }, null, 46 /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_5))
                  }), 128 /* KEYED_FRAGMENT */))
                ], 2 /* CLASS */)
              ], 64 /* STABLE_FRAGMENT */))
            : (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("v-if", true),
          (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "settingView")
        ], 2 /* CLASS */))
      : (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("v-if", true),
    (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, "content")
  ], 2 /* CLASS */))
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-style-loader/dist/index.js??clonedRuleSet-1.use[0]!../../../cli/hummer-cli/packages/plugin-build/node_modules/less-loader/dist/cjs.js!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/animation-basic/app.vue?vue&type=style&index=0&id=791d83ee&lang=less&scoped=true&":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-style-loader/dist/index.js??clonedRuleSet-1.use[0]!../../../cli/hummer-cli/packages/plugin-build/node_modules/less-loader/dist/cjs.js!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/animation-basic/app.vue?vue&type=style&index=0&id=791d83ee&lang=less&scoped=true& ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hummer/tenon-vue */ "./node_modules/@hummer/tenon-vue/dist/tenon-vue.es.js");

    
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function(){
      
    var ruleSetMap = {"global":{"classList":[]},"data-v-791d83ee":{"classList":[{"selector":"page","n_selector":{"next":null,"value":"page","matchType":0,"relation":0},"style":{"width":"100%","height":"100%","backgroundColor":"#eeeeee"},"matchType":0},{"selector":"demo-item","n_selector":{"next":null,"value":"demo-item","matchType":0,"relation":0},"style":{"paddingTop":"20.00hm","paddingRight":"0","paddingBottom":"20.00hm","paddingLeft":"0","backgroundColor":"#ffffff","width":"100%","marginBottom":"20.00hm"},"matchType":0},{"selector":"item-title","n_selector":{"next":null,"value":"item-title","matchType":0,"relation":0},"style":{"textAlign":"center"},"matchType":0},{"selector":"item-title-text","n_selector":{"next":null,"value":"item-title-text","matchType":0,"relation":0},"style":{"textAlign":"center","fontSize":"28.00hm"},"matchType":0},{"selector":"item-container","n_selector":{"next":null,"value":"item-container","matchType":0,"relation":0},"style":{"marginTop":"20.00hm"},"matchType":0},{"selector":"box","n_selector":{"next":null,"value":"box","matchType":0,"relation":0},"style":{"marginTop":"10.00hm","marginRight":"10.00hm","marginBottom":"10.00hm","marginLeft":"10.00hm","width":"100.00hm","height":"100.00hm","backgroundColor":"#fa9153"},"matchType":0},{"selector":"box-opacity-hide","n_selector":{"next":null,"value":"box-opacity-hide","matchType":0,"relation":0},"style":{"opacity":"0"},"matchType":0},{"selector":"box-flex-row","n_selector":{"next":null,"value":"box-flex-row","matchType":0,"relation":0},"style":{"display":"flex","flexDirection":"row"},"matchType":0},{"selector":"warning-text","n_selector":{"next":null,"value":"warning-text","matchType":0,"relation":0},"style":{"paddingTop":"0","paddingRight":"20.00hm","paddingBottom":"0","paddingLeft":"20.00hm","color":"#ff0000"},"matchType":0}]}};
    var options = {"scoped":true,"id":"data-v-791d83ee","packageName":"@hummer/tenon-vue"};
  
      return (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.collectStyle)(ruleSetMap, options);
    })());
  

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-style-loader/dist/index.js??clonedRuleSet-1.use[0]!../../../cli/hummer-cli/packages/plugin-build/node_modules/less-loader/dist/cjs.js!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/component/CommonPage.vue?vue&type=style&index=0&lang=less&":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-style-loader/dist/index.js??clonedRuleSet-1.use[0]!../../../cli/hummer-cli/packages/plugin-build/node_modules/less-loader/dist/cjs.js!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/component/CommonPage.vue?vue&type=style&index=0&lang=less& ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hummer/tenon-vue */ "./node_modules/@hummer/tenon-vue/dist/tenon-vue.es.js");

    
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function(){
      
    var ruleSetMap = {"global":{"classList":[{"selector":"page","n_selector":{"next":null,"value":"page","matchType":0,"relation":0},"style":{"width":"100%","height":"100%"},"matchType":0},{"selector":"titleBar","n_selector":{"next":null,"value":"titleBar","matchType":0,"relation":1},"style":{"flexDirection":"row","width":"100%","height":"52","justifyContent":"center","alignItems":"center","backgroundColor":"#f8f8f8d2"},"matchType":0},{"selector":"imageWrapper","n_selector":{"next":null,"value":"imageWrapper","matchType":0,"relation":1},"style":{"paddingTop":"8","paddingRight":"8","paddingBottom":"8","paddingLeft":"8","position":"absolute","left":"0","width":"40","height":"40","marginLeft":"4"},"matchType":0},{"selector":"navigatorBackImage","n_selector":{"next":null,"value":"navigatorBackImage","matchType":0,"relation":1},"style":{"width":"22","height":"22"},"matchType":0},{"selector":"titleView","n_selector":{"next":null,"value":"titleView","matchType":0,"relation":1},"style":{"color":"\"#000000\"","fontSize":"20"},"matchType":0},{"selector":"line","n_selector":{"next":null,"value":"line","matchType":0,"relation":1},"style":{"position":"absolute","bottom":"0","width":"100%","height":"1px","backgroundColor":"#00000040"},"matchType":0},{"selector":"displayLayout","n_selector":{"next":null,"value":"displayLayout","matchType":0,"relation":1},"style":{"paddingTop":"24","paddingRight":"24","paddingBottom":"24","paddingLeft":"24","width":"100%","backgroundColor":"#ffffff","justifyContent":"center","alignItems":"center"},"matchType":0},{"selector":"groupTitle","n_selector":{"next":null,"value":"groupTitle","matchType":0,"relation":1},"style":{"color":"#808080","fontSize":"14","marginLeft":"16","marginTop":"24","marginBottom":"4"},"matchType":0},{"selector":"groupContent","n_selector":{"next":null,"value":"groupContent","matchType":0,"relation":1},"style":{"flexDirection":"row","width":"100%","flexWrap":"wrap","backgroundColor":"#ffffff","paddingRight":"16","paddingTop":"4","paddingBottom":"4","paddingLeft":"20"},"matchType":0},{"selector":"groupText","n_selector":{"next":null,"value":"groupText","matchType":0,"relation":1},"style":{"fontSize":"10","color":"#000000","textAlign":"center","width":"36","height":"24","marginTop":"6","marginBottom":"6"},"matchType":0},{"selector":"groupRadius","n_selector":{"next":null,"value":"groupRadius","matchType":0,"relation":1},"style":{"marginTop":"4","marginRight":"4","marginBottom":"4","marginLeft":"4","borderColor":"#000000","width":"30","height":"30","backgroundColor":"#15d0b4"},"matchType":0},{"selector":"groupBorder","n_selector":{"next":null,"value":"groupBorder","matchType":0,"relation":1},"style":{"marginTop":"4","marginRight":"4","marginBottom":"4","marginLeft":"4","width":"30","height":"30","backgroundColor":"#15d0b4","borderColor":"#000000","borderWidth":"1"},"matchType":0},{"selector":"groupShadow","n_selector":{"next":null,"value":"groupShadow","matchType":0,"relation":1},"style":{"marginTop":"4","marginRight":"4","marginBottom":"4","marginLeft":"4","width":"30","height":"30","backgroundColor":"#15d0b4"},"matchType":0},{"selector":"scrollContentView","n_selector":{"next":null,"value":"scrollContentView","matchType":0,"relation":1},"style":{"width":"100%","flexGrow":"1","flexShrink":"1","backgroundColor":"#eeeeee70"},"matchType":0},{"selector":"displayView","n_selector":{"next":null,"value":"displayView","matchType":0,"relation":1},"style":{"overflow":"hidden"},"matchType":0}]}};
    var options = {"scoped":false,"id":"data-v-undefined","packageName":"@hummer/tenon-vue"};
  
      return (0,_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.collectStyle)(ruleSetMap, options);
    })());
  

/***/ }),

/***/ "./node_modules/@hummer/tenon-dev-tool/dist/tenon-dev-tool.cjs.js":
/*!************************************************************************!*\
  !*** ./node_modules/@hummer/tenon-dev-tool/dist/tenon-dev-tool.cjs.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var NODE_VIEW = "Symbol(NODE_VIEW)";
var NODE_TEXT = "Symbol(NODE_TEXT)";
var NODE_IMAGE = "Symbol(NODE_IMAGE)";
var NODE_BUTTON = "Symbol(NODE_BUTTON)";
var NODE_TEXTAREA = "Symbol(NODE_TEXTAREA)";
var NODE_INPUT = "Symbol(NODE_INPUT)";
var NODE_SWITCH = "Symbol(NODE_SWITCH)";
var NODE_SCROLLER = "Symbol(NODE_SCROLLER)";
var NODE_REFRESH = "Symbol(NODE_REFRESH)";
var NODE_LOADMORE = "Symbol(NODE_LOADMORE)";
var HUMMER_VIEW = 'View';
var HUMMER_TEXT = 'Text';
var HUMMER_BUTTON = 'Button';
var HUMMER_IMAGE = 'Image';
var HUMMER_INPUT = 'Input';
var HUMMER_TEXTAREA = 'TextArea';
var HUMMER_SWITCH = 'Switch';
var HUMMER_LOADING = 'Loading';
var HUMMER_SCROLLER = 'Scroller';
var HUMMER_HORIZONTALSCROLLER = 'HorizontalScroller';
var HUMMER_LIST = 'List';
var HUMMER_VIEWPAGER = 'ViewPager';
var HUMMER_DIALOG = 'Dialog';

function getElementTagMap() {
  var tagMap = new Map();
  tagMap.set(NODE_VIEW, 'view');
  tagMap.set(NODE_TEXT, 'text');
  tagMap.set(NODE_IMAGE, 'image');
  tagMap.set(NODE_BUTTON, 'button');
  tagMap.set(NODE_TEXTAREA, 'textarea');
  tagMap.set(NODE_INPUT, 'input');
  tagMap.set(NODE_SWITCH, 'switch');
  tagMap.set(NODE_SCROLLER, 'scroller');
  tagMap.set(NODE_REFRESH, 'refresh');
  tagMap.set(NODE_LOADMORE, 'loadmore');
  tagMap.set(HUMMER_VIEW, 'view');
  tagMap.set(HUMMER_TEXT, 'text');
  tagMap.set(HUMMER_BUTTON, 'button');
  tagMap.set(HUMMER_IMAGE, 'image');
  tagMap.set(HUMMER_INPUT, 'input');
  tagMap.set(HUMMER_TEXTAREA, 'textarea');
  tagMap.set(HUMMER_SWITCH, 'switch');
  tagMap.set(HUMMER_LOADING, 'loading');
  tagMap.set(HUMMER_SCROLLER, 'scroller');
  tagMap.set(HUMMER_HORIZONTALSCROLLER, 'horizontalscroller');
  tagMap.set(HUMMER_LIST, 'list');
  tagMap.set(HUMMER_VIEWPAGER, 'viewpager');
  tagMap.set(HUMMER_DIALOG, 'view');
  return tagMap;
}

var ELEMNT_TAG_MAP = getElementTagMap();

var getPartUrlByParam = function getPartUrlByParam(url, param) {
  var reg = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;
  var res = reg.exec(url);
  var fields = ['url', 'scheme', 'slash', 'host', 'port', 'path', 'query', 'hash'];
  return res[fields.indexOf(param)];
};

var formatNode = function formatNode(node) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'tenon-vue';
  var formatedNode = Object.create({});

  var treeTraveler = function treeTraveler(node, rootView) {
    processView(node, rootView, type);

    if (node.children) {
      var arr = Array.from(node.children);

      if (arr.length) {
        rootView.children = Array.apply(null, new Array(arr.length)).map(function () {
          return {};
        });
        arr.forEach(function (n, i) {
          treeTraveler(n, rootView.children[i]);
        });
      }
    }
  };

  treeTraveler(node, formatedNode);
  return formatedNode;
};

var getViewData = function getViewData(container) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'tenon-vue';
  var simpleRoot = Object.create({});
  var viewMap = Object.create({});

  var treeTraveler = function treeTraveler(node, rootView) {
    var _a, _b, _c, _d, _e;

    if (node === null || node === void 0 ? void 0 : node.tagName) {
      node.name = node === null || node === void 0 ? void 0 : node.tagName.toLowerCase();
      node.style = (_a = node === null || node === void 0 ? void 0 : node.element) === null || _a === void 0 ? void 0 : _a._style;
      node.__view_id = (_b = node === null || node === void 0 ? void 0 : node.element) === null || _b === void 0 ? void 0 : _b.objID;

      switch (node.name) {
        case 'text':
          node.text = (_c = node.element) === null || _c === void 0 ? void 0 : _c._text;
          break;

        case 'image':
          node.src = (_d = node.element) === null || _d === void 0 ? void 0 : _d._src;
          break;
      }
    }

    rootView = Object.assign(rootView, node);
    viewMap[rootView.__view_id] = node;
    delete rootView.children;
    delete rootView.element;

    if (node.name === 'template' && node !== container) {
      if (node === null || node === void 0 ? void 0 : node.element.dbg_getDescription) {
        node === null || node === void 0 ? void 0 : node.element.dbg_getDescription(function (thatNode) {
          var _a;

          if (thatNode === null || thatNode === void 0 ? void 0 : thatNode.children) {
            thatNode.children.forEach(function (item, index) {
              var _a, _b;

              thatNode.children[index].name = item === null || item === void 0 ? void 0 : item.tagName;
              thatNode.children[index].style = (_a = item === null || item === void 0 ? void 0 : item.element) === null || _a === void 0 ? void 0 : _a._style;
              thatNode.children[index].__view_id = (_b = item === null || item === void 0 ? void 0 : item.element) === null || _b === void 0 ? void 0 : _b.objID;

              switch (item.name) {
                case 'Text':
                  thatNode.children[index].text = item.element._text;
                  break;

                case 'Image':
                  thatNode.children[index].src = item.element._src;
                  break;
              }
            });
            node.children = thatNode.children;
          }

          node.name = thatNode.tagName.toLowerCase();
          rootView.name = node.name;

          if (node.children && node.children.length > 0) {
            rootView.children = Array.apply(null, new Array(((_a = node === null || node === void 0 ? void 0 : node.children) === null || _a === void 0 ? void 0 : _a.length) || 0)).map(function () {
              return {};
            });
            var arr = Array.from(node.children);
            arr.forEach(function (n, i) {
              treeTraveler(n, rootView.children[i]);
            });
          }
        });
      }
    } else {
      if (node.children && node.children.length > 0) {
        rootView.children = Array.apply(null, new Array(((_e = node === null || node === void 0 ? void 0 : node.children) === null || _e === void 0 ? void 0 : _e.length) || 0)).map(function () {
          return {};
        });
        var arr = Array.from(node.children);
        arr.forEach(function (n, i) {
          treeTraveler(n, rootView.children[i]);
        });
      }
    }
  };

  treeTraveler(container, simpleRoot);
  return {
    simpleRoot,
    viewMap
  };
};

var processView = function processView(node, rootView) {
  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'tenon-vue';

  var _a;

  var nameKey = '__NAME',
      idKey = '__view_id',
      textKey = '_text',
      srcKey = '_src',
      elementKey = 'element',
      styleKey = 'style',
      classNameKey = 'className';
  rootView.style = node[styleKey];

  switch (type) {
    case 'hummer':
      nameKey = 'tagName';
      idKey = 'id';
      textKey = 'content';
      srcKey = 'content';
      rootView.style = node.element.style;
      break;
  }

  rootView.__view_id = node[idKey];
  rootView.name = node[nameKey] && ELEMNT_TAG_MAP.get(node[nameKey].toString()) || 'template';
  rootView.element = node[elementKey];
  rootView.className = node[classNameKey];
  ((_a = node[elementKey]) === null || _a === void 0 ? void 0 : _a.node) && (node[elementKey].node.__view_id = node[idKey]);

  switch (rootView.name) {
    case 'text':
      rootView.text = node[textKey];
      break;

    case 'image':
      rootView.src = node[srcKey];
      break;
  }
};

var updateOptions = function updateOptions(oldOptions, newOptions) {
  for (var key in oldOptions) {
    if (!(key in newOptions)) {
      delete oldOptions[key];
    }
  }

  for (var _key in newOptions) {
    oldOptions[_key] = newOptions[_key];
  }

  return oldOptions;
};

var log = function log(str) {};

var error = function error(str) {};

var guid = function guid() {
  function S4() {
    return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
  }

  return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
};

var _GLOBAL__ = __GLOBAL__,
    __storageInterceptFlag__ = _GLOBAL__.__storageInterceptFlag__,
    Storage = _GLOBAL__.Storage,
    Memory$1 = _GLOBAL__.Memory;

var getAllStorage = function getAllStorage(ws, params) {
  var storageAll = Storage.getAll();
  var newStorageAll = [];

  for (var key in storageAll) {
    if (/_#_hummer_.*_#_/.test(key)) {
      continue;
    }

    var item = {
      key: key,
      value: storageAll[key]
    };
    newStorageAll.push(item);
  }

  sendMessage(ws, {
    type: 'storage',
    method: 'setStorageList',
    params: Object.assign(Object.assign({}, params), {
      storageAll: newStorageAll
    })
  });
};

var storageintercept = function storageintercept(ws) {
  __GLOBAL__.__storageInterceptFlag__ = true;
  !__storageInterceptFlag__ && (__GLOBAL__.__storageOriginSet__ = Storage.set, __GLOBAL__.__storageOriginRemove__ = Storage.remove, __GLOBAL__.__storageOriginRemoveAll__ = Storage.removeAll);

  Storage.set = function () {
    if (Memory$1.get("_#_hummer_tenonIp_#_")) {
      sendMessage(ws, {
        type: 'storage',
        method: 'updateStorageList',
        params: {
          tenonIp: Memory$1.get("_#_hummer_tenonIp_#_"),
          key: arguments[0],
          value: arguments[1]
        }
      });
    }

    __GLOBAL__.__storageOriginSet__.apply(this, arguments);
  };

  Storage.remove = function () {
    __GLOBAL__.__storageOriginRemove__.apply(this, arguments);

    if (Memory$1.get("_#_hummer_tenonIp_#_")) {
      getAllStorage(ws, {
        tenonIp: Memory$1.get("_#_hummer_tenonIp_#_")
      });
    }
  };

  Storage.removeAll = function () {
    __GLOBAL__.__storageOriginRemoveAll__.apply(this, arguments);

    if (Memory$1.get("_#_hummer_tenonIp_#_")) {
      sendMessage(ws, {
        type: 'storage',
        method: 'setStorageList',
        params: {
          tenonIp: Memory$1.get("_#_hummer_tenonIp_#_"),
          storageAll: []
        }
      });
    }
  };
};

var _GLOBAL__2 = __GLOBAL__,
    __memoryInterceptFlag__ = _GLOBAL__2.__memoryInterceptFlag__,
    Memory = _GLOBAL__2.Memory;

var getAllMemory = function getAllMemory(ws, params) {
  var memoryAll = Memory.getAll();
  var newMemoryAll = [];

  for (var key in memoryAll) {
    if (/_#_hummer_.*_#_/.test(key)) {
      continue;
    }

    var item = {
      key: key,
      value: memoryAll[key]
    };
    newMemoryAll.push(item);
  }

  sendMessage(ws, {
    type: 'memory',
    method: 'setMemoryList',
    params: Object.assign(Object.assign({}, params), {
      memoryAll: newMemoryAll
    })
  });
};

var memoryintercept = function memoryintercept(ws) {
  __GLOBAL__.__memoryInterceptFlag__ = true;
  !__memoryInterceptFlag__ && (__GLOBAL__.__memoryOriginSet__ = Memory.set, __GLOBAL__.__memoryOriginRemove__ = Memory.remove, __GLOBAL__.__memoryOriginRemoveAll__ = Memory.removeAll);

  Memory.set = function () {
    if (Memory.get("_#_hummer_tenonIp_#_")) {
      sendMessage(ws, {
        type: 'memory',
        method: 'updateMemoryList',
        params: {
          tenonIp: Memory.get("_#_hummer_tenonIp_#_"),
          key: arguments[0],
          value: arguments[1]
        }
      });
    }

    __GLOBAL__.__memoryOriginSet__.apply(this, arguments);
  };

  Memory.remove = function () {
    __GLOBAL__.__memoryOriginRemove__.apply(this, arguments);

    if (Memory.get("_#_hummer_tenonIp_#_")) {
      getAllMemory(ws, {
        tenonIp: Memory.get("_#_hummer_tenonIp_#_")
      });
    }
  };

  Memory.removeAll = function () {
    __GLOBAL__.__memoryOriginRemoveAll__.apply(this, arguments);

    if (Memory.get("_#_hummer_tenonIp_#_")) {
      sendMessage(ws, {
        type: 'memory',
        method: 'setMemoryList',
        params: {
          tenonIp: Memory.get("_#_hummer_tenonIp_#_"),
          memoryAll: []
        }
      });
    }
  };
};

var requestintercept = function requestintercept(ws) {
  var _GLOBAL__3 = __GLOBAL__,
      Request = _GLOBAL__3.Request,
      __requestInterceptFlag__ = _GLOBAL__3.__requestInterceptFlag__;
  __GLOBAL__.__requestInterceptFlag__ = true;
  !__requestInterceptFlag__ && (__GLOBAL__.__requestOriginSend__ = Request.prototype.send);

  Request.prototype.send = function () {
    var _this = this;

    var requestId = guid();
    sendMessage(ws, {
      type: 'netWork',
      method: 'updateNetWorkList',
      params: {
        id: requestId,
        requestInfo: {
          method: this.method,
          header: this.header,
          url: this.url,
          param: this.param
        }
      }
    });
    var callback = arguments[0];

    var mergeCallback = function mergeCallback(res) {
      sendMessage(ws, {
        type: 'netWork',
        method: 'updateNetWorkList',
        params: {
          id: requestId,
          responseInfo: res
        }
      });
      callback.call(_this, res);
    };

    __GLOBAL__.__requestOriginSend__.apply(this, [mergeCallback]);
  };
};

var ws, currentType;

function initSocket(url, handlers) {
  ws = new __GLOBAL__.WebSocket(url);

  ws.onopen = function () {
    log('websocket opened~');
    storageintercept(ws);
    memoryintercept(ws);
    requestintercept(ws);
  };

  ws.onmessage = function (event) {
    log(JSON.stringify(event));
    var msg = JSON.parse(event.data);
    currentType = msg.type || '';

    if (handlers[msg.method]) {
      handlers[msg.method](ws, msg.params);
    }
  };

  ws.onclose = function () {
    ws = null;
    log('websocket closed~');
  };
}

var sendMessage = function sendMessage(ws, options) {
  var type = options.type || currentType;
  var method = options.method || 'ignore';
  var params = options.params || {};
  ws.send(JSON.stringify({
    type,
    method,
    params
  }));
};

var isWebPlatform = __GLOBAL__.Hummer.pageInfo && JSON.stringify(__GLOBAL__.Hummer.pageInfo) === '{}';

function run(container) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'tenon-vue';
  var formatedNode = formatNode(container, type);
  log('Socket Initializing');
  var url = __GLOBAL__.Hummer.pageInfo.url;
  var _GLOBAL__4 = __GLOBAL__,
      Storage = _GLOBAL__4.Storage,
      Memory = _GLOBAL__4.Memory;
  var host = getPartUrlByParam(url, 'host');
  var port = getPartUrlByParam(url, 'port');
  var path = getPartUrlByParam(url, 'path');
  var scheme = getPartUrlByParam(url, 'scheme');

  if (!['http', 'https'].includes(scheme) || !port) {
    error("invalid url[".concat(url, "], initialization failed"));
    return;
  }

  var wsTenonUrl = "ws://".concat(host, ":").concat(port, "/proxy/tenon");

  if (isWebPlatform) {
    wsTenonUrl = 'ws://172.23.166.43:8000/proxy/tenon';
  }

  var viewMap = {},
      viewId,
      view;
  var onSocketMsgHandlers = {
    'getViewTree': function getViewTree(ws, params) {
      var _a;

      var data = getViewData(formatedNode, type);
      viewMap = data.viewMap;

      if ((_a = formatedNode === null || formatedNode === void 0 ? void 0 : formatedNode.element) === null || _a === void 0 ? void 0 : _a.dbg_getDescription) {
        formatedNode.element.dbg_getDescription(function (node) {
          sendMessage(ws, {
            method: 'setViewTree',
            params: Object.assign(Object.assign({}, params), {
              viewTree: [data.simpleRoot],
              path: path,
              baseInfo: __GLOBAL__.Hummer.env
            })
          });
        });
      } else {
        sendMessage(ws, {
          method: 'setViewTree',
          params: Object.assign(Object.assign({}, params), {
            viewTree: [data.simpleRoot],
            path: path,
            baseInfo: __GLOBAL__.Hummer.env
          })
        });
      }
    },
    'getViewInfo': function getViewInfo(ws, params) {
      viewId = params.viewId;
      view = viewMap[viewId];
      view.element.getRect(function (rect) {
        view.element.dbg_highlight && view.element.dbg_highlight(true);
        sendMessage(ws, {
          method: 'setViewInfo',
          params: Object.assign(Object.assign({}, params), {
            rect: rect,
            style: view.style,
            className: view.className || ''
          })
        });
      });
    },
    'setViewStyle': function setViewStyle(ws, params) {
      viewId = params.viewId;
      view = viewMap[viewId];
      var style = params.style;
      view.element.style = updateOptions(view.style, style);
      sendMessage(ws, {
        method: 'setStyleSuccess'
      });
    },
    'setStorage': function setStorage(ws, params) {
      var _params$storage = params.storage,
          type = _params$storage.type,
          key = _params$storage.key,
          value = _params$storage.value;

      switch (type) {
        case 'delete':
          Storage.remove(key);
          break;

        case 'revise':
          Storage.set(key, value);
          break;
      }

      sendMessage(ws, {
        method: 'setStorageSuccess'
      });
    },
    'getStorage': function getStorage(ws, params) {
      Memory.set("_#_hummer_tenonIp_#_", params === null || params === void 0 ? void 0 : params.tenonIp);
      getAllStorage(ws, params);
    },
    'setMemory': function setMemory(ws, params) {
      var _params$memory = params.memory,
          type = _params$memory.type,
          key = _params$memory.key,
          value = _params$memory.value;

      switch (type) {
        case 'delete':
          Memory.remove(key);
          break;

        case 'revise':
          Memory.set(key, value);
          break;
      }

      sendMessage(ws, {
        method: 'setMemorySuccess'
      });
    },
    'getMemory': function getMemory(ws, params) {
      Memory.set("_#_hummer_tenonIp_#_", params === null || params === void 0 ? void 0 : params.tenonIp);
      getAllMemory(ws, params);
    }
  };
  initSocket(wsTenonUrl, onSocketMsgHandlers);
  log('Socket initializing complete');
}

exports.run = run;

/***/ }),

/***/ "./node_modules/@hummer/tenon-vue/dist/tenon-vue.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/@hummer/tenon-vue/dist/tenon-vue.es.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Base": () => (/* binding */ Base),
/* harmony export */   "BaseTransition": () => (/* binding */ BaseTransition),
/* harmony export */   "Button": () => (/* binding */ Button),
/* harmony export */   "Comment": () => (/* binding */ Comment$1),
/* harmony export */   "EffectScope": () => (/* binding */ EffectScope),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "Image": () => (/* binding */ Image),
/* harmony export */   "Input": () => (/* binding */ Input),
/* harmony export */   "KeepAlive": () => (/* binding */ KeepAlive),
/* harmony export */   "MatchType": () => (/* binding */ MatchType),
/* harmony export */   "Page": () => (/* binding */ Page),
/* harmony export */   "ReactiveEffect": () => (/* binding */ ReactiveEffect),
/* harmony export */   "RelationType": () => (/* binding */ RelationType),
/* harmony export */   "RootViewComponent": () => (/* binding */ RootViewComponent),
/* harmony export */   "RuleKeyMap": () => (/* binding */ RuleKeyMap),
/* harmony export */   "Static": () => (/* binding */ Static),
/* harmony export */   "Suspense": () => (/* binding */ Suspense),
/* harmony export */   "Switch": () => (/* binding */ Switch),
/* harmony export */   "Teleport": () => (/* binding */ Teleport),
/* harmony export */   "Text": () => (/* binding */ Text$1),
/* harmony export */   "TextArea": () => (/* binding */ TextArea),
/* harmony export */   "View": () => (/* binding */ View),
/* harmony export */   "appContext": () => (/* binding */ appContext),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* binding */ callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* binding */ callWithErrorHandling),
/* harmony export */   "camelize": () => (/* binding */ camelize$1),
/* harmony export */   "capitalize": () => (/* binding */ capitalize),
/* harmony export */   "cloneVNode": () => (/* binding */ cloneVNode),
/* harmony export */   "collectStyle": () => (/* binding */ collectStyle),
/* harmony export */   "compatUtils": () => (/* binding */ compatUtils),
/* harmony export */   "component": () => (/* binding */ component),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "container": () => (/* binding */ container),
/* harmony export */   "createApp": () => (/* binding */ createApp),
/* harmony export */   "createBlock": () => (/* binding */ createBlock),
/* harmony export */   "createCommentVNode": () => (/* binding */ createCommentVNode),
/* harmony export */   "createElementBlock": () => (/* binding */ createElementBlock),
/* harmony export */   "createElementVNode": () => (/* binding */ createBaseVNode),
/* harmony export */   "createHydrationRenderer": () => (/* binding */ createHydrationRenderer),
/* harmony export */   "createRenderer": () => (/* binding */ createRenderer),
/* harmony export */   "createRootContainer": () => (/* binding */ createRootContainer),
/* harmony export */   "createSlots": () => (/* binding */ createSlots),
/* harmony export */   "createStaticVNode": () => (/* binding */ createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* binding */ createTextVNode),
/* harmony export */   "createVNode": () => (/* binding */ createVNode),
/* harmony export */   "customRef": () => (/* binding */ customRef),
/* harmony export */   "default": () => (/* binding */ index),
/* harmony export */   "defineAsyncComponent": () => (/* binding */ defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* binding */ defineComponent),
/* harmony export */   "defineEmits": () => (/* binding */ defineEmits),
/* harmony export */   "defineExpose": () => (/* binding */ defineExpose),
/* harmony export */   "defineProps": () => (/* binding */ defineProps),
/* harmony export */   "devtools": () => (/* binding */ devtools),
/* harmony export */   "directive": () => (/* binding */ directive),
/* harmony export */   "effect": () => (/* binding */ effect),
/* harmony export */   "effectScope": () => (/* binding */ effectScope),
/* harmony export */   "getClassStyle": () => (/* binding */ getClassStyle),
/* harmony export */   "getComponent": () => (/* binding */ getComponent),
/* harmony export */   "getCurrentInstance": () => (/* binding */ getCurrentInstance),
/* harmony export */   "getCurrentScope": () => (/* binding */ getCurrentScope),
/* harmony export */   "getTransitionRawChildren": () => (/* binding */ getTransitionRawChildren),
/* harmony export */   "guardReactiveProps": () => (/* binding */ guardReactiveProps),
/* harmony export */   "h": () => (/* binding */ h),
/* harmony export */   "handleError": () => (/* binding */ handleError),
/* harmony export */   "initCustomFormatter": () => (/* binding */ initCustomFormatter),
/* harmony export */   "inject": () => (/* binding */ inject),
/* harmony export */   "isMemoSame": () => (/* binding */ isMemoSame),
/* harmony export */   "isProxy": () => (/* binding */ isProxy),
/* harmony export */   "isReactive": () => (/* binding */ isReactive),
/* harmony export */   "isReadonly": () => (/* binding */ isReadonly),
/* harmony export */   "isRef": () => (/* binding */ isRef),
/* harmony export */   "isRuntimeOnly": () => (/* binding */ isRuntimeOnly),
/* harmony export */   "isVNode": () => (/* binding */ isVNode),
/* harmony export */   "markRaw": () => (/* binding */ markRaw),
/* harmony export */   "mergeDefaults": () => (/* binding */ mergeDefaults),
/* harmony export */   "mergeProps": () => (/* binding */ mergeProps),
/* harmony export */   "mixin": () => (/* binding */ mixin),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "normalizeClass": () => (/* binding */ normalizeClass),
/* harmony export */   "normalizeProps": () => (/* binding */ normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* binding */ normalizeStyle),
/* harmony export */   "onActivated": () => (/* binding */ onActivated),
/* harmony export */   "onBeforeMount": () => (/* binding */ onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* binding */ onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* binding */ onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* binding */ onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* binding */ onErrorCaptured),
/* harmony export */   "onMounted": () => (/* binding */ onMounted),
/* harmony export */   "onRenderTracked": () => (/* binding */ onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* binding */ onRenderTriggered),
/* harmony export */   "onScopeDispose": () => (/* binding */ onScopeDispose),
/* harmony export */   "onServerPrefetch": () => (/* binding */ onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* binding */ onUnmounted),
/* harmony export */   "onUpdated": () => (/* binding */ onUpdated),
/* harmony export */   "openBlock": () => (/* binding */ openBlock),
/* harmony export */   "popScopeId": () => (/* binding */ popScopeId),
/* harmony export */   "provide": () => (/* binding */ provide),
/* harmony export */   "proxyRefs": () => (/* binding */ proxyRefs),
/* harmony export */   "pushScopeId": () => (/* binding */ pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* binding */ queuePostFlushCb),
/* harmony export */   "reactive": () => (/* binding */ reactive),
/* harmony export */   "readonly": () => (/* binding */ readonly),
/* harmony export */   "ref": () => (/* binding */ ref),
/* harmony export */   "register": () => (/* binding */ register),
/* harmony export */   "registerRuntimeCompiler": () => (/* binding */ registerRuntimeCompiler),
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "renderApp": () => (/* binding */ renderApp),
/* harmony export */   "renderCustomSlot": () => (/* binding */ renderCustomSlot),
/* harmony export */   "renderList": () => (/* binding */ renderList),
/* harmony export */   "renderSlot": () => (/* binding */ renderSlot),
/* harmony export */   "resolveComponent": () => (/* binding */ resolveComponent),
/* harmony export */   "resolveDirective": () => (/* binding */ resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* binding */ resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* binding */ resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* binding */ resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* binding */ setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* binding */ setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* binding */ setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* binding */ shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* binding */ shallowReadonly),
/* harmony export */   "shallowRef": () => (/* binding */ shallowRef),
/* harmony export */   "ssrContextKey": () => (/* binding */ ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* binding */ ssrUtils),
/* harmony export */   "stop": () => (/* binding */ stop),
/* harmony export */   "toDisplayString": () => (/* binding */ toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* binding */ toHandlerKey),
/* harmony export */   "toHandlers": () => (/* binding */ toHandlers),
/* harmony export */   "toRaw": () => (/* binding */ toRaw),
/* harmony export */   "toRef": () => (/* binding */ toRef),
/* harmony export */   "toRefs": () => (/* binding */ toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* binding */ transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* binding */ triggerRef),
/* harmony export */   "unref": () => (/* binding */ unref),
/* harmony export */   "use": () => (/* binding */ use),
/* harmony export */   "useAttrs": () => (/* binding */ useAttrs),
/* harmony export */   "useSSRContext": () => (/* binding */ useSSRContext),
/* harmony export */   "useSlots": () => (/* binding */ useSlots),
/* harmony export */   "useTransitionState": () => (/* binding */ useTransitionState),
/* harmony export */   "vAnimation": () => (/* binding */ vAnimation),
/* harmony export */   "vModelSwitch": () => (/* binding */ vModelSwitch),
/* harmony export */   "vModelText": () => (/* binding */ vModelText),
/* harmony export */   "vShow": () => (/* binding */ vShow),
/* harmony export */   "version": () => (/* binding */ version),
/* harmony export */   "warn": () => (/* binding */ warn),
/* harmony export */   "watch": () => (/* binding */ watch),
/* harmony export */   "watchEffect": () => (/* binding */ watchEffect),
/* harmony export */   "watchPostEffect": () => (/* binding */ watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* binding */ watchSyncEffect),
/* harmony export */   "withAsyncContext": () => (/* binding */ withAsyncContext),
/* harmony export */   "withCtx": () => (/* binding */ withCtx),
/* harmony export */   "withDefaults": () => (/* binding */ withDefaults),
/* harmony export */   "withDirectives": () => (/* binding */ withDirectives),
/* harmony export */   "withMemo": () => (/* binding */ withMemo),
/* harmony export */   "withScopeId": () => (/* binding */ withScopeId)
/* harmony export */ });
/* harmony import */ var _Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/inherits */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/createSuper */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/createSuper.js");
/* harmony import */ var _Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js");
/* harmony import */ var _Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/classCallCheck */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/createClass */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/slicedToArray */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/toConsumableArray */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");








var global$1 = typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */

function makeMap$1(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return !!map[val.toLowerCase()];
  } : function (val) {
    return !!map[val];
  };
}

var GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' + 'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' + 'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
var isGloballyWhitelisted = /*#__PURE__*/makeMap$1(GLOBALS_WHITE_LISTED);

function normalizeStyle(value) {
  if (isArray(value)) {
    var res = {};

    for (var i = 0; i < value.length; i++) {
      var item = value[i];
      var normalized = isString(item) ? parseStringStyle$1(item) : normalizeStyle(item);

      if (normalized) {
        for (var key in normalized) {
          res[key] = normalized[key];
        }
      }
    }

    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject$1(value)) {
    return value;
  }
}

var listDelimiterRE$1 = /;(?![^(]*\))/g;
var propertyDelimiterRE$1 = /:(.+)/;

function parseStringStyle$1(cssText) {
  var ret = {};
  cssText.split(listDelimiterRE$1).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiterRE$1);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}

function normalizeClass(value) {
  var res = '';

  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (var i = 0; i < value.length; i++) {
      var normalized = normalizeClass(value[i]);

      if (normalized) {
        res += normalized + ' ';
      }
    }
  } else if (isObject$1(value)) {
    for (var name in value) {
      if (value[name]) {
        res += name + ' ';
      }
    }
  }

  return res.trim();
}

function normalizeProps(props) {
  if (!props) return null;
  var klass = props.class,
      style = props.style;

  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }

  if (style) {
    props.style = normalizeStyle(style);
  }

  return props;
}
/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */


var toDisplayString = function toDisplayString(val) {
  return val == null ? '' : isArray(val) || isObject$1(val) && (val.toString === objectToString || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};

var replacer = function replacer(_key, val) {
  // can't use isRef here since @vue/shared has no deps
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      ["Map(".concat(val.size, ")")]: (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(val.entries()).reduce(function (entries, _ref) {
        var _ref2 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_6__["default"])(_ref, 2),
            key = _ref2[0],
            val = _ref2[1];

        entries["".concat(key, " =>")] = val;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      ["Set(".concat(val.size, ")")]: (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(val.values())
    };
  } else if (isObject$1(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }

  return val;
};

var EMPTY_OBJ = {};
var EMPTY_ARR = [];

var NOOP = function NOOP() {};
/**
 * Always return false.
 */


var NO = function NO() {
  return false;
};

var onRE = /^on[^a-z]/;

var isOn$1 = function isOn$1(key) {
  return onRE.test(key);
};

var isModelListener = function isModelListener(key) {
  return key.startsWith('onUpdate:');
};

var extend$2 = Object.assign;

var remove$1 = function remove$1(arr, el) {
  var i = arr.indexOf(el);

  if (i > -1) {
    arr.splice(i, 1);
  }
};

var hasOwnProperty = Object.prototype.hasOwnProperty;

var hasOwn = function hasOwn(val, key) {
  return hasOwnProperty.call(val, key);
};

var isArray = Array.isArray;

var isMap = function isMap(val) {
  return toTypeString(val) === '[object Map]';
};

var isSet = function isSet(val) {
  return toTypeString(val) === '[object Set]';
};

var isFunction$1 = function isFunction$1(val) {
  return typeof val === 'function';
};

var isString = function isString(val) {
  return typeof val === 'string';
};

var isSymbol = function isSymbol(val) {
  return typeof val === 'symbol';
};

var isObject$1 = function isObject$1(val) {
  return val !== null && typeof val === 'object';
};

var isPromise$1 = function isPromise$1(val) {
  return isObject$1(val) && isFunction$1(val.then) && isFunction$1(val.catch);
};

var objectToString = Object.prototype.toString;

var toTypeString = function toTypeString(value) {
  return objectToString.call(value);
};

var toRawType = function toRawType(value) {
  // extract "RawType" from strings like "[object RawType]"
  return toTypeString(value).slice(8, -1);
};

var isPlainObject = function isPlainObject(val) {
  return toTypeString(val) === '[object Object]';
};

var isIntegerKey = function isIntegerKey(key) {
  return isString(key) && key !== 'NaN' && key[0] !== '-' && '' + parseInt(key, 10) === key;
};

var isReservedProp = /*#__PURE__*/makeMap$1( // the leading comma is intentional so empty string "" is also included
',key,ref,' + 'onVnodeBeforeMount,onVnodeMounted,' + 'onVnodeBeforeUpdate,onVnodeUpdated,' + 'onVnodeBeforeUnmount,onVnodeUnmounted');

var cacheStringFunction = function cacheStringFunction(fn) {
  var cache = Object.create(null);
  return function (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};

var camelizeRE$1 = /-(\w)/g;
/**
 * @private
 */

var camelize$1 = cacheStringFunction(function (str) {
  return str.replace(camelizeRE$1, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
var hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */

var hyphenate = cacheStringFunction(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * @private
 */

var capitalize = cacheStringFunction(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * @private
 */

var toHandlerKey = cacheStringFunction(function (str) {
  return str ? "on".concat(capitalize(str)) : "";
}); // compare whether a value has changed, accounting for NaN.

var hasChanged = function hasChanged(value, oldValue) {
  return !Object.is(value, oldValue);
};

var invokeArrayFns = function invokeArrayFns(fns, arg) {
  for (var i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};

var def = function def(obj, key, value) {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};

var toNumber = function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
};

var _globalThis;

var getGlobalThis = function getGlobalThis() {
  return _globalThis || (_globalThis = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof global$1 !== 'undefined' ? global$1 : {});
};

var activeEffectScope;
var effectScopeStack = [];

var EffectScope = /*#__PURE__*/function () {
  function EffectScope() {
    var detached = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, EffectScope);

    this.active = true;
    this.effects = [];
    this.cleanups = [];

    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope;
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(EffectScope, [{
    key: "run",
    value: function run(fn) {
      if (this.active) {
        try {
          this.on();
          return fn();
        } finally {
          this.off();
        }
      }
    }
  }, {
    key: "on",
    value: function on() {
      if (this.active) {
        effectScopeStack.push(this);
        activeEffectScope = this;
      }
    }
  }, {
    key: "off",
    value: function off() {
      if (this.active) {
        effectScopeStack.pop();
        activeEffectScope = effectScopeStack[effectScopeStack.length - 1];
      }
    }
  }, {
    key: "stop",
    value: function stop(fromParent) {
      if (this.active) {
        this.effects.forEach(function (e) {
          return e.stop();
        });
        this.cleanups.forEach(function (cleanup) {
          return cleanup();
        });

        if (this.scopes) {
          this.scopes.forEach(function (e) {
            return e.stop(true);
          });
        } // nested scope, dereference from parent to avoid memory leaks


        if (this.parent && !fromParent) {
          // optimized O(1) removal
          var last = this.parent.scopes.pop();

          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }

        this.active = false;
      }
    }
  }]);

  return EffectScope;
}();

function effectScope(detached) {
  return new EffectScope(detached);
}

function recordEffectScope(effect, scope) {
  scope = scope || activeEffectScope;

  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}

function getCurrentScope() {
  return activeEffectScope;
}

function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}

var createDep = function createDep(effects) {
  var dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};

var wasTracked = function wasTracked(dep) {
  return (dep.w & trackOpBit) > 0;
};

var newTracked = function newTracked(dep) {
  return (dep.n & trackOpBit) > 0;
};

var initDepMarkers = function initDepMarkers(_ref3) {
  var deps = _ref3.deps;

  if (deps.length) {
    for (var i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit; // set was tracked
    }
  }
};

var finalizeDepMarkers = function finalizeDepMarkers(effect) {
  var deps = effect.deps;

  if (deps.length) {
    var ptr = 0;

    for (var i = 0; i < deps.length; i++) {
      var dep = deps[i];

      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      } // clear bits


      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }

    deps.length = ptr;
  }
};

var targetMap = new WeakMap(); // The number of effects currently being tracked recursively.

var effectTrackDepth = 0;
var trackOpBit = 1;
/**
 * The bitwise track markers support at most 30 levels op recursion.
 * This value is chosen to enable modern JS engines to use a SMI on all platforms.
 * When recursion depth is greater, fall back to using a full cleanup.
 */

var maxMarkerBits = 30;
var effectStack = [];
var activeEffect;
var ITERATE_KEY = Symbol('');
var MAP_KEY_ITERATE_KEY = Symbol('');

var ReactiveEffect = /*#__PURE__*/function () {
  function ReactiveEffect(fn) {
    var scheduler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var scope = arguments.length > 2 ? arguments[2] : undefined;

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, ReactiveEffect);

    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    recordEffectScope(this, scope);
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(ReactiveEffect, [{
    key: "run",
    value: function run() {
      if (!this.active) {
        return this.fn();
      }

      if (!effectStack.includes(this)) {
        try {
          effectStack.push(activeEffect = this);
          enableTracking();
          trackOpBit = 1 << ++effectTrackDepth;

          if (effectTrackDepth <= maxMarkerBits) {
            initDepMarkers(this);
          } else {
            cleanupEffect(this);
          }

          return this.fn();
        } finally {
          if (effectTrackDepth <= maxMarkerBits) {
            finalizeDepMarkers(this);
          }

          trackOpBit = 1 << --effectTrackDepth;
          resetTracking();
          effectStack.pop();
          var n = effectStack.length;
          activeEffect = n > 0 ? effectStack[n - 1] : undefined;
        }
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this.active) {
        cleanupEffect(this);

        if (this.onStop) {
          this.onStop();
        }

        this.active = false;
      }
    }
  }]);

  return ReactiveEffect;
}();

function cleanupEffect(effect) {
  var deps = effect.deps;

  if (deps.length) {
    for (var i = 0; i < deps.length; i++) {
      deps[i].delete(effect);
    }

    deps.length = 0;
  }
}

function effect(fn, options) {
  if (fn.effect) {
    fn = fn.effect.fn;
  }

  var _effect = new ReactiveEffect(fn);

  if (options) {
    extend$2(_effect, options);
    if (options.scope) recordEffectScope(_effect, options.scope);
  }

  if (!options || !options.lazy) {
    _effect.run();
  }

  var runner = _effect.run.bind(_effect);

  runner.effect = _effect;
  return runner;
}

function stop(runner) {
  runner.effect.stop();
}

var shouldTrack = true;
var trackStack = [];

function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}

function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}

function resetTracking() {
  var last = trackStack.pop();
  shouldTrack = last === undefined ? true : last;
}

function track(target, type, key) {
  if (!isTracking()) {
    return;
  }

  var depsMap = targetMap.get(target);

  if (!depsMap) {
    targetMap.set(target, depsMap = new Map());
  }

  var dep = depsMap.get(key);

  if (!dep) {
    depsMap.set(key, dep = createDep());
  }

  trackEffects(dep);
}

function isTracking() {
  return shouldTrack && activeEffect !== undefined;
}

function trackEffects(dep, debuggerEventExtraInfo) {
  var shouldTrack = false;

  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit; // set newly tracked

      shouldTrack = !wasTracked(dep);
    }
  } else {
    // Full cleanup mode.
    shouldTrack = !dep.has(activeEffect);
  }

  if (shouldTrack) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}

function trigger(target, type, key, newValue, oldValue, oldTarget) {
  var depsMap = targetMap.get(target);

  if (!depsMap) {
    // never been tracked
    return;
  }

  var deps = [];

  if (type === "clear"
  /* CLEAR */
  ) {
    // collection being cleared
    // trigger all effects for target
    deps = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(depsMap.values());
  } else if (key === 'length' && isArray(target)) {
    depsMap.forEach(function (dep, key) {
      if (key === 'length' || key >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    // schedule runs for SET | ADD | DELETE
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    } // also run for iteration key on ADD | DELETE | Map.SET


    switch (type) {
      case "add"
      /* ADD */
      :
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));

          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          // new index added to array -> length changes
          deps.push(depsMap.get('length'));
        }

        break;

      case "delete"
      /* DELETE */
      :
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));

          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }

        break;

      case "set"
      /* SET */
      :
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }

        break;
    }
  }

  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    var effects = [];

    var _iterator = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_3__["default"])(deps),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var dep = _step.value;

        if (dep) {
          effects.push.apply(effects, (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(dep));
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    {
      triggerEffects(createDep(effects));
    }
  }
}

function triggerEffects(dep, debuggerEventExtraInfo) {
  // spread into array for stabilization
  var _iterator2 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_3__["default"])(isArray(dep) ? dep : (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(dep)),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _effect2 = _step2.value;

      if (_effect2 !== activeEffect || _effect2.allowRecurse) {
        if (_effect2.scheduler) {
          _effect2.scheduler();
        } else {
          _effect2.run();
        }
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
}

var isNonTrackableKeys = /*#__PURE__*/makeMap$1("__proto__,__v_isRef,__isVue");
var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map(function (key) {
  return Symbol[key];
}).filter(isSymbol));
var get = /*#__PURE__*/createGetter();
var shallowGet = /*#__PURE__*/createGetter(false, true);
var readonlyGet = /*#__PURE__*/createGetter(true);
var shallowReadonlyGet = /*#__PURE__*/createGetter(true, true);
var arrayInstrumentations = /*#__PURE__*/createArrayInstrumentations();

function createArrayInstrumentations() {
  var instrumentations = {};
  ['includes', 'indexOf', 'lastIndexOf'].forEach(function (key) {
    instrumentations[key] = function () {
      var arr = toRaw(this);

      for (var i = 0, l = this.length; i < l; i++) {
        track(arr, "get"
        /* GET */
        , i + '');
      } // we run the method using the original args first (which may be reactive)


      for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var res = arr[key].apply(arr, args);

      if (res === -1 || res === false) {
        // if that didn't work, run it again using raw values.
        return arr[key].apply(arr, (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(args.map(toRaw)));
      } else {
        return res;
      }
    };
  });
  ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(function (key) {
    instrumentations[key] = function () {
      pauseTracking();

      for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}

function createGetter() {
  var isReadonly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var shallow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return function get(target, key, receiver) {
    if (key === "__v_isReactive"
    /* IS_REACTIVE */
    ) {
      return !isReadonly;
    } else if (key === "__v_isReadonly"
    /* IS_READONLY */
    ) {
      return isReadonly;
    } else if (key === "__v_raw"
    /* RAW */
    && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }

    var targetIsArray = isArray(target);

    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }

    var res = Reflect.get(target, key, receiver);

    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }

    if (!isReadonly) {
      track(target, "get"
      /* GET */
      , key);
    }

    if (shallow) {
      return res;
    }

    if (isRef(res)) {
      // ref unwrapping - does not apply for Array + integer key.
      var shouldUnwrap = !targetIsArray || !isIntegerKey(key);
      return shouldUnwrap ? res.value : res;
    }

    if (isObject$1(res)) {
      // Convert returned value into a proxy as well. we do the isObject check
      // here to avoid invalid value warning. Also need to lazy access readonly
      // and reactive here to avoid circular dependency.
      return isReadonly ? readonly(res) : reactive(res);
    }

    return res;
  };
}

var set = /*#__PURE__*/createSetter();
var shallowSet = /*#__PURE__*/createSetter(true);

function createSetter() {
  var shallow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return function set(target, key, value, receiver) {
    var oldValue = target[key];

    if (!shallow) {
      value = toRaw(value);
      oldValue = toRaw(oldValue);

      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }

    var hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    var result = Reflect.set(target, key, value, receiver); // don't trigger if target is something up in the prototype chain of original

    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add"
        /* ADD */
        , key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set"
        /* SET */
        , key, value);
      }
    }

    return result;
  };
}

function deleteProperty(target, key) {
  var hadKey = hasOwn(target, key);
  target[key];
  var result = Reflect.deleteProperty(target, key);

  if (result && hadKey) {
    trigger(target, "delete"
    /* DELETE */
    , key, undefined);
  }

  return result;
}

function has(target, key) {
  var result = Reflect.has(target, key);

  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has"
    /* HAS */
    , key);
  }

  return result;
}

function ownKeys(target) {
  track(target, "iterate"
  /* ITERATE */
  , isArray(target) ? 'length' : ITERATE_KEY);
  return Reflect.ownKeys(target);
}

var mutableHandlers = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys
};
var readonlyHandlers = {
  get: readonlyGet,

  set(target, key) {
    return true;
  },

  deleteProperty(target, key) {
    return true;
  }

};
var shallowReactiveHandlers = /*#__PURE__*/extend$2({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
}); // Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.

var shallowReadonlyHandlers = /*#__PURE__*/extend$2({}, readonlyHandlers, {
  get: shallowReadonlyGet
});

var toReactive = function toReactive(value) {
  return isObject$1(value) ? reactive(value) : value;
};

var toReadonly = function toReadonly(value) {
  return isObject$1(value) ? readonly(value) : value;
};

var toShallow = function toShallow(value) {
  return value;
};

var getProto = function getProto(v) {
  return Reflect.getPrototypeOf(v);
};

function get$1(target, key) {
  var isReadonly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isShallow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  // #1772: readonly(reactive(Map)) should return readonly + reactive version
  // of the value
  target = target["__v_raw"
  /* RAW */
  ];
  var rawTarget = toRaw(target);
  var rawKey = toRaw(key);

  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "get"
    /* GET */
    , key);
  }

  !isReadonly && track(rawTarget, "get"
  /* GET */
  , rawKey);

  var _getProto = getProto(rawTarget),
      has = _getProto.has;

  var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;

  if (has.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    // #3602 readonly(reactive(Map))
    // ensure that the nested reactive `Map` can do tracking for itself
    target.get(key);
  }
}

function has$1(key) {
  var isReadonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var target = this["__v_raw"
  /* RAW */
  ];
  var rawTarget = toRaw(target);
  var rawKey = toRaw(key);

  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "has"
    /* HAS */
    , key);
  }

  !isReadonly && track(rawTarget, "has"
  /* HAS */
  , rawKey);
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}

function size(target) {
  var isReadonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  target = target["__v_raw"
  /* RAW */
  ];
  !isReadonly && track(toRaw(target), "iterate"
  /* ITERATE */
  , ITERATE_KEY);
  return Reflect.get(target, 'size', target);
}

function add(value) {
  value = toRaw(value);
  var target = toRaw(this);
  var proto = getProto(target);
  var hadKey = proto.has.call(target, value);

  if (!hadKey) {
    target.add(value);
    trigger(target, "add"
    /* ADD */
    , value, value);
  }

  return this;
}

function set$1(key, value) {
  value = toRaw(value);
  var target = toRaw(this);

  var _getProto2 = getProto(target),
      has = _getProto2.has,
      get = _getProto2.get;

  var hadKey = has.call(target, key);

  if (!hadKey) {
    key = toRaw(key);
    hadKey = has.call(target, key);
  }

  var oldValue = get.call(target, key);
  target.set(key, value);

  if (!hadKey) {
    trigger(target, "add"
    /* ADD */
    , key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set"
    /* SET */
    , key, value);
  }

  return this;
}

function deleteEntry(key) {
  var target = toRaw(this);

  var _getProto3 = getProto(target),
      has = _getProto3.has,
      get = _getProto3.get;

  var hadKey = has.call(target, key);

  if (!hadKey) {
    key = toRaw(key);
    hadKey = has.call(target, key);
  }

  get ? get.call(target, key) : undefined; // forward the operation before queueing reactions

  var result = target.delete(key);

  if (hadKey) {
    trigger(target, "delete"
    /* DELETE */
    , key, undefined);
  }

  return result;
}

function clear() {
  var target = toRaw(this);
  var hadItems = target.size !== 0; // forward the operation before queueing reactions

  var result = target.clear();

  if (hadItems) {
    trigger(target, "clear"
    /* CLEAR */
    , undefined, undefined);
  }

  return result;
}

function createForEach(isReadonly, isShallow) {
  return function forEach(callback, thisArg) {
    var observed = this;
    var target = observed["__v_raw"
    /* RAW */
    ];
    var rawTarget = toRaw(target);
    var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate"
    /* ITERATE */
    , ITERATE_KEY);
    return target.forEach(function (value, key) {
      // important: make sure the callback is
      // 1. invoked with the reactive map as `this` and 3rd arg
      // 2. the value received should be a corresponding reactive/readonly.
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}

function createIterableMethod(method, isReadonly, isShallow) {
  return function () {
    var target = this["__v_raw"
    /* RAW */
    ];
    var rawTarget = toRaw(target);
    var targetIsMap = isMap(rawTarget);
    var isPair = method === 'entries' || method === Symbol.iterator && targetIsMap;
    var isKeyOnly = method === 'keys' && targetIsMap;
    var innerIterator = target[method].apply(target, arguments);
    var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate"
    /* ITERATE */
    , isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY); // return a wrapped iterator which returns observed versions of the
    // values emitted from the real iterator

    return {
      // iterator protocol
      next() {
        var _innerIterator$next = innerIterator.next(),
            value = _innerIterator$next.value,
            done = _innerIterator$next.done;

        return done ? {
          value,
          done
        } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },

      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }

    };
  };
}

function createReadonlyMethod(type) {
  return function () {
    return type === "delete"
    /* DELETE */
    ? false : this;
  };
}

function createInstrumentations() {
  var mutableInstrumentations = {
    get(key) {
      return get$1(this, key);
    },

    get size() {
      return size(this);
    },

    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  var shallowInstrumentations = {
    get(key) {
      return get$1(this, key, false, true);
    },

    get size() {
      return size(this);
    },

    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  var readonlyInstrumentations = {
    get(key) {
      return get$1(this, key, true);
    },

    get size() {
      return size(this, true);
    },

    has(key) {
      return has$1.call(this, key, true);
    },

    add: createReadonlyMethod("add"
    /* ADD */
    ),
    set: createReadonlyMethod("set"
    /* SET */
    ),
    delete: createReadonlyMethod("delete"
    /* DELETE */
    ),
    clear: createReadonlyMethod("clear"
    /* CLEAR */
    ),
    forEach: createForEach(true, false)
  };
  var shallowReadonlyInstrumentations = {
    get(key) {
      return get$1(this, key, true, true);
    },

    get size() {
      return size(this, true);
    },

    has(key) {
      return has$1.call(this, key, true);
    },

    add: createReadonlyMethod("add"
    /* ADD */
    ),
    set: createReadonlyMethod("set"
    /* SET */
    ),
    delete: createReadonlyMethod("delete"
    /* DELETE */
    ),
    clear: createReadonlyMethod("clear"
    /* CLEAR */
    ),
    forEach: createForEach(true, true)
  };
  var iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
  iteratorMethods.forEach(function (method) {
    mutableInstrumentations[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations[method] = createIterableMethod(method, true, false);
    shallowInstrumentations[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
  });
  return [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations];
}

var _createInstrumentatio = /* #__PURE__*/createInstrumentations(),
    _createInstrumentatio2 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_6__["default"])(_createInstrumentatio, 4),
    mutableInstrumentations = _createInstrumentatio2[0],
    readonlyInstrumentations = _createInstrumentatio2[1],
    shallowInstrumentations = _createInstrumentatio2[2],
    shallowReadonlyInstrumentations = _createInstrumentatio2[3];

function createInstrumentationGetter(isReadonly, shallow) {
  var instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
  return function (target, key, receiver) {
    if (key === "__v_isReactive"
    /* IS_REACTIVE */
    ) {
      return !isReadonly;
    } else if (key === "__v_isReadonly"
    /* IS_READONLY */
    ) {
      return isReadonly;
    } else if (key === "__v_raw"
    /* RAW */
    ) {
      return target;
    }

    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}

var mutableCollectionHandlers = {
  get: /*#__PURE__*/createInstrumentationGetter(false, false)
};
var shallowCollectionHandlers = {
  get: /*#__PURE__*/createInstrumentationGetter(false, true)
};
var readonlyCollectionHandlers = {
  get: /*#__PURE__*/createInstrumentationGetter(true, false)
};
var shallowReadonlyCollectionHandlers = {
  get: /*#__PURE__*/createInstrumentationGetter(true, true)
};
var reactiveMap = new WeakMap();
var shallowReactiveMap = new WeakMap();
var readonlyMap = new WeakMap();
var shallowReadonlyMap = new WeakMap();

function targetTypeMap(rawType) {
  switch (rawType) {
    case 'Object':
    case 'Array':
      return 1
      /* COMMON */
      ;

    case 'Map':
    case 'Set':
    case 'WeakMap':
    case 'WeakSet':
      return 2
      /* COLLECTION */
      ;

    default:
      return 0
      /* INVALID */
      ;
  }
}

function getTargetType(value) {
  return value["__v_skip"
  /* SKIP */
  ] || !Object.isExtensible(value) ? 0
  /* INVALID */
  : targetTypeMap(toRawType(value));
}

function reactive(target) {
  // if trying to observe a readonly proxy, return the readonly version.
  if (target && target["__v_isReadonly"
  /* IS_READONLY */
  ]) {
    return target;
  }

  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */


function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
/**
 * Creates a readonly copy of the original object. Note the returned copy is not
 * made reactive, but `readonly` can be called on an already reactive object.
 */


function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */


function shallowReadonly(target) {
  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}

function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$1(target)) {
    return target;
  } // target is already a Proxy, return it.
  // exception: calling readonly() on a reactive object


  if (target["__v_raw"
  /* RAW */
  ] && !(isReadonly && target["__v_isReactive"
  /* IS_REACTIVE */
  ])) {
    return target;
  } // target already has corresponding Proxy


  var existingProxy = proxyMap.get(target);

  if (existingProxy) {
    return existingProxy;
  } // only a whitelist of value types can be observed.


  var targetType = getTargetType(target);

  if (targetType === 0
  /* INVALID */
  ) {
    return target;
  }

  var proxy = new Proxy(target, targetType === 2
  /* COLLECTION */
  ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}

function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"
    /* RAW */
    ]);
  }

  return !!(value && value["__v_isReactive"
  /* IS_REACTIVE */
  ]);
}

function isReadonly(value) {
  return !!(value && value["__v_isReadonly"
  /* IS_READONLY */
  ]);
}

function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}

function toRaw(observed) {
  var raw = observed && observed["__v_raw"
  /* RAW */
  ];
  return raw ? toRaw(raw) : observed;
}

function markRaw(value) {
  def(value, "__v_skip"
  /* SKIP */
  , true);
  return value;
}

function trackRefValue(ref) {
  if (isTracking()) {
    ref = toRaw(ref);

    if (!ref.dep) {
      ref.dep = createDep();
    }

    {
      trackEffects(ref.dep);
    }
  }
}

function triggerRefValue(ref, newVal) {
  ref = toRaw(ref);

  if (ref.dep) {
    {
      triggerEffects(ref.dep);
    }
  }
}

var convert = function convert(val) {
  return isObject$1(val) ? reactive(val) : val;
};

function isRef(r) {
  return Boolean(r && r.__v_isRef === true);
}

function ref(value) {
  return createRef(value, false);
}

function shallowRef(value) {
  return createRef(value, true);
}

var RefImpl = /*#__PURE__*/function () {
  function RefImpl(value, _shallow) {
    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, RefImpl);

    this._shallow = _shallow;
    this.dep = undefined;
    this.__v_isRef = true;
    this._rawValue = _shallow ? value : toRaw(value);
    this._value = _shallow ? value : convert(value);
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(RefImpl, [{
    key: "value",
    get: function get() {
      trackRefValue(this);
      return this._value;
    },
    set: function set(newVal) {
      newVal = this._shallow ? newVal : toRaw(newVal);

      if (hasChanged(newVal, this._rawValue)) {
        this._rawValue = newVal;
        this._value = this._shallow ? newVal : convert(newVal);
        triggerRefValue(this);
      }
    }
  }]);

  return RefImpl;
}();

function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }

  return new RefImpl(rawValue, shallow);
}

function triggerRef(ref) {
  triggerRefValue(ref);
}

function unref(ref) {
  return isRef(ref) ? ref.value : ref;
}

var shallowUnwrapHandlers = {
  get: function get(target, key, receiver) {
    return unref(Reflect.get(target, key, receiver));
  },
  set: function set(target, key, value, receiver) {
    var oldValue = target[key];

    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};

function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}

var CustomRefImpl = /*#__PURE__*/function () {
  function CustomRefImpl(factory) {
    var _this = this;

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, CustomRefImpl);

    this.dep = undefined;
    this.__v_isRef = true;

    var _factory = factory(function () {
      return trackRefValue(_this);
    }, function () {
      return triggerRefValue(_this);
    }),
        get = _factory.get,
        set = _factory.set;

    this._get = get;
    this._set = set;
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(CustomRefImpl, [{
    key: "value",
    get: function get() {
      return this._get();
    },
    set: function set(newVal) {
      this._set(newVal);
    }
  }]);

  return CustomRefImpl;
}();

function customRef(factory) {
  return new CustomRefImpl(factory);
}

function toRefs(object) {
  var ret = isArray(object) ? new Array(object.length) : {};

  for (var key in object) {
    ret[key] = toRef(object, key);
  }

  return ret;
}

var ObjectRefImpl = /*#__PURE__*/function () {
  function ObjectRefImpl(_object, _key) {
    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, ObjectRefImpl);

    this._object = _object;
    this._key = _key;
    this.__v_isRef = true;
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(ObjectRefImpl, [{
    key: "value",
    get: function get() {
      return this._object[this._key];
    },
    set: function set(newVal) {
      this._object[this._key] = newVal;
    }
  }]);

  return ObjectRefImpl;
}();

function toRef(object, key) {
  var val = object[key];
  return isRef(val) ? val : new ObjectRefImpl(object, key);
}

var ComputedRefImpl = /*#__PURE__*/function () {
  function ComputedRefImpl(getter, _setter, isReadonly) {
    var _this2 = this;

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, ComputedRefImpl);

    this._setter = _setter;
    this.dep = undefined;
    this._dirty = true;
    this.__v_isRef = true;
    this.effect = new ReactiveEffect(getter, function () {
      if (!_this2._dirty) {
        _this2._dirty = true;
        triggerRefValue(_this2);
      }
    });
    this["__v_isReadonly"
    /* IS_READONLY */
    ] = isReadonly;
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(ComputedRefImpl, [{
    key: "value",
    get: function get() {
      // the computed ref may get wrapped by other proxies e.g. readonly() #3376
      var self = toRaw(this);
      trackRefValue(self);

      if (self._dirty) {
        self._dirty = false;
        self._value = self.effect.run();
      }

      return self._value;
    },
    set: function set(newValue) {
      this._setter(newValue);
    }
  }]);

  return ComputedRefImpl;
}();

function computed(getterOrOptions, debugOptions) {
  var getter;
  var setter;

  if (isFunction$1(getterOrOptions)) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }

  var cRef = new ComputedRefImpl(getter, setter, isFunction$1(getterOrOptions) || !getterOrOptions.set);
  return cRef;
}

Promise.resolve();
var devtools;

function setDevtoolsHook(hook) {
  devtools = hook;
}

function devtoolsInitApp(app, version) {
  // TODO queue if devtools is undefined
  if (!devtools) return;
  devtools.emit("app:init"
  /* APP_INIT */
  , app, version, {
    Fragment,
    Text: Text$1,
    Comment: Comment$1,
    Static
  });
}

function devtoolsUnmountApp(app) {
  if (!devtools) return;
  devtools.emit("app:unmount"
  /* APP_UNMOUNT */
  , app);
}

var devtoolsComponentAdded = /*#__PURE__*/createDevtoolsComponentHook("component:added"
/* COMPONENT_ADDED */
);
var devtoolsComponentUpdated = /*#__PURE__*/createDevtoolsComponentHook("component:updated"
/* COMPONENT_UPDATED */
);
var devtoolsComponentRemoved = /*#__PURE__*/createDevtoolsComponentHook("component:removed"
/* COMPONENT_REMOVED */
);

function createDevtoolsComponentHook(hook) {
  return function (component) {
    if (!devtools) return;
    devtools.emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);
  };
}

function devtoolsComponentEmit(component, event, params) {
  if (!devtools) return;
  devtools.emit("component:emit"
  /* COMPONENT_EMIT */
  , component.appContext.app, component, event, params);
}

var globalCompatConfig = {
  MODE: 2
};

function getCompatConfigForKey(key, instance) {
  var instanceConfig = instance && instance.type.compatConfig;

  if (instanceConfig && key in instanceConfig) {
    return instanceConfig[key];
  }

  return globalCompatConfig[key];
}

function isCompatEnabled(key, instance) {
  var enableForBuiltIn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  // skip compat for built-in components
  if (!enableForBuiltIn && instance && instance.type.__isBuiltIn) {
    return false;
  }

  var rawMode = getCompatConfigForKey('MODE', instance) || 2;
  var val = getCompatConfigForKey(key, instance);
  var mode = isFunction$1(rawMode) ? rawMode(instance && instance.type) : rawMode;

  if (mode === 2) {
    return val !== false;
  } else {
    return val === true || val === 'suppress-warning';
  }
}

function emit(instance, event) {
  var props = instance.vnode.props || EMPTY_OBJ;

  for (var _len3 = arguments.length, rawArgs = new Array(_len3 > 2 ? _len3 - 2 : 0), _key4 = 2; _key4 < _len3; _key4++) {
    rawArgs[_key4 - 2] = arguments[_key4];
  }

  var args = rawArgs;
  var isModelListener = event.startsWith('update:'); // for v-model update:xxx events, apply modifiers on args

  var modelArg = isModelListener && event.slice(7);

  if (modelArg && modelArg in props) {
    var modifiersKey = "".concat(modelArg === 'modelValue' ? 'model' : modelArg, "Modifiers");

    var _ref4 = props[modifiersKey] || EMPTY_OBJ,
        number = _ref4.number,
        trim = _ref4.trim;

    if (trim) {
      args = rawArgs.map(function (a) {
        return a.trim();
      });
    } else if (number) {
      args = rawArgs.map(toNumber);
    }
  }

  if (__VUE_PROD_DEVTOOLS__) {
    devtoolsComponentEmit(instance, event, args);
  }

  var handlerName;
  var handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize$1(event))]; // for v-model update:xxx events, also trigger kebab-case equivalent
  // for props passed via kebab-case

  if (!handler && isModelListener) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }

  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6
    /* COMPONENT_EVENT_HANDLER */
    , args);
  }

  var onceHandler = props[handlerName + "Once"];

  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }

    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6
    /* COMPONENT_EVENT_HANDLER */
    , args);
  }
}

function normalizeEmitsOptions(comp, appContext) {
  var asMixin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var cache = appContext.emitsCache;
  var cached = cache.get(comp);

  if (cached !== undefined) {
    return cached;
  }

  var raw = comp.emits;
  var normalized = {}; // apply mixin/extends props

  var hasExtends = false;

  if (__VUE_OPTIONS_API__ && !isFunction$1(comp)) {
    var extendEmits = function extendEmits(raw) {
      var normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);

      if (normalizedFromExtend) {
        hasExtends = true;
        extend$2(normalized, normalizedFromExtend);
      }
    };

    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }

    if (comp.extends) {
      extendEmits(comp.extends);
    }

    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }

  if (!raw && !hasExtends) {
    cache.set(comp, null);
    return null;
  }

  if (isArray(raw)) {
    raw.forEach(function (key) {
      return normalized[key] = null;
    });
  } else {
    extend$2(normalized, raw);
  }

  cache.set(comp, normalized);
  return normalized;
} // Check if an incoming prop key is a declared emit event listener.
// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
// both considered matched listeners.


function isEmitListener(options, key) {
  if (!options || !isOn$1(key)) {
    return false;
  }

  key = key.slice(2).replace(/Once$/, '');
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
/**
 * mark the current rendering instance for asset resolution (e.g.
 * resolveComponent, resolveDirective) during render
 */


var currentRenderingInstance = null;
var currentScopeId = null;
/**
 * Note: rendering calls maybe nested. The function returns the parent rendering
 * instance if present, which should be restored after the render is done:
 *
 * ```js
 * const prev = setCurrentRenderingInstance(i)
 * // ...render
 * setCurrentRenderingInstance(prev)
 * ```
 */

function setCurrentRenderingInstance(instance) {
  var prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
/**
 * Set scope id when creating hoisted vnodes.
 * @private compiler helper
 */


function pushScopeId(id) {
  currentScopeId = id;
}
/**
 * Technically we no longer need this after 3.0.8 but we need to keep the same
 * API for backwards compat w/ code generated by compilers.
 * @private
 */


function popScopeId() {
  currentScopeId = null;
}
/**
 * Only for backwards compat
 * @private
 */


var withScopeId = function withScopeId(_id) {
  return withCtx;
};
/**
 * Wrap a slot function to memoize current rendering instance
 * @private compiler helper
 */


function withCtx(fn) {
  var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentRenderingInstance;
  var isNonScopedSlot // false only
  = arguments.length > 2 ? arguments[2] : undefined;
  if (!ctx) return fn; // already normalized

  if (fn._n) {
    return fn;
  }

  var renderFnWithContext = function renderFnWithContext() {
    // If a user calls a compiled slot inside a template expression (#1745), it
    // can mess up block tracking, so by default we disable block tracking and
    // force bail out when invoking a compiled slot (indicated by the ._d flag).
    // This isn't necessary if rendering a compiled `<slot>`, so we flip the
    // ._d flag off when invoking the wrapped fn inside `renderSlot`.
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }

    var prevInstance = setCurrentRenderingInstance(ctx);
    var res = fn.apply(void 0, arguments);
    setCurrentRenderingInstance(prevInstance);

    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }

    if (__VUE_PROD_DEVTOOLS__) {
      devtoolsComponentUpdated(ctx);
    }

    return res;
  }; // mark normalized to avoid duplicated wrapping


  renderFnWithContext._n = true; // mark this as compiled by default
  // this is used in vnode.ts -> normalizeChildren() to set the slot
  // rendering flag.

  renderFnWithContext._c = true; // disable block tracking by default

  renderFnWithContext._d = true;
  return renderFnWithContext;
}
/**
 * dev only flag to track whether $attrs was used during render.
 * If $attrs was used during render then the warning for failed attrs
 * fallthrough can be suppressed.
 */


var accessedAttrs = false;

function markAttrsAccessed() {
  accessedAttrs = true;
}

function renderComponentRoot(instance) {
  var Component = instance.type,
      vnode = instance.vnode,
      proxy = instance.proxy,
      withProxy = instance.withProxy,
      props = instance.props,
      _instance$propsOption = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_6__["default"])(instance.propsOptions, 1),
      propsOptions = _instance$propsOption[0],
      slots = instance.slots,
      attrs = instance.attrs,
      emit = instance.emit,
      render = instance.render,
      renderCache = instance.renderCache,
      data = instance.data,
      setupState = instance.setupState,
      ctx = instance.ctx,
      inheritAttrs = instance.inheritAttrs;

  var result;
  var prev = setCurrentRenderingInstance(instance);

  try {
    var fallthroughAttrs;

    if (vnode.shapeFlag & 4
    /* STATEFUL_COMPONENT */
    ) {
      // withProxy is a proxy with a different `has` trap only for
      // runtime-compiled render functions using `with` block.
      var proxyToUse = withProxy || proxy;
      result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      // functional
      var _render = Component; // in dev, mark attrs accessed if optional props (attrs === props)

      if (false) {}
      result = normalizeVNode(_render.length > 1 ? _render(props,  false ? 0 : {
        attrs,
        slots,
        emit
      }) : _render(props, null
      /* we know it doesn't need it */
      ));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    } // attr merging
    // in dev mode, comments are preserved, and it's possible for a template
    // to have comments along side the root element which makes it a fragment


    var root = result;
    var setRoot = undefined;
    if (false
    /* DEV_ROOT_FRAGMENT */
    ) {}

    if (fallthroughAttrs && inheritAttrs !== false) {
      var keys = Object.keys(fallthroughAttrs);
      var _root = root,
          shapeFlag = _root.shapeFlag;

      if (keys.length) {
        if (shapeFlag & (1
        /* ELEMENT */
        | 6
        /* COMPONENT */
        )) {
          if (propsOptions && keys.some(isModelListener)) {
            // If a v-model listener (onUpdate:xxx) has a corresponding declared
            // prop, it indicates this component expects to handle v-model and
            // it should not fallthrough.
            // related: #1543, #1643, #1989
            fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
          }

          root = cloneVNode(root, fallthroughAttrs);
        } else if (false) {}
      }
    }

    if (false) {} // inherit directives

    if (vnode.dirs) {
      if (false) {}
      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    } // inherit transition data


    if (vnode.transition) {
      if (false) {}
      root.transition = vnode.transition;
    }

    if (false) {}else {
      result = root;
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1
    /* RENDER_FUNCTION */
    );
    result = createVNode(Comment$1);
  }

  setCurrentRenderingInstance(prev);
  return result;
}
/**
 * dev only
 * In dev mode, template root level comments are rendered, which turns the
 * template into a fragment root, but we need to locate the single element
 * root for attrs and scope id processing.
 */


var getChildRoot = function getChildRoot(vnode) {
  var rawChildren = vnode.children;
  var dynamicChildren = vnode.dynamicChildren;
  var childRoot = filterSingleRoot(rawChildren);

  if (!childRoot) {
    return [vnode, undefined];
  }

  var index = rawChildren.indexOf(childRoot);
  var dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;

  var setRoot = function setRoot(updatedRoot) {
    rawChildren[index] = updatedRoot;

    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [].concat((0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(dynamicChildren), [updatedRoot]);
      }
    }
  };

  return [normalizeVNode(childRoot), setRoot];
};

function filterSingleRoot(children) {
  var singleRoot;

  for (var i = 0; i < children.length; i++) {
    var child = children[i];

    if (isVNode(child)) {
      // ignore user comment
      if (child.type !== Comment$1 || child.children === 'v-if') {
        if (singleRoot) {
          // has more than 1 non-comment child, return now
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }

  return singleRoot;
}

var getFunctionalFallthrough = function getFunctionalFallthrough(attrs) {
  var res;

  for (var key in attrs) {
    if (key === 'class' || key === 'style' || isOn$1(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }

  return res;
};

var filterModelListeners = function filterModelListeners(attrs, props) {
  var res = {};

  for (var key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }

  return res;
};

var isElementRoot = function isElementRoot(vnode) {
  return vnode.shapeFlag & (6
  /* COMPONENT */
  | 1
  /* ELEMENT */
  ) || vnode.type === Comment$1 // potential v-if branch switch
  ;
};

function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  var prevProps = prevVNode.props,
      prevChildren = prevVNode.children,
      component = prevVNode.component;
  var nextProps = nextVNode.props,
      nextChildren = nextVNode.children,
      patchFlag = nextVNode.patchFlag;
  var emits = component.emitsOptions; // force child update for runtime directive or transition on component vnode.

  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }

  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024
    /* DYNAMIC_SLOTS */
    ) {
      // slot content that references values that might have changed,
      // e.g. in a v-for
      return true;
    }

    if (patchFlag & 16
    /* FULL_PROPS */
    ) {
      if (!prevProps) {
        return !!nextProps;
      } // presence of this flag indicates props are always non-null


      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8
    /* PROPS */
    ) {
      var dynamicProps = nextVNode.dynamicProps;

      for (var i = 0; i < dynamicProps.length; i++) {
        var key = dynamicProps[i];

        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    // this path is only taken by manually written render functions
    // so presence of any children leads to a forced update
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }

    if (prevProps === nextProps) {
      return false;
    }

    if (!prevProps) {
      return !!nextProps;
    }

    if (!nextProps) {
      return true;
    }

    return hasPropsChanged(prevProps, nextProps, emits);
  }

  return false;
}

function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  var nextKeys = Object.keys(nextProps);

  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }

  for (var i = 0; i < nextKeys.length; i++) {
    var key = nextKeys[i];

    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }

  return false;
}

function updateHOCHostEl(_ref5, el // HostNode
) {
  var vnode = _ref5.vnode,
      parent = _ref5.parent;

  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}

var isSuspense = function isSuspense(type) {
  return type.__isSuspense;
}; // Suspense exposes a component-like API, and is treated like a component
// in the compiler, but internally it's a special built-in type that hooks
// directly into the renderer.


var SuspenseImpl = {
  name: 'Suspense',
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,

  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, // platform-specific impl passed from renderer
  rendererInternals) {
    if (n1 == null) {
      mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
    } else {
      patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    }
  },

  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
}; // Force-casted public typing for h and TSX props inference

var Suspense = SuspenseImpl;

function triggerEvent(vnode, name) {
  var eventListener = vnode.props && vnode.props[name];

  if (isFunction$1(eventListener)) {
    eventListener();
  }
}

function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  var patch = rendererInternals.p,
      createElement = rendererInternals.o.createElement;
  var hiddenContainer = createElement('div');
  var suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals); // start mounting the content subtree in an off-dom container

  patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds); // now check if we have encountered any async deps

  if (suspense.deps > 0) {
    // has async
    // invoke @fallback event
    triggerEvent(vnode, 'onPending');
    triggerEvent(vnode, 'onFallback'); // mount the fallback tree

    patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
    isSVG, slotScopeIds);
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    // Suspense has no async deps. Just resolve.
    suspense.resolve();
  }
}

function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, _ref6) {
  var patch = _ref6.p,
      unmount = _ref6.um,
      createElement = _ref6.o.createElement;
  var suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  var newBranch = n2.ssContent;
  var newFallback = n2.ssFallback;
  var activeBranch = suspense.activeBranch,
      pendingBranch = suspense.pendingBranch,
      isInFallback = suspense.isInFallback,
      isHydrating = suspense.isHydrating;

  if (pendingBranch) {
    suspense.pendingBranch = newBranch;

    if (isSameVNodeType(newBranch, pendingBranch)) {
      // same root type but content may have changed.
      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newFallback);
      }
    } else {
      // toggled before pending tree is resolved
      suspense.pendingId++;

      if (isHydrating) {
        // if toggled before hydration is finished, the current DOM tree is
        // no longer valid. set it as the active branch so it will be unmounted
        // when resolved
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      } // increment pending ID. this is used to invalidate async callbacks
      // reset suspense state


      suspense.deps = 0; // discard effects from pending branch

      suspense.effects.length = 0; // discard previous container

      suspense.hiddenContainer = createElement('div');

      if (isInFallback) {
        // already in fallback state
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
          isSVG, slotScopeIds, optimized);
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        // toggled "back" to current active branch
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized); // force resolve

        suspense.resolve(true);
      } else {
        // switched to a 3rd branch
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      // root did not change, just normal patch
      patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      setActiveBranch(suspense, newBranch);
    } else {
      // root node toggled
      // invoke @pending event
      triggerEvent(n2, 'onPending'); // mount pending branch in off-dom container

      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

      if (suspense.deps <= 0) {
        // incoming branch has no async deps, resolve now.
        suspense.resolve();
      } else {
        var timeout = suspense.timeout,
            pendingId = suspense.pendingId;

        if (timeout > 0) {
          setTimeout(function () {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}

function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals) {
  var isHydrating = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;
  var patch = rendererInternals.p,
      move = rendererInternals.m,
      unmount = rendererInternals.um,
      next = rendererInternals.n,
      _rendererInternals$o = rendererInternals.o,
      parentNode = _rendererInternals$o.parentNode,
      remove = _rendererInternals$o.remove;
  var timeout = toNumber(vnode.props && vnode.props.timeout);
  var suspense = {
    vnode,
    parent,
    parentComponent,
    isSVG,
    container,
    hiddenContainer,
    anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === 'number' ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating,
    isUnmounted: false,
    effects: [],

    resolve() {
      var resume = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var vnode = suspense.vnode,
          activeBranch = suspense.activeBranch,
          pendingBranch = suspense.pendingBranch,
          pendingId = suspense.pendingId,
          effects = suspense.effects,
          parentComponent = suspense.parentComponent,
          container = suspense.container;

      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        var delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === 'out-in';

        if (delayEnter) {
          activeBranch.transition.afterLeave = function () {
            if (pendingId === suspense.pendingId) {
              move(pendingBranch, container, _anchor, 0
              /* ENTER */
              );
            }
          };
        } // this is initial anchor on mount


        var _anchor = suspense.anchor; // unmount current active tree

        if (activeBranch) {
          // if the fallback tree was mounted, it may have been moved
          // as part of a parent suspense. get the latest anchor for insertion
          _anchor = next(activeBranch);
          unmount(activeBranch, parentComponent, suspense, true);
        }

        if (!delayEnter) {
          // move content from off-dom container to actual container
          move(pendingBranch, container, _anchor, 0
          /* ENTER */
          );
        }
      }

      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false; // flush buffered effects
      // check if there is a pending parent suspense

      var parent = suspense.parent;
      var hasUnresolvedAncestor = false;

      while (parent) {
        if (parent.pendingBranch) {
          var _parent$effects;

          // found a pending parent suspense, merge buffered post jobs
          // into that parent
          (_parent$effects = parent.effects).push.apply(_parent$effects, (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(effects));

          hasUnresolvedAncestor = true;
          break;
        }

        parent = parent.parent;
      } // no pending parent suspense, flush all jobs


      if (!hasUnresolvedAncestor) {
        queuePostFlushCb(effects);
      }

      suspense.effects = []; // invoke @resolve event

      triggerEvent(vnode, 'onResolve');
    },

    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }

      var vnode = suspense.vnode,
          activeBranch = suspense.activeBranch,
          parentComponent = suspense.parentComponent,
          container = suspense.container,
          isSVG = suspense.isSVG; // invoke @fallback event

      triggerEvent(vnode, 'onFallback');
      var anchor = next(activeBranch);

      var mountFallback = function mountFallback() {
        if (!suspense.isInFallback) {
          return;
        } // mount the fallback tree


        patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, fallbackVNode);
      };

      var delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';

      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }

      suspense.isInFallback = true; // unmount current active branch

      unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now
      true // shouldRemove
      );

      if (!delayEnter) {
        mountFallback();
      }
    },

    move(container, anchor, type) {
      suspense.activeBranch && move(suspense.activeBranch, container, anchor, type);
      suspense.container = container;
    },

    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },

    registerDep(instance, setupRenderEffect) {
      var isInPendingSuspense = !!suspense.pendingBranch;

      if (isInPendingSuspense) {
        suspense.deps++;
      }

      var hydratedEl = instance.vnode.el;
      instance.asyncDep.catch(function (err) {
        handleError(err, instance, 0
        /* SETUP_FUNCTION */
        );
      }).then(function (asyncSetupResult) {
        // retry when the setup() promise resolves.
        // component may have been unmounted before resolve.
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        } // retry from this component


        instance.asyncResolved = true;
        var vnode = instance.vnode;
        handleSetupResult(instance, asyncSetupResult);

        if (hydratedEl) {
          // vnode may have been replaced if an update happened before the
          // async dep is resolved.
          vnode.el = hydratedEl;
        }

        var placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(instance, vnode, // component may have been moved before resolve.
        // if this is not a hydration, instance.subTree will be the comment
        // placeholder.
        parentNode(hydratedEl || instance.subTree.el), // anchor will not be used if this is hydration, so only need to
        // consider the comment placeholder case.
        hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);

        if (placeholder) {
          remove(placeholder);
        }

        updateHOCHostEl(instance, vnode.el); // only decrease deps count if suspense is not already resolved

        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },

    unmount(parentSuspense, doRemove) {
      suspense.isUnmounted = true;

      if (suspense.activeBranch) {
        unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
      }

      if (suspense.pendingBranch) {
        unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
      }
    }

  };
  return suspense;
}

function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  /* eslint-disable no-restricted-globals */
  var suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true
  /* hydrating */
  ); // there are two possible scenarios for server-rendered suspense:
  // - success: ssr content should be fully resolved
  // - failure: ssr content should be the fallback branch.
  // however, on the client we don't really know if it has failed or not
  // attempt to hydrate the DOM assuming it has succeeded, but we still
  // need to construct a suspense boundary first

  var result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);

  if (suspense.deps === 0) {
    suspense.resolve();
  }

  return result;
  /* eslint-enable no-restricted-globals */
}

function normalizeSuspenseChildren(vnode) {
  var shapeFlag = vnode.shapeFlag,
      children = vnode.children;
  var isSlotChildren = shapeFlag & 32
  /* SLOTS_CHILDREN */
  ;
  vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment$1);
}

function normalizeSuspenseSlot(s) {
  var block;

  if (isFunction$1(s)) {
    var isCompiledSlot = s._c;

    if (isCompiledSlot) {
      // disableTracking: false
      // allow block tracking for compiled slots
      // (see ./componentRenderContext.ts)
      s._d = false;
      openBlock();
    }

    s = s();

    if (isCompiledSlot) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }

  if (isArray(s)) {
    var singleChild = filterSingleRoot(s);
    s = singleChild;
  }

  s = normalizeVNode(s);

  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter(function (c) {
      return c !== s;
    });
  }

  return s;
}

function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      var _suspense$effects;

      (_suspense$effects = suspense.effects).push.apply(_suspense$effects, (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(fn));
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}

function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  var vnode = suspense.vnode,
      parentComponent = suspense.parentComponent;
  var el = vnode.el = branch.el; // in case suspense is the root node of a component,
  // recursively update the HOC el

  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}

function provide(key, value) {
  if (!currentInstance) ;else {
    var provides = currentInstance.provides; // by default an instance inherits its parent's provides object
    // but when it needs to provide values of its own, it creates its
    // own provides object using parent provides object as prototype.
    // this way in `inject` we can simply look up injections from direct
    // parent and let the prototype chain do the work.

    var parentProvides = currentInstance.parent && currentInstance.parent.provides;

    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    } // TS doesn't allow symbol as index type


    provides[key] = value;
  }
}

function inject(key, defaultValue) {
  var treatDefaultAsFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // fallback to `currentRenderingInstance` so that this can be called in
  // a functional component
  var instance = currentInstance || currentRenderingInstance;

  if (instance) {
    // #2400
    // to support `app.use` plugins,
    // fallback to appContext's `provides` if the intance is at root
    var provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;

    if (provides && key in provides) {
      // TS doesn't allow symbol as index type
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else ;
  }
}

function useTransitionState() {
  var state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: new Map()
  };
  onMounted(function () {
    state.isMounted = true;
  });
  onBeforeUnmount(function () {
    state.isUnmounting = true;
  });
  return state;
}

var TransitionHookValidator = [Function, Array];
var BaseTransitionImpl = {
  name: "BaseTransition",
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },

  setup(props, _ref7) {
    var slots = _ref7.slots;
    var instance = getCurrentInstance();
    var state = useTransitionState();
    var prevTransitionKey;
    return function () {
      var children = slots.default && getTransitionRawChildren(slots.default(), true);

      if (!children || !children.length) {
        return;
      } // there's no need to track reactivity for these props so use the raw
      // props for a bit better perf


      var rawProps = toRaw(props);
      var mode = rawProps.mode; // at this point children has a guaranteed length of 1.

      var child = children[0];

      if (state.isLeaving) {
        return emptyPlaceholder(child);
      } // in the case of <transition><keep-alive/></transition>, we need to
      // compare the type of the kept-alive children.


      var innerChild = getKeepAliveChild(child);

      if (!innerChild) {
        return emptyPlaceholder(child);
      }

      var enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      var oldChild = instance.subTree;
      var oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      var transitionKeyChanged = false;
      var getTransitionKey = innerChild.type.getTransitionKey;

      if (getTransitionKey) {
        var key = getTransitionKey();

        if (prevTransitionKey === undefined) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      } // handle mode


      if (oldInnerChild && oldInnerChild.type !== Comment$1 && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        var leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance); // update old tree's hooks in case of dynamic transition

        setTransitionHooks(oldInnerChild, leavingHooks); // switching between different views

        if (mode === 'out-in') {
          state.isLeaving = true; // return placeholder node and queue update when leave finishes

          leavingHooks.afterLeave = function () {
            state.isLeaving = false;
            instance.update();
          };

          return emptyPlaceholder(child);
        } else if (mode === 'in-out' && innerChild.type !== Comment$1) {
          leavingHooks.delayLeave = function (el, earlyRemove, delayedLeave) {
            var leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild; // early removal callback

            el._leaveCb = function () {
              earlyRemove();
              el._leaveCb = undefined;
              delete enterHooks.delayedLeave;
            };

            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }

      return child;
    };
  }

}; // export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files

var BaseTransition = BaseTransitionImpl;

function getLeavingNodesForType(state, vnode) {
  var leavingVNodes = state.leavingVNodes;
  var leavingVNodesCache = leavingVNodes.get(vnode.type);

  if (!leavingVNodesCache) {
    leavingVNodesCache = Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }

  return leavingVNodesCache;
} // The transition hooks are attached to the vnode as vnode.transition
// and will be called at appropriate timing in the renderer.


function resolveTransitionHooks(vnode, props, state, instance) {
  var appear = props.appear,
      mode = props.mode,
      _props$persisted = props.persisted,
      persisted = _props$persisted === void 0 ? false : _props$persisted,
      onBeforeEnter = props.onBeforeEnter,
      onEnter = props.onEnter,
      onAfterEnter = props.onAfterEnter,
      onEnterCancelled = props.onEnterCancelled,
      onBeforeLeave = props.onBeforeLeave,
      onLeave = props.onLeave,
      onAfterLeave = props.onAfterLeave,
      onLeaveCancelled = props.onLeaveCancelled,
      onBeforeAppear = props.onBeforeAppear,
      onAppear = props.onAppear,
      onAfterAppear = props.onAfterAppear,
      onAppearCancelled = props.onAppearCancelled;
  var key = String(vnode.key);
  var leavingVNodesCache = getLeavingNodesForType(state, vnode);

  var callHook = function callHook(hook, args) {
    hook && callWithAsyncErrorHandling(hook, instance, 9
    /* TRANSITION_HOOK */
    , args);
  };

  var hooks = {
    mode,
    persisted,

    beforeEnter(el) {
      var hook = onBeforeEnter;

      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      } // for same element (v-show)


      if (el._leaveCb) {
        el._leaveCb(true
        /* cancelled */
        );
      } // for toggled element with same key (v-if)


      var leavingVNode = leavingVNodesCache[key];

      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        // force early removal (not cancelled)
        leavingVNode.el._leaveCb();
      }

      callHook(hook, [el]);
    },

    enter(el) {
      var hook = onEnter;
      var afterHook = onAfterEnter;
      var cancelHook = onEnterCancelled;

      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }

      var called = false;

      var done = el._enterCb = function (cancelled) {
        if (called) return;
        called = true;

        if (cancelled) {
          callHook(cancelHook, [el]);
        } else {
          callHook(afterHook, [el]);
        }

        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }

        el._enterCb = undefined;
      };

      if (hook) {
        hook(el, done);

        if (hook.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },

    leave(el, remove) {
      var key = String(vnode.key);

      if (el._enterCb) {
        el._enterCb(true
        /* cancelled */
        );
      }

      if (state.isUnmounting) {
        return remove();
      }

      callHook(onBeforeLeave, [el]);
      var called = false;

      var done = el._leaveCb = function (cancelled) {
        if (called) return;
        called = true;
        remove();

        if (cancelled) {
          callHook(onLeaveCancelled, [el]);
        } else {
          callHook(onAfterLeave, [el]);
        }

        el._leaveCb = undefined;

        if (leavingVNodesCache[key] === vnode) {
          delete leavingVNodesCache[key];
        }
      };

      leavingVNodesCache[key] = vnode;

      if (onLeave) {
        onLeave(el, done);

        if (onLeave.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },

    clone(vnode) {
      return resolveTransitionHooks(vnode, props, state, instance);
    }

  };
  return hooks;
} // the placeholder really only handles one special case: KeepAlive
// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
// placeholder with empty content to avoid the KeepAlive instance from being
// unmounted.


function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}

function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : undefined : vnode;
}

function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6
  /* COMPONENT */
  && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128
  /* SUSPENSE */
  ) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}

function getTransitionRawChildren(children) {
  var keepComment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var ret = [];
  var keyedFragmentCount = 0;

  for (var i = 0; i < children.length; i++) {
    var child = children[i]; // handle fragment children case, e.g. v-for

    if (child.type === Fragment) {
      if (child.patchFlag & 128
      /* KEYED_FRAGMENT */
      ) keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
    } // comment placeholders should be skipped, e.g. v-if
    else if (keepComment || child.type !== Comment$1) {
      ret.push(child);
    }
  } // #1126 if a transition children list contains multiple sub fragments, these
  // fragments will be merged into a flat children array. Since each v-for
  // fragment may contain different static bindings inside, we need to de-op
  // these children to force full diffs to ensure correct behavior.


  if (keyedFragmentCount > 1) {
    for (var _i = 0; _i < ret.length; _i++) {
      ret[_i].patchFlag = -2
      /* BAIL */
      ;
    }
  }

  return ret;
} // implementation, close to no-op


function defineComponent(options) {
  return isFunction$1(options) ? {
    setup: options,
    name: options.name
  } : options;
}

var isAsyncWrapper = function isAsyncWrapper(i) {
  return !!i.type.__asyncLoader;
};

function defineAsyncComponent(source) {
  if (isFunction$1(source)) {
    source = {
      loader: source
    };
  }

  var _source = source,
      loader = _source.loader,
      loadingComponent = _source.loadingComponent,
      errorComponent = _source.errorComponent,
      _source$delay = _source.delay,
      delay = _source$delay === void 0 ? 200 : _source$delay,
      timeout = _source.timeout,
      _source$suspensible = _source.suspensible,
      suspensible = _source$suspensible === void 0 ? true : _source$suspensible,
      userOnError = _source.onError;
  var pendingRequest = null;
  var resolvedComp;
  var retries = 0;

  var retry = function retry() {
    retries++;
    pendingRequest = null;
    return load();
  };

  var load = function load() {
    var thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch(function (err) {
      err = err instanceof Error ? err : new Error(String(err));

      if (userOnError) {
        return new Promise(function (resolve, reject) {
          var userRetry = function userRetry() {
            return resolve(retry());
          };

          var userFail = function userFail() {
            return reject(err);
          };

          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then(function (comp) {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      } // interop module default


      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
        comp = comp.default;
      }

      resolvedComp = comp;
      return comp;
    }));
  };

  return defineComponent({
    name: 'AsyncComponentWrapper',
    __asyncLoader: load,

    get __asyncResolved() {
      return resolvedComp;
    },

    setup() {
      var instance = currentInstance; // already resolved

      if (resolvedComp) {
        return function () {
          return createInnerComp(resolvedComp, instance);
        };
      }

      var onError = function onError(err) {
        pendingRequest = null;
        handleError(err, instance, 13
        /* ASYNC_COMPONENT_LOADER */
        , !errorComponent
        /* do not throw in dev if user provided error component */
        );
      }; // suspense-controlled or SSR.


      if (suspensible && instance.suspense || false) {
        return load().then(function (comp) {
          return function () {
            return createInnerComp(comp, instance);
          };
        }).catch(function (err) {
          onError(err);
          return function () {
            return errorComponent ? createVNode(errorComponent, {
              error: err
            }) : null;
          };
        });
      }

      var loaded = ref(false);
      var error = ref();
      var delayed = ref(!!delay);

      if (delay) {
        setTimeout(function () {
          delayed.value = false;
        }, delay);
      }

      if (timeout != null) {
        setTimeout(function () {
          if (!loaded.value && !error.value) {
            var err = new Error("Async component timed out after ".concat(timeout, "ms."));
            onError(err);
            error.value = err;
          }
        }, timeout);
      }

      load().then(function () {
        loaded.value = true;

        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          // parent is keep-alive, force update so the loaded component's
          // name is taken into account
          queueJob(instance.parent.update);
        }
      }).catch(function (err) {
        onError(err);
        error.value = err;
      });
      return function () {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }

  });
}

function createInnerComp(comp, _ref8) {
  var _ref8$vnode = _ref8.vnode,
      ref = _ref8$vnode.ref,
      props = _ref8$vnode.props,
      children = _ref8$vnode.children;
  var vnode = createVNode(comp, props, children); // ensure inner component inherits the async wrapper's ref owner

  vnode.ref = ref;
  return vnode;
}

var isKeepAlive = function isKeepAlive(vnode) {
  return vnode.type.__isKeepAlive;
};

var KeepAliveImpl = {
  name: "KeepAlive",
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },

  setup(props, _ref9) {
    var slots = _ref9.slots;
    var instance = getCurrentInstance(); // KeepAlive communicates with the instantiated renderer via the
    // ctx where the renderer passes in its internals,
    // and the KeepAlive instance exposes activate/deactivate implementations.
    // The whole point of this is to avoid importing KeepAlive directly in the
    // renderer to facilitate tree-shaking.

    var sharedContext = instance.ctx; // if the internal renderer is not registered, it indicates that this is server-side rendering,
    // for KeepAlive, we just need to render its children

    if (!sharedContext.renderer) {
      return slots.default;
    }

    var cache = new Map();
    var keys = new Set();
    var current = null;

    if (__VUE_PROD_DEVTOOLS__) {
      instance.__v_cache = cache;
    }

    var parentSuspense = instance.suspense;
    var _sharedContext$render = sharedContext.renderer,
        patch = _sharedContext$render.p,
        move = _sharedContext$render.m,
        _unmount = _sharedContext$render.um,
        createElement = _sharedContext$render.o.createElement;
    var storageContainer = createElement('div');

    sharedContext.activate = function (vnode, container, anchor, isSVG, optimized) {
      var instance = vnode.component;
      move(vnode, container, anchor, 0
      /* ENTER */
      , parentSuspense); // in case props have changed

      patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
      queuePostRenderEffect(function () {
        instance.isDeactivated = false;

        if (instance.a) {
          invokeArrayFns(instance.a);
        }

        var vnodeHook = vnode.props && vnode.props.onVnodeMounted;

        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance.parent, vnode);
        }
      }, parentSuspense);

      if (__VUE_PROD_DEVTOOLS__) {
        // Update components tree
        devtoolsComponentAdded(instance);
      }
    };

    sharedContext.deactivate = function (vnode) {
      var instance = vnode.component;
      move(vnode, storageContainer, null, 1
      /* LEAVE */
      , parentSuspense);
      queuePostRenderEffect(function () {
        if (instance.da) {
          invokeArrayFns(instance.da);
        }

        var vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;

        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance.parent, vnode);
        }

        instance.isDeactivated = true;
      }, parentSuspense);

      if (__VUE_PROD_DEVTOOLS__) {
        // Update components tree
        devtoolsComponentAdded(instance);
      }
    };

    function unmount(vnode) {
      // reset the shapeFlag so it can be properly unmounted
      resetShapeFlag(vnode);

      _unmount(vnode, instance, parentSuspense);
    }

    function pruneCache(filter) {
      cache.forEach(function (vnode, key) {
        var name = getComponentName(vnode.type);

        if (name && (!filter || !filter(name))) {
          pruneCacheEntry(key);
        }
      });
    }

    function pruneCacheEntry(key) {
      var cached = cache.get(key);

      if (!current || cached.type !== current.type) {
        unmount(cached);
      } else if (current) {
        // current active instance should no longer be kept-alive.
        // we can't unmount it now but it might be later, so reset its flag now.
        resetShapeFlag(current);
      }

      cache.delete(key);
      keys.delete(key);
    } // prune cache on include/exclude prop change


    watch(function () {
      return [props.include, props.exclude];
    }, function (_ref10) {
      var _ref11 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_6__["default"])(_ref10, 2),
          include = _ref11[0],
          exclude = _ref11[1];

      include && pruneCache(function (name) {
        return matches(include, name);
      });
      exclude && pruneCache(function (name) {
        return !matches(exclude, name);
      });
    }, // prune post-render after `current` has been updated
    {
      flush: 'post',
      deep: true
    }); // cache sub tree after render

    var pendingCacheKey = null;

    var cacheSubtree = function cacheSubtree() {
      // fix #1621, the pendingCacheKey could be 0
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };

    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(function () {
      cache.forEach(function (cached) {
        var subTree = instance.subTree,
            suspense = instance.suspense;
        var vnode = getInnerChild(subTree);

        if (cached.type === vnode.type) {
          // current instance will be unmounted as part of keep-alive's unmount
          resetShapeFlag(vnode); // but invoke its deactivated hook here

          var da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }

        unmount(cached);
      });
    });
    return function () {
      pendingCacheKey = null;

      if (!slots.default) {
        return null;
      }

      var children = slots.default();
      var rawVNode = children[0];

      if (children.length > 1) {
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4
      /* STATEFUL_COMPONENT */
      ) && !(rawVNode.shapeFlag & 128
      /* SUSPENSE */
      )) {
        current = null;
        return rawVNode;
      }

      var vnode = getInnerChild(rawVNode);
      var comp = vnode.type; // for async components, name check should be based in its loaded
      // inner component if available

      var name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
      var include = props.include,
          exclude = props.exclude,
          max = props.max;

      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }

      var key = vnode.key == null ? comp : vnode.key;
      var cachedVNode = cache.get(key); // clone vnode if it's reused because we are going to mutate it

      if (vnode.el) {
        vnode = cloneVNode(vnode);

        if (rawVNode.shapeFlag & 128
        /* SUSPENSE */
        ) {
          rawVNode.ssContent = vnode;
        }
      } // #1513 it's possible for the returned vnode to be cloned due to attr
      // fallthrough or scopeId, so the vnode here may not be the final vnode
      // that is mounted. Instead of caching it directly, we store the pending
      // key and cache `instance.subTree` (the normalized vnode) in
      // beforeMount/beforeUpdate hooks.


      pendingCacheKey = key;

      if (cachedVNode) {
        // copy over mounted state
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;

        if (vnode.transition) {
          // recursively update transition hooks on subTree
          setTransitionHooks(vnode, vnode.transition);
        } // avoid vnode being mounted as fresh


        vnode.shapeFlag |= 512
        /* COMPONENT_KEPT_ALIVE */
        ; // make this key the freshest

        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key); // prune oldest entry

        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      } // avoid vnode being unmounted


      vnode.shapeFlag |= 256
      /* COMPONENT_SHOULD_KEEP_ALIVE */
      ;
      current = vnode;
      return rawVNode;
    };
  }

}; // export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files

var KeepAlive = KeepAliveImpl;

function matches(pattern, name) {
  if (isArray(pattern)) {
    return pattern.some(function (p) {
      return matches(p, name);
    });
  } else if (isString(pattern)) {
    return pattern.split(',').indexOf(name) > -1;
  } else if (pattern.test) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a"
  /* ACTIVATED */
  , target);
}

function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da"
  /* DEACTIVATED */
  , target);
}

function registerKeepAliveHook(hook, type) {
  var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : currentInstance;

  // cache the deactivate branch check wrapper for injected hooks so the same
  // hook can be properly deduped by the scheduler. "__wdc" stands for "with
  // deactivation check".
  var wrappedHook = hook.__wdc || (hook.__wdc = function () {
    // only fire the hook if the target instance is NOT in a deactivated branch.
    var current = target;

    while (current) {
      if (current.isDeactivated) {
        return;
      }

      current = current.parent;
    }

    hook();
  });

  injectHook(type, wrappedHook, target); // In addition to registering it on the target instance, we walk up the parent
  // chain and register it on all ancestor instances that are keep-alive roots.
  // This avoids the need to walk the entire component tree when invoking these
  // hooks, and more importantly, avoids the need to track child components in
  // arrays.

  if (target) {
    var current = target.parent;

    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }

      current = current.parent;
    }
  }
}

function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  // injectHook wraps the original for error handling, so make sure to remove
  // the wrapped version.
  var injected = injectHook(type, hook, keepAliveRoot, true
  /* prepend */
  );
  onUnmounted(function () {
    remove$1(keepAliveRoot[type], injected);
  }, target);
}

function resetShapeFlag(vnode) {
  var shapeFlag = vnode.shapeFlag;

  if (shapeFlag & 256
  /* COMPONENT_SHOULD_KEEP_ALIVE */
  ) {
    shapeFlag -= 256
    /* COMPONENT_SHOULD_KEEP_ALIVE */
    ;
  }

  if (shapeFlag & 512
  /* COMPONENT_KEPT_ALIVE */
  ) {
    shapeFlag -= 512
    /* COMPONENT_KEPT_ALIVE */
    ;
  }

  vnode.shapeFlag = shapeFlag;
}

function getInnerChild(vnode) {
  return vnode.shapeFlag & 128
  /* SUSPENSE */
  ? vnode.ssContent : vnode;
}

function injectHook(type, hook) {
  var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : currentInstance;
  var prepend = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  if (target) {
    var hooks = target[type] || (target[type] = []); // cache the error handling wrapper for injected hooks so the same hook
    // can be properly deduped by the scheduler. "__weh" stands for "with error
    // handling".

    var wrappedHook = hook.__weh || (hook.__weh = function () {
      if (target.isUnmounted) {
        return;
      } // disable tracking inside all lifecycle hooks
      // since they can potentially be called inside effects.


      pauseTracking(); // Set currentInstance during hook invocation.
      // This assumes the hook does not synchronously trigger other hooks, which
      // can only be false when the user does something really funky.

      setCurrentInstance(target);

      for (var _len4 = arguments.length, args = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {
        args[_key5] = arguments[_key5];
      }

      var res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });

    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }

    return wrappedHook;
  }
}

var createHook = function createHook(lifecycle) {
  return function (hook) {
    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentInstance;
    return (// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
      (!isInSSRComponentSetup || lifecycle === "sp"
      /* SERVER_PREFETCH */
      ) && injectHook(lifecycle, hook, target)
    );
  };
};

var onBeforeMount = createHook("bm"
/* BEFORE_MOUNT */
);
var onMounted = createHook("m"
/* MOUNTED */
);
var onBeforeUpdate = createHook("bu"
/* BEFORE_UPDATE */
);
var onUpdated = createHook("u"
/* UPDATED */
);
var onBeforeUnmount = createHook("bum"
/* BEFORE_UNMOUNT */
);
var onUnmounted = createHook("um"
/* UNMOUNTED */
);
var onServerPrefetch = createHook("sp"
/* SERVER_PREFETCH */
);
var onRenderTriggered = createHook("rtg"
/* RENDER_TRIGGERED */
);
var onRenderTracked = createHook("rtc"
/* RENDER_TRACKED */
);

function onErrorCaptured(hook) {
  var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentInstance;
  injectHook("ec"
  /* ERROR_CAPTURED */
  , hook, target);
}

var shouldCacheAccess = true;

function applyOptions(instance) {
  var options = resolveMergedOptions(instance);
  var publicThis = instance.proxy;
  var ctx = instance.ctx; // do not cache property access on public proxy during state initialization

  shouldCacheAccess = false; // call beforeCreate first before accessing other options since
  // the hook may mutate resolved options (#2791)

  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc"
    /* BEFORE_CREATE */
    );
  }

  var dataOptions = options.data,
      computedOptions = options.computed,
      methods = options.methods,
      watchOptions = options.watch,
      provideOptions = options.provide,
      injectOptions = options.inject,
      created = options.created,
      beforeMount = options.beforeMount,
      mounted = options.mounted,
      beforeUpdate = options.beforeUpdate,
      updated = options.updated,
      activated = options.activated,
      deactivated = options.deactivated,
      beforeDestroy = options.beforeDestroy,
      beforeUnmount = options.beforeUnmount,
      destroyed = options.destroyed,
      unmounted = options.unmounted,
      render = options.render,
      renderTracked = options.renderTracked,
      renderTriggered = options.renderTriggered,
      errorCaptured = options.errorCaptured,
      serverPrefetch = options.serverPrefetch,
      expose = options.expose,
      inheritAttrs = options.inheritAttrs,
      components = options.components,
      directives = options.directives,
      filters = options.filters;
  var checkDuplicateProperties = null; // options initialization order (to be consistent with Vue 2):
  // - props (already done outside of this function)
  // - inject
  // - methods
  // - data (deferred since it relies on `this` access)
  // - computed
  // - watch (deferred since it relies on `this` access)

  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }

  if (methods) {
    for (var key in methods) {
      var methodHandler = methods[key];

      if (isFunction$1(methodHandler)) {
        // In dev mode, we use the `createRenderContext` function to define
        // methods to the proxy target, and those are read-only but
        // reconfigurable, so it needs to be redefined here
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }

  if (dataOptions) {
    var data = dataOptions.call(publicThis, publicThis);
    if (!isObject$1(data)) ;else {
      instance.data = reactive(data);
    }
  } // state initialization complete at this point - start caching access


  shouldCacheAccess = true;

  if (computedOptions) {
    var _loop = function _loop(_key6) {
      var opt = computedOptions[_key6];
      var get = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      var set = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
      var c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, _key6, {
        enumerable: true,
        configurable: true,
        get: function get() {
          return c.value;
        },
        set: function set(v) {
          return c.value = v;
        }
      });
    };

    for (var _key6 in computedOptions) {
      _loop(_key6);
    }
  }

  if (watchOptions) {
    for (var _key7 in watchOptions) {
      createWatcher(watchOptions[_key7], ctx, publicThis, _key7);
    }
  }

  if (provideOptions) {
    var provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach(function (key) {
      provide(key, provides[key]);
    });
  }

  if (created) {
    callHook(created, instance, "c"
    /* CREATED */
    );
  }

  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach(function (_hook) {
        return register(_hook.bind(publicThis));
      });
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }

  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);

  if (isArray(expose)) {
    if (expose.length) {
      var exposed = instance.exposed || (instance.exposed = {});
      expose.forEach(function (key) {
        Object.defineProperty(exposed, key, {
          get: function get() {
            return publicThis[key];
          },
          set: function set(val) {
            return publicThis[key] = val;
          }
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  } // options that are handled when creating the instance but also need to be
  // applied from mixins


  if (render && instance.render === NOOP) {
    instance.render = render;
  }

  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  } // asset options.


  if (components) instance.components = components;
  if (directives) instance.directives = directives;
}

function resolveInjections(injectOptions, ctx) {
  var checkDuplicateProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOOP;
  var unwrapRef = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }

  var _loop2 = function _loop2(key) {
    var opt = injectOptions[key];
    var injected = void 0;

    if (isObject$1(opt)) {
      if ('default' in opt) {
        injected = inject(opt.from || key, opt.default, true
        /* treat default function as factory */
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }

    if (isRef(injected)) {
      // TODO remove the check in 3.3
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: function get() {
            return injected.value;
          },
          set: function set(v) {
            return injected.value = v;
          }
        });
      } else {
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
  };

  for (var key in injectOptions) {
    _loop2(key);
  }
}

function callHook(hook, instance, type) {
  callWithAsyncErrorHandling(isArray(hook) ? hook.map(function (h) {
    return h.bind(instance.proxy);
  }) : hook.bind(instance.proxy), instance, type);
}

function createWatcher(raw, ctx, publicThis, key) {
  var getter = key.includes('.') ? createPathGetter(publicThis, key) : function () {
    return publicThis[key];
  };

  if (isString(raw)) {
    var handler = ctx[raw];

    if (isFunction$1(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$1(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$1(raw)) {
    if (isArray(raw)) {
      raw.forEach(function (r) {
        return createWatcher(r, ctx, publicThis, key);
      });
    } else {
      var _handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];

      if (isFunction$1(_handler)) {
        watch(getter, _handler, raw);
      }
    }
  } else ;
}
/**
 * Resolve merged options and cache it on the component.
 * This is done only once per-component since the merging does not involve
 * instances.
 */


function resolveMergedOptions(instance) {
  var base = instance.type;
  var mixins = base.mixins,
      extendsOptions = base.extends;
  var _instance$appContext = instance.appContext,
      globalMixins = _instance$appContext.mixins,
      cache = _instance$appContext.optionsCache,
      optionMergeStrategies = _instance$appContext.config.optionMergeStrategies;
  var cached = cache.get(base);
  var resolved;

  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};

    if (globalMixins.length) {
      globalMixins.forEach(function (m) {
        return mergeOptions(resolved, m, optionMergeStrategies, true);
      });
    }

    mergeOptions(resolved, base, optionMergeStrategies);
  }

  cache.set(base, resolved);
  return resolved;
}

function mergeOptions(to, from, strats) {
  var asMixin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var mixins = from.mixins,
      extendsOptions = from.extends;

  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }

  if (mixins) {
    mixins.forEach(function (m) {
      return mergeOptions(to, m, strats, true);
    });
  }

  for (var key in from) {
    if (asMixin && key === 'expose') ;else {
      var strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }

  return to;
}

var internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};

function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }

  if (!to) {
    return from;
  }

  return function mergedDataFn() {
    return extend$2(isFunction$1(to) ? to.call(this, this) : to, isFunction$1(from) ? from.call(this, this) : from);
  };
}

function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}

function normalizeInject(raw) {
  if (isArray(raw)) {
    var res = {};

    for (var i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }

    return res;
  }

  return raw;
}

function mergeAsArray(to, from) {
  return to ? (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(new Set([].concat(to, from))) : from;
}

function mergeObjectOptions(to, from) {
  return to ? extend$2(extend$2(Object.create(null), to), from) : from;
}

function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  var merged = extend$2(Object.create(null), to);

  for (var key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }

  return merged;
}

function initProps(instance, rawProps, isStateful) {
  var isSSR = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var props = {};
  var attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = Object.create(null);
  setFullProps(instance, rawProps, props, attrs); // ensure all declared prop keys are present

  for (var key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = undefined;
    }
  }

  if (isStateful) {
    // stateful
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      // functional w/ optional props, props === attrs
      instance.props = attrs;
    } else {
      // functional w/ declared props
      instance.props = props;
    }
  }

  instance.attrs = attrs;
}

function updateProps(instance, rawProps, rawPrevProps, optimized) {
  var props = instance.props,
      attrs = instance.attrs,
      patchFlag = instance.vnode.patchFlag;
  var rawCurrentProps = toRaw(props);

  var _instance$propsOption2 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_6__["default"])(instance.propsOptions, 1),
      options = _instance$propsOption2[0];

  var hasAttrsChanged = false;

  if ( // always force full diff in dev
  // - #1942 if hmr is enabled with sfc component
  // - vite#872 non-sfc component used by sfc component
  (optimized || patchFlag > 0) && !(patchFlag & 16
  /* FULL_PROPS */
  )) {
    if (patchFlag & 8
    /* PROPS */
    ) {
      // Compiler-generated props & no keys change, just set the updated
      // the props.
      var propsToUpdate = instance.vnode.dynamicProps;

      for (var i = 0; i < propsToUpdate.length; i++) {
        var key = propsToUpdate[i]; // PROPS flag guarantees rawProps to be non-null

        var value = rawProps[key];

        if (options) {
          // attr / props separation was done on init and will be consistent
          // in this code path, so just check if attrs have it.
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            var camelizedKey = camelize$1(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false
            /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    // full props update.
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    } // in case of dynamic props, check if we need to delete keys from
    // the props object


    var kebabKey;

    for (var _key8 in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, _key8) && ( // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      (kebabKey = hyphenate(_key8)) === _key8 || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && ( // for camelCase
          rawPrevProps[_key8] !== undefined || // for kebab-case
          rawPrevProps[kebabKey] !== undefined)) {
            props[_key8] = resolvePropValue(options, rawCurrentProps, _key8, undefined, instance, true
            /* isAbsent */
            );
          }
        } else {
          delete props[_key8];
        }
      }
    } // in the case of functional component w/o props declaration, props and
    // attrs point to the same object so it should already have been updated.


    if (attrs !== rawCurrentProps) {
      for (var _key9 in attrs) {
        if (!rawProps || !hasOwn(rawProps, _key9)) {
          delete attrs[_key9];
          hasAttrsChanged = true;
        }
      }
    }
  } // trigger updates for $attrs in case it's used in component slots


  if (hasAttrsChanged) {
    trigger(instance, "set"
    /* SET */
    , '$attrs');
  }
}

function setFullProps(instance, rawProps, props, attrs) {
  var _instance$propsOption3 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_6__["default"])(instance.propsOptions, 2),
      options = _instance$propsOption3[0],
      needCastKeys = _instance$propsOption3[1];

  var hasAttrsChanged = false;
  var rawCastValues;

  if (rawProps) {
    for (var key in rawProps) {
      // key, ref are reserved and never passed down
      if (isReservedProp(key)) {
        continue;
      }

      var value = rawProps[key]; // prop option names are camelized during normalization, so to support
      // kebab -> camel conversion here we need to camelize the key.

      var camelKey = void 0;

      if (options && hasOwn(options, camelKey = camelize$1(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }

  if (needCastKeys) {
    var rawCurrentProps = toRaw(props);
    var castValues = rawCastValues || EMPTY_OBJ;

    for (var i = 0; i < needCastKeys.length; i++) {
      var _key10 = needCastKeys[i];
      props[_key10] = resolvePropValue(options, rawCurrentProps, _key10, castValues[_key10], instance, !hasOwn(castValues, _key10));
    }
  }

  return hasAttrsChanged;
}

function resolvePropValue(options, props, key, value, instance, isAbsent) {
  var opt = options[key];

  if (opt != null) {
    var hasDefault = hasOwn(opt, 'default'); // default values

    if (hasDefault && value === undefined) {
      var defaultValue = opt.default;

      if (opt.type !== Function && isFunction$1(defaultValue)) {
        var propsDefaults = instance.propsDefaults;

        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    } // boolean casting


    if (opt[0
    /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1
      /* shouldCastTrue */
      ] && (value === '' || value === hyphenate(key))) {
        value = true;
      }
    }
  }

  return value;
}

function normalizePropsOptions(comp, appContext) {
  var asMixin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var cache = appContext.propsCache;
  var cached = cache.get(comp);

  if (cached) {
    return cached;
  }

  var raw = comp.props;
  var normalized = {};
  var needCastKeys = []; // apply mixin/extends props

  var hasExtends = false;

  if (__VUE_OPTIONS_API__ && !isFunction$1(comp)) {
    var extendProps = function extendProps(raw) {
      hasExtends = true;

      var _normalizePropsOption = normalizePropsOptions(raw, appContext, true),
          _normalizePropsOption2 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_6__["default"])(_normalizePropsOption, 2),
          props = _normalizePropsOption2[0],
          keys = _normalizePropsOption2[1];

      extend$2(normalized, props);
      if (keys) needCastKeys.push.apply(needCastKeys, (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(keys));
    };

    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }

    if (comp.extends) {
      extendProps(comp.extends);
    }

    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }

  if (!raw && !hasExtends) {
    cache.set(comp, EMPTY_ARR);
    return EMPTY_ARR;
  }

  if (isArray(raw)) {
    for (var i = 0; i < raw.length; i++) {
      var normalizedKey = camelize$1(raw[i]);

      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (var key in raw) {
      var _normalizedKey = camelize$1(key);

      if (validatePropName(_normalizedKey)) {
        var opt = raw[key];
        var prop = normalized[_normalizedKey] = isArray(opt) || isFunction$1(opt) ? {
          type: opt
        } : opt;

        if (prop) {
          var booleanIndex = getTypeIndex(Boolean, prop.type);
          var stringIndex = getTypeIndex(String, prop.type);
          prop[0
          /* shouldCast */
          ] = booleanIndex > -1;
          prop[1
          /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex; // if the prop needs boolean casting or default value

          if (booleanIndex > -1 || hasOwn(prop, 'default')) {
            needCastKeys.push(_normalizedKey);
          }
        }
      }
    }
  }

  var res = [normalized, needCastKeys];
  cache.set(comp, res);
  return res;
}

function validatePropName(key) {
  if (key[0] !== '$') {
    return true;
  }

  return false;
} // use function string name to check type constructors
// so that it works across vms / iframes.


function getType(ctor) {
  var match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ctor === null ? 'null' : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if (isArray(expectedTypes)) {
    return expectedTypes.findIndex(function (t) {
      return isSameType(t, type);
    });
  } else if (isFunction$1(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  return -1;
}

var isInternalKey = function isInternalKey(key) {
  return key[0] === '_' || key === '$stable';
};

var normalizeSlotValue = function normalizeSlotValue(value) {
  return isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
};

var normalizeSlot = function normalizeSlot(key, rawSlot, ctx) {
  var normalized = withCtx(function () {
    return normalizeSlotValue(rawSlot.apply(void 0, arguments));
  }, ctx);
  normalized._c = false;
  return normalized;
};

var normalizeObjectSlots = function normalizeObjectSlots(rawSlots, slots, instance) {
  var ctx = rawSlots._ctx;

  for (var key in rawSlots) {
    if (isInternalKey(key)) continue;
    var value = rawSlots[key];

    if (isFunction$1(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      (function () {
        var normalized = normalizeSlotValue(value);

        slots[key] = function () {
          return normalized;
        };
      })();
    }
  }
};

var normalizeVNodeSlots = function normalizeVNodeSlots(instance, children) {
  var normalized = normalizeSlotValue(children);

  instance.slots.default = function () {
    return normalized;
  };
};

var initSlots = function initSlots(instance, children) {
  if (instance.vnode.shapeFlag & 32
  /* SLOTS_CHILDREN */
  ) {
    var type = children._;

    if (type) {
      // users can get the shallow readonly version of the slots object through `this.$slots`,
      // we should avoid the proxy object polluting the slots of the internal instance
      instance.slots = toRaw(children); // make compiler marker non-enumerable

      def(children, '_', type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};

    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }

  def(instance.slots, InternalObjectKey, 1);
};

var updateSlots = function updateSlots(instance, children, optimized) {
  var vnode = instance.vnode,
      slots = instance.slots;
  var needDeletionCheck = true;
  var deletionComparisonTarget = EMPTY_OBJ;

  if (vnode.shapeFlag & 32
  /* SLOTS_CHILDREN */
  ) {
    var type = children._;

    if (type) {
      // compiled slots.
      if (optimized && type === 1
      /* STABLE */
      ) {
        // compiled AND stable.
        // no need to update, and skip stale slots removal.
        needDeletionCheck = false;
      } else {
        // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
        // normalization.
        extend$2(slots, children); // #2893
        // when rendering the optimized slots by manually written render function,
        // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,
        // i.e. let the `renderSlot` create the bailed Fragment

        if (!optimized && type === 1
        /* STABLE */
        ) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }

    deletionComparisonTarget = children;
  } else if (children) {
    // non slot object children (direct value) passed to a component
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = {
      default: 1
    };
  } // delete stale slots


  if (needDeletionCheck) {
    for (var key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
/**
 * Adds directives to a VNode.
 */


function withDirectives(vnode, directives) {
  var internalInstance = currentRenderingInstance;

  if (internalInstance === null) {
    return vnode;
  }

  var instance = internalInstance.proxy;
  var bindings = vnode.dirs || (vnode.dirs = []);

  for (var i = 0; i < directives.length; i++) {
    var _directives$i = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_6__["default"])(directives[i], 4),
        dir = _directives$i[0],
        value = _directives$i[1],
        arg = _directives$i[2],
        _directives$i$ = _directives$i[3],
        modifiers = _directives$i$ === void 0 ? EMPTY_OBJ : _directives$i$;

    if (isFunction$1(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      };
    }

    if (dir.deep) {
      traverse(value);
    }

    bindings.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg,
      modifiers
    });
  }

  return vnode;
}

function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  var bindings = vnode.dirs;
  var oldBindings = prevVNode && prevVNode.dirs;

  for (var i = 0; i < bindings.length; i++) {
    var binding = bindings[i];

    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }

    var hook = binding.dir[name];

    if (hook) {
      // disable tracking inside all lifecycle hooks
      // since they can potentially be called inside effects.
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8
      /* DIRECTIVE_HOOK */
      , [vnode.el, binding, vnode, prevVNode]);
      resetTracking();
    }
  }
}

function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: undefined,
      warnHandler: undefined,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap()
  };
}

var uid = 0;

function createAppAPI(render, hydrate) {
  return function createApp(rootComponent) {
    var rootProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (rootProps != null && !isObject$1(rootProps)) {
      rootProps = null;
    }

    var context = createAppContext();
    var installedPlugins = new Set();
    var isMounted = false;
    var app = context.app = {
      _uid: uid++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,

      get config() {
        return context.config;
      },

      set config(v) {},

      use(plugin) {
        for (var _len5 = arguments.length, options = new Array(_len5 > 1 ? _len5 - 1 : 0), _key11 = 1; _key11 < _len5; _key11++) {
          options[_key11 - 1] = arguments[_key11];
        }

        if (installedPlugins.has(plugin)) ;else if (plugin && isFunction$1(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install.apply(plugin, [app].concat(options));
        } else if (isFunction$1(plugin)) {
          installedPlugins.add(plugin);
          plugin.apply(void 0, [app].concat(options));
        } else ;
        return app;
      },

      mixin(mixin) {
        if (__VUE_OPTIONS_API__) {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }

        return app;
      },

      component(name, component) {
        if (!component) {
          return context.components[name];
        }

        context.components[name] = component;
        return app;
      },

      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }

        context.directives[name] = directive;
        return app;
      },

      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          var vnode = createVNode(rootComponent, rootProps); // store app context on the root VNode.
          // this will be set on the root instance on initial mount.

          vnode.appContext = context;

          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }

          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;

          if (__VUE_PROD_DEVTOOLS__) {
            app._instance = vnode.component;
            devtoolsInitApp(app, version);
          }

          return vnode.component.proxy;
        }
      },

      unmount() {
        if (isMounted) {
          render(null, app._container);

          if (__VUE_PROD_DEVTOOLS__) {
            app._instance = null;
            devtoolsUnmountApp(app);
          }

          delete app._container.__vue_app__;
        }
      },

      provide(key, value) {
        // TypeScript doesn't allow symbols as index type
        // https://github.com/Microsoft/TypeScript/issues/24587
        context.provides[key] = value;
        return app;
      }

    };
    return app;
  };
}

var hasMismatch = false;

var isSVGContainer = function isSVGContainer(container) {
  return /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';
};

var isComment = function isComment(node) {
  return node.nodeType === 8;
}
/* COMMENT */
; // Note: hydration is DOM-specific
// But we have to place it in core due to tight coupling with core - splitting
// it out creates a ton of unnecessary complexity.
// Hydration also depends on some renderer internal logic which needs to be
// passed in via arguments.


function createHydrationFunctions(rendererInternals) {
  var mountComponent = rendererInternals.mt,
      patch = rendererInternals.p,
      _rendererInternals$o2 = rendererInternals.o,
      patchProp = _rendererInternals$o2.patchProp,
      nextSibling = _rendererInternals$o2.nextSibling,
      parentNode = _rendererInternals$o2.parentNode,
      remove = _rendererInternals$o2.remove,
      insert = _rendererInternals$o2.insert,
      createComment = _rendererInternals$o2.createComment;

  var hydrate = function hydrate(vnode, container) {
    if (!container.hasChildNodes()) {
      patch(null, vnode, container);
      flushPostFlushCbs();
      return;
    }

    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();

    if (hasMismatch && !false) {
      // this error should show up in production
      console.error("Hydration completed but contains mismatches.");
    }
  };

  var hydrateNode = function hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds) {
    var optimized = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    var isFragmentStart = isComment(node) && node.data === '[';

    var onMismatch = function onMismatch() {
      return handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
    };

    var type = vnode.type,
        ref = vnode.ref,
        shapeFlag = vnode.shapeFlag;
    var domType = node.nodeType;
    vnode.el = node;
    var nextNode = null;

    switch (type) {
      case Text$1:
        if (domType !== 3
        /* TEXT */
        ) {
          nextNode = onMismatch();
        } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
            node.data = vnode.children;
          }

          nextNode = nextSibling(node);
        }

        break;

      case Comment$1:
        if (domType !== 8
        /* COMMENT */
        || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }

        break;

      case Static:
        if (domType !== 1
        /* ELEMENT */
        ) {
          nextNode = onMismatch();
        } else {
          // determine anchor, adopt content
          nextNode = node; // if the static vnode has its content stripped during build,
          // adopt it from the server-rendered HTML.

          var needToAdoptContent = !vnode.children.length;

          for (var i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent) vnode.children += nextNode.outerHTML;

            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }

            nextNode = nextSibling(nextNode);
          }

          return nextNode;
        }

        break;

      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
        }

        break;

      default:
        if (shapeFlag & 1
        /* ELEMENT */
        ) {
          if (domType !== 1
          /* ELEMENT */
          || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
          }
        } else if (shapeFlag & 6
        /* COMPONENT */
        ) {
          // when setting up the render effect, if the initial vnode already
          // has .el set, the component will perform hydration instead of mount
          // on its sub-tree.
          vnode.slotScopeIds = slotScopeIds;

          var _container = parentNode(node);

          mountComponent(vnode, _container, null, parentComponent, parentSuspense, isSVGContainer(_container), optimized); // component may be async, so in the case of fragments we cannot rely
          // on component's rendered output to determine the end of the fragment
          // instead, we do a lookahead to find the end anchor node.

          nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node); // #3787
          // if component is async, it may get moved / unmounted before its
          // inner component is loaded, so we need to give it a placeholder
          // vnode that matches its adopted DOM.

          if (isAsyncWrapper(vnode)) {
            var subTree;

            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : _container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode('') : createVNode('div');
            }

            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64
        /* TELEPORT */
        ) {
          if (domType !== 8
          /* COMMENT */
          ) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
          }
        } else if (shapeFlag & 128
        /* SUSPENSE */
        ) {
          nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
        } else ;

    }

    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode);
    }

    return nextNode;
  };

  var hydrateElement = function hydrateElement(el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) {
    optimized = optimized || !!vnode.dynamicChildren;
    var type = vnode.type,
        props = vnode.props,
        patchFlag = vnode.patchFlag,
        shapeFlag = vnode.shapeFlag,
        dirs = vnode.dirs; // #4006 for form elements with non-string v-model value bindings
    // e.g. <option :value="obj">, <input type="checkbox" :true-value="1">

    var forcePatchValue = type === 'input' && dirs || type === 'option'; // skip props & children if this is hoisted static nodes

    if (forcePatchValue || patchFlag !== -1
    /* HOISTED */
    ) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, 'created');
      } // props


      if (props) {
        if (forcePatchValue || !optimized || patchFlag & (16
        /* FULL_PROPS */
        | 32
        /* HYDRATE_EVENTS */
        )) {
          for (var key in props) {
            if (forcePatchValue && key.endsWith('value') || isOn$1(key) && !isReservedProp(key)) {
              patchProp(el, key, null, props[key]);
            }
          }
        } else if (props.onClick) {
          // Fast path for click listeners (which is most often) to avoid
          // iterating through props.
          patchProp(el, 'onClick', null, props.onClick);
        }
      } // vnode / directive hooks


      var vnodeHooks;

      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }

      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
      }

      if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
        queueEffectWithSuspense(function () {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
        }, parentSuspense);
      } // children


      if (shapeFlag & 16
      /* ARRAY_CHILDREN */
      && // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        var next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);

        while (next) {
          hasMismatch = true; // The SSRed DOM contains more nodes than it should. Remove them.

          var cur = next;
          next = next.nextSibling;
          remove(cur);
        }
      } else if (shapeFlag & 8
      /* TEXT_CHILDREN */
      ) {
        if (el.textContent !== vnode.children) {
          hasMismatch = true;
          el.textContent = vnode.children;
        }
      }
    }

    return el.nextSibling;
  };

  var hydrateChildren = function hydrateChildren(node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) {
    optimized = optimized || !!parentVNode.dynamicChildren;
    var children = parentVNode.children;
    var l = children.length;

    for (var i = 0; i < l; i++) {
      var vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);

      if (node) {
        node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
      } else if (vnode.type === Text$1 && !vnode.children) {
        continue;
      } else {
        hasMismatch = true; // the SSRed DOM didn't contain enough nodes. Mount the missing ones.

        patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
      }
    }

    return node;
  };

  var hydrateFragment = function hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) {
    var fragmentSlotScopeIds = vnode.slotScopeIds;

    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }

    var container = parentNode(node);
    var next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);

    if (next && isComment(next) && next.data === ']') {
      return nextSibling(vnode.anchor = next);
    } else {
      // fragment didn't hydrate successfully, since we didn't get a end anchor
      // back. This should have led to node/children mismatch warnings.
      hasMismatch = true; // since the anchor is missing, we need to create one and insert it

      insert(vnode.anchor = createComment("]"), container, next);
      return next;
    }
  };

  var handleMismatch = function handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) {
    hasMismatch = true;
    vnode.el = null;

    if (isFragment) {
      // remove excessive fragment nodes
      var end = locateClosingAsyncAnchor(node);

      while (true) {
        var _next = nextSibling(node);

        if (_next && _next !== end) {
          remove(_next);
        } else {
          break;
        }
      }
    }

    var next = nextSibling(node);
    var container = parentNode(node);
    remove(node);
    patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
    return next;
  };

  var locateClosingAsyncAnchor = function locateClosingAsyncAnchor(node) {
    var match = 0;

    while (node) {
      node = nextSibling(node);

      if (node && isComment(node)) {
        if (node.data === '[') match++;

        if (node.data === ']') {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }

    return node;
  };

  return [hydrate, hydrateNode];
}
/**
 * This is only called in esm-bundler builds.
 * It is called when a renderer is created, in `baseCreateRenderer` so that
 * importing runtime-core is side-effects free.
 *
 * istanbul-ignore-next
 */


function initFeatureFlags() {
  if (typeof __VUE_OPTIONS_API__ !== 'boolean') {
    getGlobalThis().__VUE_OPTIONS_API__ = true;
  }

  if (typeof __VUE_PROD_DEVTOOLS__ !== 'boolean') {
    getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;
  }
}

var queuePostRenderEffect = queueEffectWithSuspense;
/**
 * The createRenderer function accepts two generic arguments:
 * HostNode and HostElement, corresponding to Node and Element types in the
 * host environment. For example, for runtime-dom, HostNode would be the DOM
 * `Node` interface and HostElement would be the DOM `Element` interface.
 *
 * Custom renderers can pass in the platform specific types like this:
 *
 * ``` js
 * const { render, createApp } = createRenderer<Node, Element>({
 *   patchProp,
 *   ...nodeOps
 * })
 * ```
 */

function createRenderer(options) {
  return baseCreateRenderer(options);
} // Separate API for creating hydration-enabled renderer.
// Hydration logic is only used when calling this function, making it
// tree-shakable.


function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
} // implementation


function baseCreateRenderer(options, createHydrationFns) {
  // compile-time feature flags check
  {
    initFeatureFlags();
  }

  if (__VUE_PROD_DEVTOOLS__) {
    var target = getGlobalThis();
    target.__VUE__ = true;
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__);
  }

  var hostInsert = options.insert,
      hostRemove = options.remove,
      hostPatchProp = options.patchProp,
      hostCreateElement = options.createElement,
      hostCreateText = options.createText,
      hostCreateComment = options.createComment,
      hostSetText = options.setText,
      hostSetElementText = options.setElementText,
      hostParentNode = options.parentNode,
      hostNextSibling = options.nextSibling,
      _options$setScopeId = options.setScopeId,
      hostSetScopeId = _options$setScopeId === void 0 ? NOOP : _options$setScopeId,
      hostCloneNode = options.cloneNode,
      hostInsertStaticContent = options.insertStaticContent; // Note: functions inside this closure should use `const xxx = () => {}`
  // style in order to prevent being inlined by minifiers.

  var patch = function patch(n1, n2, container) {
    var anchor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var parentComponent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var parentSuspense = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var isSVG = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    var slotScopeIds = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
    var optimized = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : !!n2.dynamicChildren;

    if (n1 === n2) {
      return;
    } // patching & not same type, unmount old tree


    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }

    if (n2.patchFlag === -2
    /* BAIL */
    ) {
      optimized = false;
      n2.dynamicChildren = null;
    }

    var type = n2.type,
        ref = n2.ref,
        shapeFlag = n2.shapeFlag;

    switch (type) {
      case Text$1:
        processText(n1, n2, container, anchor);
        break;

      case Comment$1:
        processCommentNode(n1, n2, container, anchor);
        break;

      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }

        break;

      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;

      default:
        if (shapeFlag & 1
        /* ELEMENT */
        ) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6
        /* COMPONENT */
        ) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64
        /* TELEPORT */
        ) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128
        /* SUSPENSE */
        ) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else ;

    } // set ref


    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };

  var processText = function processText(n1, n2, container, anchor) {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      var el = n2.el = n1.el;

      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };

  var processCommentNode = function processCommentNode(n1, n2, container, anchor) {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ''), container, anchor);
    } else {
      // there's no support for dynamic comments
      n2.el = n1.el;
    }
  };

  var mountStaticNode = function mountStaticNode(n2, container, anchor, isSVG) {
    var _hostInsertStaticCont = hostInsertStaticContent(n2.children, container, anchor, isSVG);

    var _hostInsertStaticCont2 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_6__["default"])(_hostInsertStaticCont, 2);

    n2.el = _hostInsertStaticCont2[0];
    n2.anchor = _hostInsertStaticCont2[1];
  };

  var moveStaticNode = function moveStaticNode(_ref12, container, nextSibling) {
    var el = _ref12.el,
        anchor = _ref12.anchor;
    var next;

    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }

    hostInsert(anchor, container, nextSibling);
  };

  var removeStaticNode = function removeStaticNode(_ref13) {
    var el = _ref13.el,
        anchor = _ref13.anchor;
    var next;

    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }

    hostRemove(anchor);
  };

  var processElement = function processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    isSVG = isSVG || n2.type === 'svg';

    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };

  var mountElement = function mountElement(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var el;
    var vnodeHook;
    var type = vnode.type,
        props = vnode.props,
        shapeFlag = vnode.shapeFlag,
        transition = vnode.transition,
        patchFlag = vnode.patchFlag,
        dirs = vnode.dirs;

    if (vnode.el && hostCloneNode !== undefined && patchFlag === -1
    /* HOISTED */
    ) {
      // If a vnode has non-null el, it means it's being reused.
      // Only static vnodes can be reused, so its mounted DOM nodes should be
      // exactly the same, and we can simply do a clone here.
      // only do this in production since cloned trees cannot be HMR updated.
      el = vnode.el = hostCloneNode(vnode.el);
    } else {
      el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props); // mount children first, since some props may rely on child content
      // being already rendered, e.g. `<select value>`

      if (shapeFlag & 8
      /* TEXT_CHILDREN */
      ) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
        mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);
      }

      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, 'created');
      } // props


      if (props) {
        for (var key in props) {
          if (key !== 'value' && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        /**
         * Special case for setting value on DOM elements:
         * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)
         * - it needs to be forced (#1471)
         * #2353 proposes adding another renderer option to configure this, but
         * the properties affects are so finite it is worth special casing it
         * here to reduce the complexity. (Special casing it also should not
         * affect non-DOM renderers)
         */


        if ('value' in props) {
          hostPatchProp(el, 'value', null, props.value);
        }

        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      } // scopeId


      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    }

    if (__VUE_PROD_DEVTOOLS__) {
      Object.defineProperty(el, '__vnode', {
        value: vnode,
        enumerable: false
      });
      Object.defineProperty(el, '__vueParentComponent', {
        value: parentComponent,
        enumerable: false
      });
    }

    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
    } // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
    // #1689 For inside suspense + suspense resolved case, just call it


    var needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;

    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }

    hostInsert(el, container, anchor);

    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(function () {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
      }, parentSuspense);
    }
  };

  var setScopeId = function setScopeId(el, vnode, scopeId, slotScopeIds, parentComponent) {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }

    if (slotScopeIds) {
      for (var i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }

    if (parentComponent) {
      var subTree = parentComponent.subTree;

      if (vnode === subTree) {
        var parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };

  var mountChildren = function mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var start = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;

    for (var i = start; i < children.length; i++) {
      var child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };

  var patchElement = function patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var el = n2.el = n1.el;
    var patchFlag = n2.patchFlag,
        dynamicChildren = n2.dynamicChildren,
        dirs = n2.dirs; // #1426 take the old vnode's patch flag into account since user may clone a
    // compiler-generated vnode, which de-opts to FULL_PROPS

    patchFlag |= n1.patchFlag & 16
    /* FULL_PROPS */
    ;
    var oldProps = n1.props || EMPTY_OBJ;
    var newProps = n2.props || EMPTY_OBJ;
    var vnodeHook;

    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }

    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
    }

    var areChildrenSVG = isSVG && n2.type !== 'foreignObject';

    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
    } else if (!optimized) {
      // full diff
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }

    if (patchFlag > 0) {
      // the presence of a patchFlag means this element's render code was
      // generated by the compiler and can take the fast path.
      // in this path old node and new node are guaranteed to have the same shape
      // (i.e. at the exact same position in the source template)
      if (patchFlag & 16
      /* FULL_PROPS */
      ) {
        // element props contain dynamic keys, full diff needed
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        // class
        // this flag is matched when the element has dynamic class bindings.
        if (patchFlag & 2
        /* CLASS */
        ) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, 'class', null, newProps.class, isSVG);
          }
        } // style
        // this flag is matched when the element has dynamic style bindings


        if (patchFlag & 4
        /* STYLE */
        ) {
          hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
        } // props
        // This flag is matched when the element has dynamic prop/attr bindings
        // other than class and style. The keys of dynamic prop/attrs are saved for
        // faster iteration.
        // Note dynamic keys like :[foo]="bar" will cause this optimization to
        // bail out and go through a full diff because we need to unset the old key


        if (patchFlag & 8
        /* PROPS */
        ) {
          // if the flag is present then dynamicProps must be non-null
          var propsToUpdate = n2.dynamicProps;

          for (var i = 0; i < propsToUpdate.length; i++) {
            var key = propsToUpdate[i];
            var prev = oldProps[key];
            var next = newProps[key]; // #1471 force patch value

            if (next !== prev || key === 'value') {
              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      } // text
      // This flag is matched when the element has only dynamic text children.


      if (patchFlag & 1
      /* TEXT */
      ) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      // unoptimized, full diff
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }

    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(function () {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
      }, parentSuspense);
    }
  }; // The fast path for blocks.


  var patchBlockChildren = function patchBlockChildren(oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) {
    for (var i = 0; i < newChildren.length; i++) {
      var oldVNode = oldChildren[i];
      var newVNode = newChildren[i]; // Determine the container (parent element) for the patch.

      var _container2 = // oldVNode may be an errored async setup() component inside Suspense
      // which will not have a mounted element
      oldVNode.el && ( // - In the case of a Fragment, we need to provide the actual parent
      // of the Fragment itself so it can move its children.
      oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
      // which also requires the correct parent container
      !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
      oldVNode.shapeFlag & (6
      /* COMPONENT */
      | 64
      /* TELEPORT */
      )) ? hostParentNode(oldVNode.el) : // In other cases, the parent container is not actually used so we
      // just pass the block element here to avoid a DOM parentNode call.
      fallbackContainer;

      patch(oldVNode, newVNode, _container2, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };

  var patchProps = function patchProps(el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) {
    if (oldProps !== newProps) {
      for (var key in newProps) {
        // empty string is not valid prop
        if (isReservedProp(key)) continue;
        var next = newProps[key];
        var prev = oldProps[key]; // defer patching value

        if (next !== prev && key !== 'value') {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }

      if (oldProps !== EMPTY_OBJ) {
        for (var _key12 in oldProps) {
          if (!isReservedProp(_key12) && !(_key12 in newProps)) {
            hostPatchProp(el, _key12, oldProps[_key12], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }

      if ('value' in newProps) {
        hostPatchProp(el, 'value', oldProps.value, newProps.value);
      }
    }
  };

  var processFragment = function processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText('');
    var fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText('');
    var patchFlag = n2.patchFlag,
        dynamicChildren = n2.dynamicChildren,
        fragmentSlotScopeIds = n2.slotScopeIds; // check if this is a slot fragment with :slotted scope ids

    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }

    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor); // a fragment can only have array children
      // since they are either generated by the compiler, or implicitly created
      // from arrays.

      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64
      /* STABLE_FRAGMENT */
      && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        // a stable fragment (template root or <template v-for>) doesn't need to
        // patch children order, but it may contain dynamicChildren.
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);

        if ( // #2080 if the stable fragment has a key, it's a <template v-for> that may
        //  get moved around. Make sure all root level vnodes inherit el.
        // #2134 or if it's a component root, it may also get moved around
        // as the component is being moved.
        n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true
          /* shallow */
          );
        }
      } else {
        // keyed / unkeyed, or manual fragments.
        // for keyed & unkeyed, since they are compiler generated from v-for,
        // each child is guaranteed to be a block so the fragment will never
        // have dynamicChildren.
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };

  var processComponent = function processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    n2.slotScopeIds = slotScopeIds;

    if (n1 == null) {
      if (n2.shapeFlag & 512
      /* COMPONENT_KEPT_ALIVE */
      ) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };

  var mountComponent = function mountComponent(initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) {
    var instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense); // inject renderer internals for keepAlive

    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    } // resolve props and slots for setup context


    {
      setupComponent(instance);
    } // setup() is async. This component relies on async logic to be resolved
    // before proceeding

    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect); // Give it a placeholder if this is not hydration
      // TODO handle self-defined fallback

      if (!initialVNode.el) {
        var placeholder = instance.subTree = createVNode(Comment$1);
        processCommentNode(null, placeholder, container, anchor);
      }

      return;
    }

    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
  };

  var updateComponent = function updateComponent(n1, n2, optimized) {
    var instance = n2.component = n1.component;

    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        // normal update
        instance.next = n2; // in case the child component is also queued, remove it to avoid
        // double updating the same child component in the same flush.

        invalidateJob(instance.update); // instance.update is the reactive effect.

        instance.update();
      }
    } else {
      // no update needed. just copy over properties
      n2.component = n1.component;
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };

  var setupRenderEffect = function setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) {
    var componentUpdateFn = function componentUpdateFn() {
      if (!instance.isMounted) {
        var vnodeHook;
        var _initialVNode = initialVNode,
            el = _initialVNode.el,
            props = _initialVNode.props;
        var bm = instance.bm,
            m = instance.m,
            parent = instance.parent;
        var isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        effect.allowRecurse = false; // beforeMount hook

        if (bm) {
          invokeArrayFns(bm);
        } // onVnodeBeforeMount


        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }

        effect.allowRecurse = true;

        if (el && hydrateNode) {
          // vnode has adopted host node - perform hydration instead of mount.
          var hydrateSubTree = function hydrateSubTree() {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
          };

          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then( // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            function () {
              return !instance.isUnmounted && hydrateSubTree();
            });
          } else {
            hydrateSubTree();
          }
        } else {
          var subTree = instance.subTree = renderComponentRoot(instance);
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          initialVNode.el = subTree.el;
        } // mounted hook


        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        } // onVnodeMounted


        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          var scopedInitialVNode = initialVNode;
          queuePostRenderEffect(function () {
            return invokeVNodeHook(vnodeHook, parent, scopedInitialVNode);
          }, parentSuspense);
        } // activated hook for keep-alive roots.
        // #1742 activated hook must be accessed after first render
        // since the hook may be injected by a child keep-alive


        if (initialVNode.shapeFlag & 256
        /* COMPONENT_SHOULD_KEEP_ALIVE */
        ) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }

        instance.isMounted = true;

        if (__VUE_PROD_DEVTOOLS__) {
          devtoolsComponentAdded(instance);
        } // #2458: deference mount-only object parameters to prevent memleaks


        initialVNode = container = anchor = null;
      } else {
        // updateComponent
        // This is triggered by mutation of component's own state (next: null)
        // OR parent calling processComponent (next: VNode)
        var next = instance.next,
            bu = instance.bu,
            u = instance.u,
            _parent = instance.parent,
            vnode = instance.vnode;
        var originNext = next;

        var _vnodeHook; // Disallow component effect recursion during pre-lifecycle hooks.


        effect.allowRecurse = false;

        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        } // beforeUpdate hook


        if (bu) {
          invokeArrayFns(bu);
        } // onVnodeBeforeUpdate


        if (_vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(_vnodeHook, _parent, next, vnode);
        }

        effect.allowRecurse = true;
        var nextTree = renderComponentRoot(instance);
        var prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(prevTree, nextTree, // parent may have changed if it's in a teleport
        hostParentNode(prevTree.el), // anchor may have changed if it's in a fragment
        getNextHostNode(prevTree), instance, parentSuspense, isSVG);
        next.el = nextTree.el;

        if (originNext === null) {
          // self-triggered update. In case of HOC, update parent component
          // vnode el. HOC is indicated by parent instance's subTree pointing
          // to child component's vnode
          updateHOCHostEl(instance, nextTree.el);
        } // updated hook


        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        } // onVnodeUpdated


        if (_vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(function () {
            return invokeVNodeHook(_vnodeHook, _parent, next, vnode);
          }, parentSuspense);
        }

        if (__VUE_PROD_DEVTOOLS__) {
          devtoolsComponentUpdated(instance);
        }
      }
    }; // create reactive effect for rendering


    var effect = new ReactiveEffect(componentUpdateFn, function () {
      return queueJob(instance.update);
    }, instance.scope // track it in component's effect scope
    );
    var update = instance.update = effect.run.bind(effect);
    update.id = instance.uid; // allowRecurse
    // #1801, #2043 component render effects should allow recursive updates

    effect.allowRecurse = update.allowRecurse = true;
    update();
  };

  var updateComponentPreRender = function updateComponentPreRender(instance, nextVNode, optimized) {
    nextVNode.component = instance;
    var prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking(); // props update may have triggered pre-flush watchers.
    // flush them before the render update.

    flushPreFlushCbs(undefined, instance.update);
    resetTracking();
  };

  var patchChildren = function patchChildren(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds) {
    var optimized = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
    var c1 = n1 && n1.children;
    var prevShapeFlag = n1 ? n1.shapeFlag : 0;
    var c2 = n2.children;
    var patchFlag = n2.patchFlag,
        shapeFlag = n2.shapeFlag; // fast path

    if (patchFlag > 0) {
      if (patchFlag & 128
      /* KEYED_FRAGMENT */
      ) {
        // this could be either fully-keyed or mixed (some keyed some not)
        // presence of patchFlag means children are guaranteed to be arrays
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256
      /* UNKEYED_FRAGMENT */
      ) {
        // unkeyed
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    } // children has 3 possibilities: text, array or no children.


    if (shapeFlag & 8
    /* TEXT_CHILDREN */
    ) {
      // text children fast path
      if (prevShapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }

      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
        // prev children was array
        if (shapeFlag & 16
        /* ARRAY_CHILDREN */
        ) {
          // two arrays, cannot assume anything, do full diff
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          // no new children, just unmount old
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        // prev children was text OR null
        // new children is array OR null
        if (prevShapeFlag & 8
        /* TEXT_CHILDREN */
        ) {
          hostSetElementText(container, '');
        } // mount new if array


        if (shapeFlag & 16
        /* ARRAY_CHILDREN */
        ) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };

  var patchUnkeyedChildren = function patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    var oldLength = c1.length;
    var newLength = c2.length;
    var commonLength = Math.min(oldLength, newLength);
    var i;

    for (i = 0; i < commonLength; i++) {
      var nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }

    if (oldLength > newLength) {
      // remove old
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      // mount new
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  }; // can be all-keyed or mixed


  var patchKeyedChildren = function patchKeyedChildren(c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var i = 0;
    var l2 = c2.length;
    var e1 = c1.length - 1; // prev ending index

    var e2 = l2 - 1; // next ending index
    // 1. sync from start
    // (a b) c
    // (a b) d e

    while (i <= e1 && i <= e2) {
      var n1 = c1[i];
      var n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);

      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }

      i++;
    } // 2. sync from end
    // a (b c)
    // d e (b c)


    while (i <= e1 && i <= e2) {
      var _n = c1[e1];

      var _n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);

      if (isSameVNodeType(_n, _n2)) {
        patch(_n, _n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }

      e1--;
      e2--;
    } // 3. common sequence + mount
    // (a b)
    // (a b) c
    // i = 2, e1 = 1, e2 = 2
    // (a b)
    // c (a b)
    // i = 0, e1 = -1, e2 = 0


    if (i > e1) {
      if (i <= e2) {
        var nextPos = e2 + 1;
        var anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;

        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } // 4. common sequence + unmount
    // (a b) c
    // (a b)
    // i = 2, e1 = 2, e2 = 1
    // a (b c)
    // (b c)
    // i = 0, e1 = 0, e2 = -1
    else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } // 5. unknown sequence
    // [i ... e1 + 1]: a b [c d e] f g
    // [i ... e2 + 1]: a b [e d c h] f g
    // i = 2, e1 = 4, e2 = 5
    else {
      var s1 = i; // prev starting index

      var s2 = i; // next starting index
      // 5.1 build key:index map for newChildren

      var keyToNewIndexMap = new Map();

      for (i = s2; i <= e2; i++) {
        var nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);

        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      } // 5.2 loop through old children left to be patched and try to patch
      // matching nodes & remove nodes that are no longer present


      var j;
      var patched = 0;
      var toBePatched = e2 - s2 + 1;
      var moved = false; // used to track whether any node has moved

      var maxNewIndexSoFar = 0; // works as Map<newIndex, oldIndex>
      // Note that oldIndex is offset by +1
      // and oldIndex = 0 is a special value indicating the new node has
      // no corresponding old node.
      // used for determining longest stable subsequence

      var newIndexToOldIndexMap = new Array(toBePatched);

      for (i = 0; i < toBePatched; i++) {
        newIndexToOldIndexMap[i] = 0;
      }

      for (i = s1; i <= e1; i++) {
        var prevChild = c1[i];

        if (patched >= toBePatched) {
          // all new children have been patched so this can only be a removal
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }

        var newIndex = void 0;

        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          // key-less node, try to locate a key-less node of the same type
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }

        if (newIndex === undefined) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;

          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }

          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      } // 5.3 move and mount
      // generate longest stable subsequence only when nodes have moved


      var increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1; // looping backwards so that we can use last patched node as anchor

      for (i = toBePatched - 1; i >= 0; i--) {
        var nextIndex = s2 + i;
        var _nextChild = c2[nextIndex];

        var _anchor2 = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;

        if (newIndexToOldIndexMap[i] === 0) {
          // mount new
          patch(null, _nextChild, container, _anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          // move if:
          // There is no stable subsequence (e.g. a reverse)
          // OR current node is not among the stable sequence
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(_nextChild, container, _anchor2, 2
            /* REORDER */
            );
          } else {
            j--;
          }
        }
      }
    }
  };

  var move = function move(vnode, container, anchor, moveType) {
    var parentSuspense = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var el = vnode.el,
        type = vnode.type,
        transition = vnode.transition,
        children = vnode.children,
        shapeFlag = vnode.shapeFlag;

    if (shapeFlag & 6
    /* COMPONENT */
    ) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }

    if (shapeFlag & 128
    /* SUSPENSE */
    ) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }

    if (shapeFlag & 64
    /* TELEPORT */
    ) {
      type.move(vnode, container, anchor, internals);
      return;
    }

    if (type === Fragment) {
      hostInsert(el, container, anchor);

      for (var i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }

      hostInsert(vnode.anchor, container, anchor);
      return;
    }

    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    } // single nodes


    var needTransition = moveType !== 2
    /* REORDER */
    && shapeFlag & 1
    /* ELEMENT */
    && transition;

    if (needTransition) {
      if (moveType === 0
      /* ENTER */
      ) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(function () {
          return transition.enter(el);
        }, parentSuspense);
      } else {
        var leave = transition.leave,
            delayLeave = transition.delayLeave,
            afterLeave = transition.afterLeave;

        var _remove = function _remove() {
          return hostInsert(el, container, anchor);
        };

        var performLeave = function performLeave() {
          leave(el, function () {
            _remove();

            afterLeave && afterLeave();
          });
        };

        if (delayLeave) {
          delayLeave(el, _remove, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };

  var unmount = function unmount(vnode, parentComponent, parentSuspense) {
    var doRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var optimized = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var type = vnode.type,
        props = vnode.props,
        ref = vnode.ref,
        children = vnode.children,
        dynamicChildren = vnode.dynamicChildren,
        shapeFlag = vnode.shapeFlag,
        patchFlag = vnode.patchFlag,
        dirs = vnode.dirs; // unset ref

    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode, true);
    }

    if (shapeFlag & 256
    /* COMPONENT_SHOULD_KEEP_ALIVE */
    ) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }

    var shouldInvokeDirs = shapeFlag & 1
    /* ELEMENT */
    && dirs;
    var shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    var vnodeHook;

    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }

    if (shapeFlag & 6
    /* COMPONENT */
    ) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128
      /* SUSPENSE */
      ) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }

      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
      }

      if (shapeFlag & 64
      /* TELEPORT */
      ) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && ( // #1153: fast path should not be taken for non-stable (v-for) fragments
      type !== Fragment || patchFlag > 0 && patchFlag & 64
      /* STABLE_FRAGMENT */
      )) {
        // fast path for block nodes: only need to unmount dynamic children.
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128
      /* KEYED_FRAGMENT */
      | 256
      /* UNKEYED_FRAGMENT */
      ) || !optimized && shapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
        unmountChildren(children, parentComponent, parentSuspense);
      }

      if (doRemove) {
        remove(vnode);
      }
    }

    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(function () {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
      }, parentSuspense);
    }
  };

  var remove = function remove(vnode) {
    var type = vnode.type,
        el = vnode.el,
        anchor = vnode.anchor,
        transition = vnode.transition;

    if (type === Fragment) {
      removeFragment(el, anchor);
      return;
    }

    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }

    var performRemove = function performRemove() {
      hostRemove(el);

      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };

    if (vnode.shapeFlag & 1
    /* ELEMENT */
    && transition && !transition.persisted) {
      var leave = transition.leave,
          delayLeave = transition.delayLeave;

      var performLeave = function performLeave() {
        return leave(el, performRemove);
      };

      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };

  var removeFragment = function removeFragment(cur, end) {
    // For fragments, directly remove all contained DOM nodes.
    // (fragment child nodes cannot have transition)
    var next;

    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }

    hostRemove(end);
  };

  var unmountComponent = function unmountComponent(instance, parentSuspense, doRemove) {
    var bum = instance.bum,
        scope = instance.scope,
        update = instance.update,
        subTree = instance.subTree,
        um = instance.um; // beforeUnmount hook

    if (bum) {
      invokeArrayFns(bum);
    } // stop effects in component scope


    scope.stop(); // update may be null if a component is unmounted before its async
    // setup has resolved.

    if (update) {
      // so that scheduler will no longer invoke it
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    } // unmounted hook


    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }

    queuePostRenderEffect(function () {
      instance.isUnmounted = true;
    }, parentSuspense); // A component with async dep inside a pending suspense is unmounted before
    // its async dep resolves. This should remove the dep from the suspense, and
    // cause the suspense to resolve immediately if that was the last dep.

    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;

      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }

    if (__VUE_PROD_DEVTOOLS__) {
      devtoolsComponentRemoved(instance);
    }
  };

  var unmountChildren = function unmountChildren(children, parentComponent, parentSuspense) {
    var doRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var optimized = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var start = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    for (var i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };

  var getNextHostNode = function getNextHostNode(vnode) {
    if (vnode.shapeFlag & 6
    /* COMPONENT */
    ) {
      return getNextHostNode(vnode.component.subTree);
    }

    if (vnode.shapeFlag & 128
    /* SUSPENSE */
    ) {
      return vnode.suspense.next();
    }

    return hostNextSibling(vnode.anchor || vnode.el);
  };

  var render = function render(vnode, container, isSVG) {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }

    flushPostFlushCbs();
    container._vnode = vnode;
  };

  var internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  var hydrate;
  var hydrateNode;

  if (createHydrationFns) {
    var _createHydrationFns = createHydrationFns(internals);

    var _createHydrationFns2 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_6__["default"])(_createHydrationFns, 2);

    hydrate = _createHydrationFns2[0];
    hydrateNode = _createHydrationFns2[1];
  }

  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}

function setRef(rawRef, oldRawRef, parentSuspense, vnode) {
  var isUnmount = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  if (isArray(rawRef)) {
    rawRef.forEach(function (r, i) {
      return setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount);
    });
    return;
  }

  if (isAsyncWrapper(vnode) && !isUnmount) {
    // when mounting async components, nothing needs to be done,
    // because the template ref is forwarded to inner component
    return;
  }

  var refValue = vnode.shapeFlag & 4
  /* STATEFUL_COMPONENT */
  ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  var value = isUnmount ? null : refValue;
  var owner = rawRef.i,
      ref = rawRef.r;
  var oldRef = oldRawRef && oldRawRef.r;
  var refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  var setupState = owner.setupState; // dynamic ref changed. unset old ref

  if (oldRef != null && oldRef !== ref) {
    if (isString(oldRef)) {
      refs[oldRef] = null;

      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }

  if (isString(ref)) {
    var doSet = function doSet() {
      {
        refs[ref] = value;
      }

      if (hasOwn(setupState, ref)) {
        setupState[ref] = value;
      }
    }; // #1789: for non-null values, set them after render
    // null values means this is unmount and it should not overwrite another
    // ref with the same key


    if (value) {
      doSet.id = -1;
      queuePostRenderEffect(doSet, parentSuspense);
    } else {
      doSet();
    }
  } else if (isRef(ref)) {
    var _doSet = function _doSet() {
      ref.value = value;
    };

    if (value) {
      _doSet.id = -1;
      queuePostRenderEffect(_doSet, parentSuspense);
    } else {
      _doSet();
    }
  } else if (isFunction$1(ref)) {
    callWithErrorHandling(ref, owner, 12
    /* FUNCTION_REF */
    , [value, refs]);
  } else ;
}

function invokeVNodeHook(hook, instance, vnode) {
  var prevVNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  callWithAsyncErrorHandling(hook, instance, 7
  /* VNODE_HOOK */
  , [vnode, prevVNode]);
}
/**
 * #1156
 * When a component is HMR-enabled, we need to make sure that all static nodes
 * inside a block also inherit the DOM element from the previous tree so that
 * HMR updates (which are full updates) can retrieve the element for patching.
 *
 * #2080
 * Inside keyed `template` fragment static children, if a fragment is moved,
 * the children will always moved so that need inherit el form previous nodes
 * to ensure correct moved position.
 */


function traverseStaticChildren(n1, n2) {
  var shallow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var ch1 = n1.children;
  var ch2 = n2.children;

  if (isArray(ch1) && isArray(ch2)) {
    for (var i = 0; i < ch1.length; i++) {
      // this is only called in the optimized path so array children are
      // guaranteed to be vnodes
      var c1 = ch1[i];
      var c2 = ch2[i];

      if (c2.shapeFlag & 1
      /* ELEMENT */
      && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32
        /* HYDRATE_EVENTS */
        ) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }

        if (!shallow) traverseStaticChildren(c1, c2);
      }
    }
  }
} // https://en.wikipedia.org/wiki/Longest_increasing_subsequence


function getSequence(arr) {
  var p = arr.slice();
  var result = [0];
  var i, j, u, v, c;
  var len = arr.length;

  for (i = 0; i < len; i++) {
    var arrI = arr[i];

    if (arrI !== 0) {
      j = result[result.length - 1];

      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }

      u = 0;
      v = result.length - 1;

      while (u < v) {
        c = u + v >> 1;

        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }

      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }

        result[u] = i;
      }
    }
  }

  u = result.length;
  v = result[u - 1];

  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }

  return result;
}

var isTeleport = function isTeleport(type) {
  return type.__isTeleport;
};

var isTeleportDisabled = function isTeleportDisabled(props) {
  return props && (props.disabled || props.disabled === '');
};

var isTargetSVG = function isTargetSVG(target) {
  return typeof SVGElement !== 'undefined' && target instanceof SVGElement;
};

var resolveTarget = function resolveTarget(props, select) {
  var targetSelector = props && props.to;

  if (isString(targetSelector)) {
    if (!select) {
      return null;
    } else {
      var target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};

var TeleportImpl = {
  __isTeleport: true,

  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    var mountChildren = internals.mc,
        patchChildren = internals.pc,
        patchBlockChildren = internals.pbc,
        _internals$o = internals.o,
        insert = _internals$o.insert,
        querySelector = _internals$o.querySelector,
        createText = _internals$o.createText,
        createComment = _internals$o.createComment;
    var disabled = isTeleportDisabled(n2.props);
    var shapeFlag = n2.shapeFlag,
        children = n2.children,
        dynamicChildren = n2.dynamicChildren;

    if (n1 == null) {
      // insert anchors in the main view
      var placeholder = n2.el = createText('');
      var mainAnchor = n2.anchor = createText('');
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      var target = n2.target = resolveTarget(n2.props, querySelector);
      var targetAnchor = n2.targetAnchor = createText('');

      if (target) {
        insert(targetAnchor, target); // #2652 we could be teleporting from a non-SVG tree into an SVG tree

        isSVG = isSVG || isTargetSVG(target);
      }

      var mount = function mount(container, anchor) {
        // Teleport *always* has Array children. This is enforced in both the
        // compiler and vnode children normalization.
        if (shapeFlag & 16
        /* ARRAY_CHILDREN */
        ) {
          mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };

      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      // update content
      n2.el = n1.el;

      var _mainAnchor = n2.anchor = n1.anchor;

      var _target = n2.target = n1.target;

      var _targetAnchor = n2.targetAnchor = n1.targetAnchor;

      var wasDisabled = isTeleportDisabled(n1.props);
      var currentContainer = wasDisabled ? container : _target;
      var currentAnchor = wasDisabled ? _mainAnchor : _targetAnchor;
      isSVG = isSVG || isTargetSVG(_target);

      if (dynamicChildren) {
        // fast path when the teleport happens to be a block root
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds); // even in block tree mode we need to make sure all root-level nodes
        // in the teleport inherit previous DOM references so that they can
        // be moved in future patches.

        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }

      if (disabled) {
        if (!wasDisabled) {
          // enabled -> disabled
          // move into main container
          moveTeleport(n2, container, _mainAnchor, internals, 1
          /* TOGGLE */
          );
        }
      } else {
        // target changed
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          var nextTarget = n2.target = resolveTarget(n2.props, querySelector);

          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0
            /* TARGET_CHANGE */
            );
          }
        } else if (wasDisabled) {
          // disabled -> enabled
          // move into teleport target
          moveTeleport(n2, _target, _targetAnchor, internals, 1
          /* TOGGLE */
          );
        }
      }
    }
  },

  remove(vnode, parentComponent, parentSuspense, optimized, _ref14, doRemove) {
    var unmount = _ref14.um,
        hostRemove = _ref14.o.remove;
    var shapeFlag = vnode.shapeFlag,
        children = vnode.children,
        anchor = vnode.anchor,
        targetAnchor = vnode.targetAnchor,
        target = vnode.target,
        props = vnode.props;

    if (target) {
      hostRemove(targetAnchor);
    } // an unmounted teleport should always remove its children if not disabled


    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);

      if (shapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },

  move: moveTeleport,
  hydrate: hydrateTeleport
};

function moveTeleport(vnode, container, parentAnchor, _ref15) {
  var insert = _ref15.o.insert,
      move = _ref15.m;
  var moveType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;

  // move target anchor if this is a target change.
  if (moveType === 0
  /* TARGET_CHANGE */
  ) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }

  var el = vnode.el,
      anchor = vnode.anchor,
      shapeFlag = vnode.shapeFlag,
      children = vnode.children,
      props = vnode.props;
  var isReorder = moveType === 2
  /* REORDER */
  ; // move main view anchor if this is a re-order.

  if (isReorder) {
    insert(el, container, parentAnchor);
  } // if this is a re-order and teleport is enabled (content is in target)
  // do not move children. So the opposite is: only move children if this
  // is not a reorder, or the teleport is disabled


  if (!isReorder || isTeleportDisabled(props)) {
    // Teleport has either Array children or no children.
    if (shapeFlag & 16
    /* ARRAY_CHILDREN */
    ) {
      for (var i = 0; i < children.length; i++) {
        move(children[i], container, parentAnchor, 2
        /* REORDER */
        );
      }
    }
  } // move main view anchor if this is a re-order.


  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}

function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, _ref16, hydrateChildren) {
  var _ref16$o = _ref16.o,
      nextSibling = _ref16$o.nextSibling,
      parentNode = _ref16$o.parentNode,
      querySelector = _ref16$o.querySelector;
  var target = vnode.target = resolveTarget(vnode.props, querySelector);

  if (target) {
    // if multiple teleports rendered to the same target element, we need to
    // pick up from where the last teleport finished instead of the first node
    var targetNode = target._lpa || target.firstChild;

    if (vnode.shapeFlag & 16
    /* ARRAY_CHILDREN */
    ) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
      }

      target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
    }
  }

  return vnode.anchor && nextSibling(vnode.anchor);
} // Force-casted public typing for h and TSX props inference


var Teleport = TeleportImpl;
var COMPONENTS = 'components';
var DIRECTIVES = 'directives';
/**
 * @private
 */

function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}

var NULL_DYNAMIC_COMPONENT = Symbol();
/**
 * @private
 */

function resolveDynamicComponent(component) {
  if (isString(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    // invalid types will fallthrough to createVNode and raise warning
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
/**
 * @private
 */


function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
} // implementation


function resolveAsset(type, name) {
  var warnMissing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var maybeSelfReference = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var instance = currentRenderingInstance || currentInstance;

  if (instance) {
    var Component = instance.type; // explicit self name has highest priority

    if (type === COMPONENTS) {
      var selfName = getComponentName(Component);

      if (selfName && (selfName === name || selfName === camelize$1(name) || selfName === capitalize(camelize$1(name)))) {
        return Component;
      }
    }

    var res = // local registration
    // check instance[type] first which is resolved for options API
    resolve(instance[type] || Component[type], name) || // global registration
    resolve(instance.appContext[type], name);

    if (!res && maybeSelfReference) {
      // fallback to implicit self-reference
      return Component;
    }

    return res;
  }
}

function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize$1(name)] || registry[capitalize(camelize$1(name))]);
}

var Fragment = Symbol(undefined);
var Text$1 = Symbol(undefined);
var Comment$1 = Symbol(undefined);
var Static = Symbol(undefined); // Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).

var blockStack = [];
var currentBlock = null;
/**
 * Open a block.
 * This must be called before `createBlock`. It cannot be part of `createBlock`
 * because the children of the block are evaluated before `createBlock` itself
 * is called. The generated code typically looks like this:
 *
 * ```js
 * function render() {
 *   return (openBlock(),createBlock('div', null, [...]))
 * }
 * ```
 * disableTracking is true when creating a v-for fragment block, since a v-for
 * fragment always diffs its children.
 *
 * @private
 */

function openBlock() {
  var disableTracking = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  blockStack.push(currentBlock = disableTracking ? null : []);
}

function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
} // Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)


var isBlockTreeEnabled = 1;
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */

function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}

function setupBlock(vnode) {
  // save current block children on the block vnode
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null; // close block

  closeBlock(); // a block is always going to be patched, so track it as a child of its
  // parent block

  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }

  return vnode;
}
/**
 * @private
 */


function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true
  /* isBlock */
  ));
}
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */


function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true
  /* isBlock: prevent a block from tracking itself */
  ));
}

function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}

function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
/**
 * Internal API for registering an arguments transform for createVNode
 * used for creating stubs in the test-utils
 * It is *internal* but needs to be exposed for test-utils to pick up proper
 * typings
 */


function transformVNodeArgs(transformer) {}

var InternalObjectKey = "__vInternal";

var normalizeKey = function normalizeKey(_ref17) {
  var key = _ref17.key;
  return key != null ? key : null;
};

var normalizeRef = function normalizeRef(_ref18) {
  var ref = _ref18.ref;
  return ref != null ? isString(ref) || isRef(ref) || isFunction$1(ref) ? {
    i: currentRenderingInstance,
    r: ref
  } : ref : null;
};

function createBaseVNode(type) {
  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var patchFlag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var dynamicProps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var shapeFlag = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : type === Fragment ? 0 : 1;
  var isBlockNode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  var needFullChildrenNormalization = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  var vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null
  };

  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children); // normalize suspense children

    if (shapeFlag & 128
    /* SUSPENSE */
    ) {
      type.normalize(vnode);
    }
  } else if (children) {
    // compiled element vnode - if children is passed, only possible types are
    // string or Array.
    vnode.shapeFlag |= isString(children) ? 8
    /* TEXT_CHILDREN */
    : 16
    /* ARRAY_CHILDREN */
    ;
  } // track vnode for block tree


  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && ( // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  vnode.patchFlag > 0 || shapeFlag & 6
  /* COMPONENT */
  ) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32
  /* HYDRATE_EVENTS */
  ) {
    currentBlock.push(vnode);
  }

  return vnode;
}

var createVNode = _createVNode;

function _createVNode(type) {
  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var patchFlag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var dynamicProps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var isBlockNode = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment$1;
  }

  if (isVNode(type)) {
    // createVNode receiving an existing vnode. This happens in cases like
    // <component :is="vnode"/>
    // #2078 make sure to merge refs during the clone instead of overwriting it
    var cloned = cloneVNode(type, props, true
    /* mergeRef: true */
    );

    if (children) {
      normalizeChildren(cloned, children);
    }

    return cloned;
  } // class component normalization.


  if (isClassComponent(type)) {
    type = type.__vccOpts;
  } // class & style normalization.


  if (props) {
    // for reactive or proxy objects, we need to clone it to enable mutation.
    props = guardReactiveProps(props);
    var _props = props,
        klass = _props.class,
        style = _props.style;

    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }

    if (isObject$1(style)) {
      // reactive state objects need to be cloned since they are likely to be
      // mutated
      if (isProxy(style) && !isArray(style)) {
        style = extend$2({}, style);
      }

      props.style = normalizeStyle(style);
    }
  } // encode the vnode type information into a bitmap


  var shapeFlag = isString(type) ? 1
  /* ELEMENT */
  : isSuspense(type) ? 128
  /* SUSPENSE */
  : isTeleport(type) ? 64
  /* TELEPORT */
  : isObject$1(type) ? 4
  /* STATEFUL_COMPONENT */
  : isFunction$1(type) ? 2
  /* FUNCTIONAL_COMPONENT */
  : 0;
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}

function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || InternalObjectKey in props ? extend$2({}, props) : props;
}

function cloneVNode(vnode, extraProps) {
  var mergeRef = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // This is intentionally NOT using spread or extend to avoid the runtime
  // key enumeration cost.
  var props = vnode.props,
      ref = vnode.ref,
      patchFlag = vnode.patchFlag,
      children = vnode.children;
  var mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  var cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? // #2078 in the case of <component :is="vnode" ref="extra"/>
    // if the vnode itself already has a ref, cloneVNode will need to merge
    // the refs so the single vnode can be set on multiple refs
    mergeRef && ref ? isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: perserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 // hoisted node
    ? 16
    /* FULL_PROPS */
    : patchFlag | 16
    /* FULL_PROPS */
    : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor
  };
  return cloned;
}
/**
 * @private
 */


function createTextVNode() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ' ';
  var flag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return createVNode(Text$1, null, text, flag);
}
/**
 * @private
 */


function createStaticVNode(content, numberOfNodes) {
  // A static vnode can contain multiple stringified elements, and the number
  // of elements is necessary for hydration.
  var vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
/**
 * @private
 */


function createCommentVNode() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var asBlock = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return asBlock ? (openBlock(), createBlock(Comment$1, null, text)) : createVNode(Comment$1, null, text);
}

function normalizeVNode(child) {
  if (child == null || typeof child === 'boolean') {
    // empty placeholder
    return createVNode(Comment$1);
  } else if (isArray(child)) {
    // fragment
    return createVNode(Fragment, null, // #3666, avoid reference pollution when reusing vnode
    child.slice());
  } else if (typeof child === 'object') {
    // already vnode, this should be the most common since compiled templates
    // always produce all-vnode children arrays
    return cloneIfMounted(child);
  } else {
    // strings and numbers
    return createVNode(Text$1, null, String(child));
  }
} // optimized normalization for template-compiled render fns


function cloneIfMounted(child) {
  return child.el === null || child.memo ? child : cloneVNode(child);
}

function normalizeChildren(vnode, children) {
  var type = 0;
  var shapeFlag = vnode.shapeFlag;

  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16
    /* ARRAY_CHILDREN */
    ;
  } else if (typeof children === 'object') {
    if (shapeFlag & (1
    /* ELEMENT */
    | 64
    /* TELEPORT */
    )) {
      // Normalize slot to plain children for plain element and Teleport
      var slot = children.default;

      if (slot) {
        // _c marker is added by withCtx() indicating this is a compiled slot
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }

      return;
    } else {
      type = 32
      /* SLOTS_CHILDREN */
      ;
      var slotFlag = children._;

      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3
      /* FORWARDED */
      && currentRenderingInstance) {
        // a child component receives forwarded slots from the parent.
        // its slot type is determined by its parent's slot type.
        if (currentRenderingInstance.slots._ === 1
        /* STABLE */
        ) {
          children._ = 1
          /* STABLE */
          ;
        } else {
          children._ = 2
          /* DYNAMIC */
          ;
          vnode.patchFlag |= 1024
          /* DYNAMIC_SLOTS */
          ;
        }
      }
    }
  } else if (isFunction$1(children)) {
    children = {
      default: children,
      _ctx: currentRenderingInstance
    };
    type = 32
    /* SLOTS_CHILDREN */
    ;
  } else {
    children = String(children); // force teleport children to array so it can be moved around

    if (shapeFlag & 64
    /* TELEPORT */
    ) {
      type = 16
      /* ARRAY_CHILDREN */
      ;
      children = [createTextVNode(children)];
    } else {
      type = 8
      /* TEXT_CHILDREN */
      ;
    }
  }

  vnode.children = children;
  vnode.shapeFlag |= type;
}

function mergeProps() {
  var ret = {};

  for (var i = 0; i < arguments.length; i++) {
    var toMerge = i < 0 || arguments.length <= i ? undefined : arguments[i];

    for (var key in toMerge) {
      if (key === 'class') {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === 'style') {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn$1(key)) {
        var existing = ret[key];
        var incoming = toMerge[key];

        if (existing !== incoming) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== '') {
        ret[key] = toMerge[key];
      }
    }
  }

  return ret;
}
/**
 * Actual implementation
 */


function renderList(source, renderItem, cache, index) {
  var ret;
  var cached = cache && cache[index];

  if (isArray(source) || isString(source)) {
    ret = new Array(source.length);

    for (var i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);
    }
  } else if (typeof source === 'number') {
    ret = new Array(source);

    for (var _i2 = 0; _i2 < source; _i2++) {
      ret[_i2] = renderItem(_i2 + 1, _i2, undefined, cached && cached[_i2]);
    }
  } else if (isObject$1(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, function (item, i) {
        return renderItem(item, i, undefined, cached && cached[i]);
      });
    } else {
      var keys = Object.keys(source);
      ret = new Array(keys.length);

      for (var _i3 = 0, _l = keys.length; _i3 < _l; _i3++) {
        var key = keys[_i3];
        ret[_i3] = renderItem(source[key], key, _i3, cached && cached[_i3]);
      }
    }
  } else {
    ret = [];
  }

  if (cache) {
    cache[index] = ret;
  }

  return ret;
}
/**
 * Compiler runtime helper for creating dynamic slots object
 * @private
 */


function createSlots(slots, dynamicSlots) {
  for (var i = 0; i < dynamicSlots.length; i++) {
    var slot = dynamicSlots[i]; // array of dynamic slot generated by <template v-for="..." #[...]>

    if (isArray(slot)) {
      for (var j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      // conditional single slot generated by <template v-if="..." #foo>
      slots[slot.name] = slot.fn;
    }
  }

  return slots;
}
/**
 * Compiler runtime helper for rendering `<slot/>`
 * @private
 */


function renderSlot(slots, name) {
  var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var // this is not a user-facing function, so the fallback is always generated by
  // the compiler and guaranteed to be a function returning an array
  fallback = arguments.length > 3 ? arguments[3] : undefined;
  var noSlotted = arguments.length > 4 ? arguments[4] : undefined;

  if (currentRenderingInstance.isCE) {
    return createVNode('slot', name === 'default' ? null : {
      name
    }, fallback && fallback());
  }

  var slot = slots[name]; // a compiled slot disables block tracking by default to avoid manual
  // invocation interfering with template-based block tracking, but in
  // `renderSlot` we can be sure that it's template-based so we can force
  // enable it.

  if (slot && slot._c) {
    slot._d = false;
  }

  openBlock();
  var validSlotContent = slot && ensureValidVNode(slot(props));
  var rendered = createBlock(Fragment, {
    key: props.key || "_".concat(name)
  }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1
  /* STABLE */
  ? 64
  /* STABLE_FRAGMENT */
  : -2
  /* BAIL */
  );

  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + '-s'];
  }

  if (slot && slot._c) {
    slot._d = true;
  }

  return rendered;
}

function ensureValidVNode(vnodes) {
  return vnodes.some(function (child) {
    if (!isVNode(child)) return true;
    if (child.type === Comment$1) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
    return true;
  }) ? vnodes : null;
}
/**
 * For prefixing keys in v-on="obj" with "on"
 * @private
 */


function toHandlers(obj) {
  var ret = {};

  for (var key in obj) {
    ret[toHandlerKey(key)] = obj[key];
  }

  return ret;
}
/**
 * #2437 In Vue 3, functional components do not have a public instance proxy but
 * they exist in the internal parent chain. For code that relies on traversing
 * public $parent chains, skip functional ones and go to the parent instead.
 */


var getPublicInstance = function getPublicInstance(i) {
  if (!i) return null;
  if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};

var publicPropertiesMap = extend$2(Object.create(null), {
  $: function $(i) {
    return i;
  },
  $el: function $el(i) {
    return i.vnode.el;
  },
  $data: function $data(i) {
    return i.data;
  },
  $props: function $props(i) {
    return i.props;
  },
  $attrs: function $attrs(i) {
    return i.attrs;
  },
  $slots: function $slots(i) {
    return i.slots;
  },
  $refs: function $refs(i) {
    return i.refs;
  },
  $parent: function $parent(i) {
    return getPublicInstance(i.parent);
  },
  $root: function $root(i) {
    return getPublicInstance(i.root);
  },
  $emit: function $emit(i) {
    return i.emit;
  },
  $options: function $options(i) {
    return __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type;
  },
  $forceUpdate: function $forceUpdate(i) {
    return function () {
      return queueJob(i.update);
    };
  },
  $nextTick: function $nextTick(i) {
    return nextTick.bind(i.proxy);
  },
  $watch: function $watch(i) {
    return __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP;
  }
});
var PublicInstanceProxyHandlers = {
  get(_ref19, key) {
    var instance = _ref19._;
    var ctx = instance.ctx,
        setupState = instance.setupState,
        data = instance.data,
        props = instance.props,
        accessCache = instance.accessCache,
        type = instance.type,
        appContext = instance.appContext; // data / props / ctx
    // This getter gets called for every property access on the render context
    // during render and is a major hotspot. The most expensive part of this
    // is the multiple hasOwn() calls. It's much faster to do a simple property
    // access on a plain object, so we use an accessCache object (with null
    // prototype) to memoize what access type a key corresponds to.

    var normalizedProps;

    if (key[0] !== '$') {
      var n = accessCache[key];

      if (n !== undefined) {
        switch (n) {
          case 0
          /* SETUP */
          :
            return setupState[key];

          case 1
          /* DATA */
          :
            return data[key];

          case 3
          /* CONTEXT */
          :
            return ctx[key];

          case 2
          /* PROPS */
          :
            return props[key];
          // default: just fallthrough
        }
      } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
        accessCache[key] = 0
        /* SETUP */
        ;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 1
        /* DATA */
        ;
        return data[key];
      } else if ( // only cache other properties when instance has declared (thus stable)
      // props
      (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
        accessCache[key] = 2
        /* PROPS */
        ;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 3
        /* CONTEXT */
        ;
        return ctx[key];
      } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
        accessCache[key] = 4
        /* OTHER */
        ;
      }
    }

    var publicGetter = publicPropertiesMap[key];
    var cssModule, globalProperties; // public $xxx properties

    if (publicGetter) {
      if (key === '$attrs') {
        track(instance, "get"
        /* GET */
        , key);
      }

      return publicGetter(instance);
    } else if ( // css module (injected by vue-loader)
    (cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      // user may set custom properties to `this` that start with `$`
      accessCache[key] = 3
      /* CONTEXT */
      ;
      return ctx[key];
    } else if ( // global properties
    globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else ;
  },

  set(_ref20, key, value) {
    var instance = _ref20._;
    var data = instance.data,
        setupState = instance.setupState,
        ctx = instance.ctx;

    if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
      setupState[key] = value;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }

    if (key[0] === '$' && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }

    return true;
  },

  has(_ref21, key) {
    var _ref21$_ = _ref21._,
        data = _ref21$_.data,
        setupState = _ref21$_.setupState,
        accessCache = _ref21$_.accessCache,
        ctx = _ref21$_.ctx,
        appContext = _ref21$_.appContext,
        propsOptions = _ref21$_.propsOptions;
    var normalizedProps;
    return accessCache[key] !== undefined || data !== EMPTY_OBJ && hasOwn(data, key) || setupState !== EMPTY_OBJ && hasOwn(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  }

};
var RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/extend$2({}, PublicInstanceProxyHandlers, {
  get(target, key) {
    // fast path for unscopables when using `with` block
    if (key === Symbol.unscopables) {
      return;
    }

    return PublicInstanceProxyHandlers.get(target, key, target);
  },

  has(_, key) {
    var has = key[0] !== '_' && !isGloballyWhitelisted(key);
    return has;
  }

});
var emptyAppContext = createAppContext();
var uid$1 = 0;

function createComponentInstance(vnode, parent, suspense) {
  var type = vnode.type; // inherit parent app context - or - if root, adopt from root vnode

  var appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  var instance = {
    uid: uid$1++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    update: null,
    scope: new EffectScope(true
    /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resovled assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = {
      _: instance
    };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance); // apply custom element special handling

  if (vnode.ce) {
    vnode.ce(instance);
  }

  return instance;
}

var currentInstance = null;

var getCurrentInstance = function getCurrentInstance() {
  return currentInstance || currentRenderingInstance;
};

var setCurrentInstance = function setCurrentInstance(instance) {
  currentInstance = instance;
  instance.scope.on();
};

var unsetCurrentInstance = function unsetCurrentInstance() {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};

function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4
  /* STATEFUL_COMPONENT */
  ;
}

var isInSSRComponentSetup = false;

function setupComponent(instance) {
  var isSSR = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  isInSSRComponentSetup = isSSR;
  var _instance$vnode = instance.vnode,
      props = _instance$vnode.props,
      children = _instance$vnode.children;
  var isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  var setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : undefined;
  isInSSRComponentSetup = false;
  return setupResult;
}

function setupStatefulComponent(instance, isSSR) {
  var Component = instance.type; // 0. create render proxy property access cache

  instance.accessCache = Object.create(null); // 1. create public instance / render proxy
  // also mark it raw so it's never observed

  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers)); // 2. call setup()

  var setup = Component.setup;

  if (setup) {
    var setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    var setupResult = callWithErrorHandling(setup, instance, 0
    /* SETUP_FUNCTION */
    , [instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();

    if (isPromise$1(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);

      if (isSSR) {
        // return the promise so server-renderer can wait on it
        return setupResult.then(function (resolvedResult) {
          handleSetupResult(instance, resolvedResult);
        }).catch(function (e) {
          handleError(e, instance, 0
          /* SETUP_FUNCTION */
          );
        });
      } else {
        // async setup returned Promise.
        // bail here and wait for re-entry.
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult);
    }
  } else {
    finishComponentSetup(instance);
  }
}

function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$1(setupResult)) {
    // setup returned an inline render function
    {
      instance.render = setupResult;
    }
  } else if (isObject$1(setupResult)) {
    // setup returned bindings.
    // assuming a render function compiled from template is present.
    if (__VUE_PROD_DEVTOOLS__) {
      instance.devtoolsRawSetupState = setupResult;
    }

    instance.setupState = proxyRefs(setupResult);
  } else ;

  finishComponentSetup(instance);
}

var compile;
var installWithProxy;
/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */

function registerRuntimeCompiler(_compile) {
  compile = _compile;

  installWithProxy = function installWithProxy(i) {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
} // dev only


var isRuntimeOnly = function isRuntimeOnly() {
  return !compile;
};

function finishComponentSetup(instance, isSSR, skipOptions) {
  var Component = instance.type; // template / render function normalization

  if (!instance.render) {
    // could be set from setup()
    if (compile && !Component.render) {
      var template = Component.template;

      if (template) {
        var _instance$appContext$ = instance.appContext.config,
            isCustomElement = _instance$appContext$.isCustomElement,
            compilerOptions = _instance$appContext$.compilerOptions;
        var delimiters = Component.delimiters,
            componentCompilerOptions = Component.compilerOptions;
        var finalCompilerOptions = extend$2(extend$2({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);
      }
    }

    instance.render = Component.render || NOOP; // for runtime-compiled render functions using `with` blocks, the render
    // proxy used needs a different `has` handler which is more performant and
    // also only allows a whitelist of globals to fallthrough.

    if (installWithProxy) {
      installWithProxy(instance);
    }
  } // support for 2.x options


  if (__VUE_OPTIONS_API__ && !false) {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}

function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target, key) {
      track(instance, "get"
      /* GET */
      , '$attrs');
      return target[key];
    }

  });
}

function createSetupContext(instance) {
  var expose = function expose(exposed) {
    instance.exposed = exposed || {};
  };

  var attrs;
  {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },

      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}

function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      }

    }));
  }
}

var classifyRE = /(?:^|[-_])(\w)/g;

var classify = function classify(str) {
  return str.replace(classifyRE, function (c) {
    return c.toUpperCase();
  }).replace(/[-_]/g, '');
};

function getComponentName(Component) {
  return isFunction$1(Component) ? Component.displayName || Component.name : Component.name;
}
/* istanbul ignore next */


function formatComponentName(instance, Component) {
  var isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var name = getComponentName(Component);

  if (!name && Component.__file) {
    var match = Component.__file.match(/([^/\\]+)\.\w+$/);

    if (match) {
      name = match[1];
    }
  }

  if (!name && instance && instance.parent) {
    // try to infer the name based on reverse resolution
    var inferFromRegistry = function inferFromRegistry(registry) {
      for (var key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };

    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }

  return name ? classify(name) : isRoot ? "App" : "Anonymous";
}

function isClassComponent(value) {
  return isFunction$1(value) && '__vccOpts' in value;
}

var stack = [];

function warn(msg) {
  // avoid props formatting or warn handler tracking deps that might be mutated
  // during patch, leading to infinite recursion.
  pauseTracking();
  var instance = stack.length ? stack[stack.length - 1].component : null;
  var appWarnHandler = instance && instance.appContext.config.warnHandler;
  var trace = getComponentTrace();

  for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key13 = 1; _key13 < _len6; _key13++) {
    args[_key13 - 1] = arguments[_key13];
  }

  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11
    /* APP_WARN_HANDLER */
    , [msg + args.join(''), instance && instance.proxy, trace.map(function (_ref22) {
      var vnode = _ref22.vnode;
      return "at <".concat(formatComponentName(instance, vnode.type), ">");
    }).join('\n'), trace]);
  } else {
    var _console;

    var warnArgs = ["[Vue warn]: ".concat(msg)].concat(args);
    /* istanbul ignore if */

    if (trace.length && // avoid spamming console during tests
    !false) {
      warnArgs.push.apply(warnArgs, ["\n"].concat((0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(formatTrace(trace))));
    }

    (_console = console).warn.apply(_console, (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(warnArgs));
  }

  resetTracking();
}

function getComponentTrace() {
  var currentVNode = stack[stack.length - 1];

  if (!currentVNode) {
    return [];
  } // we can't just use the stack because it will be incomplete during updates
  // that did not start from the root. Re-construct the parent chain using
  // instance parent pointers.


  var normalizedStack = [];

  while (currentVNode) {
    var last = normalizedStack[0];

    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }

    var parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }

  return normalizedStack;
}
/* istanbul ignore next */


function formatTrace(trace) {
  var logs = [];
  trace.forEach(function (entry, i) {
    logs.push.apply(logs, (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(i === 0 ? [] : ["\n"]).concat((0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(formatTraceEntry(entry))));
  });
  return logs;
}

function formatTraceEntry(_ref23) {
  var vnode = _ref23.vnode,
      recurseCount = _ref23.recurseCount;
  var postfix = recurseCount > 0 ? "... (".concat(recurseCount, " recursive calls)") : "";
  var isRoot = vnode.component ? vnode.component.parent == null : false;
  var open = " at <".concat(formatComponentName(vnode.component, vnode.type, isRoot));
  var close = ">" + postfix;
  return vnode.props ? [open].concat((0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(formatProps(vnode.props)), [close]) : [open + close];
}
/* istanbul ignore next */


function formatProps(props) {
  var res = [];
  var keys = Object.keys(props);
  keys.slice(0, 3).forEach(function (key) {
    res.push.apply(res, (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(formatProp(key, props[key])));
  });

  if (keys.length > 3) {
    res.push(" ...");
  }

  return res;
}
/* istanbul ignore next */


function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : ["".concat(key, "=").concat(value)];
  } else if (typeof value === 'number' || typeof value === 'boolean' || value == null) {
    return raw ? value : ["".concat(key, "=").concat(value)];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : ["".concat(key, "=Ref<"), value, ">"];
  } else if (isFunction$1(value)) {
    return ["".concat(key, "=fn").concat(value.name ? "<".concat(value.name, ">") : "")];
  } else {
    value = toRaw(value);
    return raw ? value : ["".concat(key, "="), value];
  }
}

function callWithErrorHandling(fn, instance, type, args) {
  var res;

  try {
    res = args ? fn.apply(void 0, (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(args)) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }

  return res;
}

function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$1(fn)) {
    var res = callWithErrorHandling(fn, instance, type, args);

    if (res && isPromise$1(res)) {
      res.catch(function (err) {
        handleError(err, instance, type);
      });
    }

    return res;
  }

  var values = [];

  for (var i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }

  return values;
}

function handleError(err, instance, type) {
  var throwInDev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var contextVNode = instance ? instance.vnode : null;

  if (instance) {
    var cur = instance.parent; // the exposed instance is the render proxy to keep it consistent with 2.x

    var exposedInstance = instance.proxy; // in production the hook receives only the error code

    var errorInfo = type;

    while (cur) {
      var errorCapturedHooks = cur.ec;

      if (errorCapturedHooks) {
        for (var i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }

      cur = cur.parent;
    } // app-level handling


    var appErrorHandler = instance.appContext.config.errorHandler;

    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10
      /* APP_ERROR_HANDLER */
      , [err, exposedInstance, errorInfo]);
      return;
    }
  }

  logError(err, type, contextVNode, throwInDev);
}

function logError(err, type, contextVNode) {
  var throwInDev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  {
    // recover in prod to reduce the impact on end-user
    console.error(err);
  }
}

var isFlushing = false;
var isFlushPending = false;
var queue = [];
var flushIndex = 0;
var pendingPreFlushCbs = [];
var activePreFlushCbs = null;
var preFlushIndex = 0;
var pendingPostFlushCbs = [];
var activePostFlushCbs = null;
var postFlushIndex = 0;
var resolvedPromise = Promise.resolve();
var currentFlushPromise = null;
var currentPreFlushParentJob = null;
var RECURSION_LIMIT = 100;

function nextTick(fn) {
  var p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
} // #2768
// Use binary-search to find a suitable position in the queue,
// so that the queue maintains the increasing order of job's id,
// which can prevent the job from being skipped and also can avoid repeated patching.


function findInsertionIndex(id) {
  // the start index should be `flushIndex + 1`
  var start = flushIndex + 1;
  var end = queue.length;

  while (start < end) {
    var middle = start + end >>> 1;
    var middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }

  return start;
}

function queueJob(job) {
  // the dedupe search uses the startIndex argument of Array.includes()
  // by default the search index includes the current job that is being run
  // so it cannot recursively trigger itself again.
  // if the job is a watch() callback, the search will start with a +1 index to
  // allow it recursively trigger itself - it is the user's responsibility to
  // ensure it doesn't end up in an infinite loop.
  if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }

    queueFlush();
  }
}

function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}

function invalidateJob(job) {
  var i = queue.indexOf(job);

  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}

function queueCb(cb, activeQueue, pendingQueue, index) {
  if (!isArray(cb)) {
    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
      pendingQueue.push(cb);
    }
  } else {
    // if cb is an array, it is a component lifecycle hook which can only be
    // triggered by a job, which is already deduped in the main queue, so
    // we can skip duplicate check here to improve perf
    pendingQueue.push.apply(pendingQueue, (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(cb));
  }

  queueFlush();
}

function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}

function queuePostFlushCb(cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}

function flushPreFlushCbs(seen) {
  var parentJob = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(new Set(pendingPreFlushCbs));
    pendingPreFlushCbs.length = 0;

    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
      activePreFlushCbs[preFlushIndex]();
    }

    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null; // recursively flush until it drains

    flushPreFlushCbs(seen, parentJob);
  }
}

function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    var deduped = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(new Set(pendingPostFlushCbs));

    pendingPostFlushCbs.length = 0; // #1947 already has active queue, nested flushPostFlushCbs call

    if (activePostFlushCbs) {
      var _activePostFlushCbs;

      (_activePostFlushCbs = activePostFlushCbs).push.apply(_activePostFlushCbs, (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(deduped));

      return;
    }

    activePostFlushCbs = deduped;
    activePostFlushCbs.sort(function (a, b) {
      return getId(a) - getId(b);
    });

    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }

    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}

var getId = function getId(job) {
  return job.id == null ? Infinity : job.id;
};

function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  flushPreFlushCbs(seen); // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child so its render effect will have smaller
  //    priority number)
  // 2. If a component is unmounted during a parent component's update,
  //    its update can be skipped.

  queue.sort(function (a, b) {
    return getId(a) - getId(b);
  });

  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      var job = queue[flushIndex];

      if (job && job.active !== false) {
        if (false) {} // console.log(`running:`, job.id)

        callWithErrorHandling(job, null, 14
        /* SCHEDULER */
        );
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null; // some postFlushCb queued jobs!
    // keep flushing until it drains.

    if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}

function checkRecursiveUpdates(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    var count = seen.get(fn);

    if (count > RECURSION_LIMIT) {
      var instance = fn.ownerInstance;
      var componentName = instance && getComponentName(instance.type);
      warn("Maximum recursive updates exceeded".concat(componentName ? " in component <".concat(componentName, ">") : "", ". ") + "This means you have a reactive effect that is mutating its own " + "dependencies and thus recursively triggering itself. Possible sources " + "include component template, render function, updated hook or " + "watcher source function.");
      return true;
    } else {
      seen.set(fn, count + 1);
    }
  }
} // Simple effect.


function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}

function watchPostEffect(effect, options) {
  return doWatch(effect, null, {
    flush: 'post'
  });
}

function watchSyncEffect(effect, options) {
  return doWatch(effect, null, {
    flush: 'sync'
  });
} // initial value for watchers to trigger on undefined initial values


var INITIAL_WATCHER_VALUE = {}; // implementation

function watch(source, cb, options) {
  return doWatch(source, cb, options);
}

function doWatch(source, cb) {
  var _ref24 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJ,
      immediate = _ref24.immediate,
      deep = _ref24.deep,
      flush = _ref24.flush,
      onTrack = _ref24.onTrack,
      onTrigger = _ref24.onTrigger;

  var instance = currentInstance;
  var getter;
  var forceTrigger = false;
  var isMultiSource = false;

  if (isRef(source)) {
    getter = function getter() {
      return source.value;
    };

    forceTrigger = !!source._shallow;
  } else if (isReactive(source)) {
    getter = function getter() {
      return source;
    };

    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some(isReactive);

    getter = function getter() {
      return source.map(function (s) {
        if (isRef(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return traverse(s);
        } else if (isFunction$1(s)) {
          return callWithErrorHandling(s, instance, 2
          /* WATCH_GETTER */
          );
        } else ;
      });
    };
  } else if (isFunction$1(source)) {
    if (cb) {
      // getter with cb
      getter = function getter() {
        return callWithErrorHandling(source, instance, 2
        /* WATCH_GETTER */
        );
      };
    } else {
      // no cb -> simple effect
      getter = function getter() {
        if (instance && instance.isUnmounted) {
          return;
        }

        if (cleanup) {
          cleanup();
        }

        return callWithAsyncErrorHandling(source, instance, 3
        /* WATCH_CALLBACK */
        , [onInvalidate]);
      };
    }
  } else {
    getter = NOOP;
  }

  if (cb && deep) {
    var baseGetter = getter;

    getter = function getter() {
      return traverse(baseGetter());
    };
  }

  var cleanup;

  var onInvalidate = function onInvalidate(fn) {
    cleanup = effect.onStop = function () {
      callWithErrorHandling(fn, instance, 4
      /* WATCH_CLEANUP */
      );
    };
  };

  var oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;

  var job = function job() {
    if (!effect.active) {
      return;
    }

    if (cb) {
      // watch(source, cb)
      var newValue = effect.run();

      if (deep || forceTrigger || (isMultiSource ? newValue.some(function (v, i) {
        return hasChanged(v, oldValue[i]);
      }) : hasChanged(newValue, oldValue)) || false) {
        // cleanup before running cb again
        if (cleanup) {
          cleanup();
        }

        callWithAsyncErrorHandling(cb, instance, 3
        /* WATCH_CALLBACK */
        , [newValue, // pass undefined as the old value when it's changed for the first time
        oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue, onInvalidate]);
        oldValue = newValue;
      }
    } else {
      // watchEffect
      effect.run();
    }
  }; // important: mark the job as a watcher callback so that scheduler knows
  // it is allowed to self-trigger (#1727)


  job.allowRecurse = !!cb;
  var scheduler;

  if (flush === 'sync') {
    scheduler = job; // the scheduler function gets called directly
  } else if (flush === 'post') {
    scheduler = function scheduler() {
      return queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else {
    // default: 'pre'
    scheduler = function scheduler() {
      if (!instance || instance.isMounted) {
        queuePreFlushCb(job);
      } else {
        // with 'pre' option, the first call must happen before
        // the component is mounted so it is called synchronously.
        job();
      }
    };
  }

  var effect = new ReactiveEffect(getter, scheduler); // initial run

  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === 'post') {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }

  return function () {
    effect.stop();

    if (instance && instance.scope) {
      remove$1(instance.scope.effects, effect);
    }
  };
} // this.$watch


function instanceWatch(source, value, options) {
  var publicThis = this.proxy;
  var getter = isString(source) ? source.includes('.') ? createPathGetter(publicThis, source) : function () {
    return publicThis[source];
  } : source.bind(publicThis, publicThis);
  var cb;

  if (isFunction$1(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }

  var cur = currentInstance;
  setCurrentInstance(this);
  var res = doWatch(getter, cb.bind(publicThis), options);

  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }

  return res;
}

function createPathGetter(ctx, path) {
  var segments = path.split('.');
  return function () {
    var cur = ctx;

    for (var i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }

    return cur;
  };
}

function traverse(value) {
  var seen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();

  if (!isObject$1(value) || value["__v_skip"
  /* SKIP */
  ]) {
    return value;
  }

  seen = seen || new Set();

  if (seen.has(value)) {
    return value;
  }

  seen.add(value);

  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray(value)) {
    for (var i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach(function (v) {
      traverse(v, seen);
    });
  } else if (isPlainObject(value)) {
    for (var key in value) {
      traverse(value[key], seen);
    }
  }

  return value;
}

var isFunction = function isFunction(val) {
  return typeof val === 'function';
};

var isObject = function isObject(val) {
  return val !== null && typeof val === 'object';
};

var isPromise = function isPromise(val) {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
}; // implementation


function defineProps() {
  return null;
} // implementation


function defineEmits() {
  return null;
}
/**
 * Vue `<script setup>` compiler macro for declaring a component's exposed
 * instance properties when it is accessed by a parent component via template
 * refs.
 *
 * `<script setup>` components are closed by default - i.e. varaibles inside
 * the `<script setup>` scope is not exposed to parent unless explicitly exposed
 * via `defineExpose`.
 *
 * This is only usable inside `<script setup>`, is compiled away in the
 * output and should **not** be actually called at runtime.
 */


function defineExpose(exposed) {}
/**
 * Vue `<script setup>` compiler macro for providing props default values when
 * using type-based `defineProps` declaration.
 *
 * Example usage:
 * ```ts
 * withDefaults(defineProps<{
 *   size?: number
 *   labels?: string[]
 * }>(), {
 *   size: 3,
 *   labels: () => ['default label']
 * })
 * ```
 *
 * This is only usable inside `<script setup>`, is compiled away in the output
 * and should **not** be actually called at runtime.
 */


function withDefaults(props, defaults) {
  return null;
}

function useSlots() {
  return getContext().slots;
}

function useAttrs() {
  return getContext().attrs;
}

function getContext() {
  var i = getCurrentInstance();
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
/**
 * Runtime helper for merging default declarations. Imported by compiled code
 * only.
 * @internal
 */


function mergeDefaults( // the base props is compiler-generated and guaranteed to be in this shape.
props, defaults) {
  for (var key in defaults) {
    var val = props[key];

    if (val) {
      val.default = defaults[key];
    } else if (val === null) {
      props[key] = {
        default: defaults[key]
      };
    } else ;
  }

  return props;
}
/**
 * `<script setup>` helper for persisting the current instance context over
 * async/await flows.
 *
 * `@vue/compiler-sfc` converts the following:
 *
 * ```ts
 * const x = await foo()
 * ```
 *
 * into:
 *
 * ```ts
 * let __temp, __restore
 * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)
 * ```
 * @internal
 */


function withAsyncContext(getAwaitable) {
  var ctx = getCurrentInstance();
  var awaitable = getAwaitable();
  unsetCurrentInstance();

  if (isPromise(awaitable)) {
    awaitable = awaitable.catch(function (e) {
      setCurrentInstance(ctx);
      throw e;
    });
  }

  return [awaitable, function () {
    return setCurrentInstance(ctx);
  }];
} // Actual implementation


function h(type, propsOrChildren, children) {
  var l = arguments.length;

  if (l === 2) {
    if (isObject$1(propsOrChildren) && !isArray(propsOrChildren)) {
      // single vnode without props
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      } // props without children


      return createVNode(type, propsOrChildren);
    } else {
      // omit props
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }

    return createVNode(type, propsOrChildren, children);
  }
}

var ssrContextKey = Symbol("");

var useSSRContext = function useSSRContext() {
  {
    var ctx = inject(ssrContextKey);

    if (!ctx) {
      warn("Server rendering context not provided. Make sure to only call " + "useSSRContext() conditionally in the server build.");
    }

    return ctx;
  }
};

function initCustomFormatter() {
  /* eslint-disable no-restricted-globals */
  {
    return;
  }
}

function withMemo(memo, render, cache, index) {
  var cached = cache[index];

  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }

  var ret = render(); // shallow clone

  ret.memo = memo.slice();
  return cache[index] = ret;
}

function isMemoSame(cached, memo) {
  var prev = cached.memo;

  if (prev.length != memo.length) {
    return false;
  }

  for (var i = 0; i < prev.length; i++) {
    if (prev[i] !== memo[i]) {
      return false;
    }
  } // make sure to let parent block track it when returning cached


  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }

  return true;
} // Core API ------------------------------------------------------------------


var version = "3.2.11";
var _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode,
  normalizeVNode
};
/**
 * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
 * @internal
 */

var ssrUtils = _ssrUtils;
/**
 * @internal only exposed in compat builds
 */

var resolveFilter = null;
/**
 * @internal only exposed in compat builds.
 */

var compatUtils = null;
var tenonUtils_cjs = {};
Object.defineProperty(tenonUtils_cjs, '__esModule', {
  value: true
});
var listDelimiterRE = /;(?![^(]*\))/g;
var propertyDelimiterRE = /:(.+)/;

function parseStringStyle(cssText) {
  var ret = {};
  cssText.split(listDelimiterRE).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}

function transformAttr(style) {
  var tempStyle = {};
  Object.keys(style).forEach(function (key) {
    var humpKey = transformHumpKey(key);
    tempStyle[humpKey] = style[key];
  });
  return tempStyle;
}

function transformHumpKey(key) {
  var humpKey = key.replace(/-(\w)/g, function ($0, $1) {
    return $1.toUpperCase();
  });
  return humpKey;
}

var COLOR_MAP = {
  aliceblue: '#f0f8ff',
  antiquewhite: '#faebd7',
  aqua: '#00ffff',
  aquamarine: '#7fffd4',
  azure: '#f0ffff',
  beige: '#f5f5dc',
  bisque: '#ffe4c4',
  black: '#000000',
  blanchedalmond: '#ffebcd',
  blue: '#0000ff',
  blueviolet: '#8a2be2',
  brown: '#a52a2a',
  burlywood: '#deb887',
  cadetblue: '#5f9ea0',
  chartreuse: '#7fff00',
  chocolate: '#d2691e',
  coral: '#ff7f50',
  cornflowerblue: '#6495ed',
  cornsilk: '#fff8dc',
  crimson: '#dc143c',
  cyan: '#00ffff',
  darkblue: '#00008b',
  darkcyan: '#008b8b',
  darkgoldenrod: '#b8860b',
  darkgray: '#a9a9a9',
  darkgrey: '#a9a9a9',
  darkgreen: '#006400',
  darkkhaki: '#bdb76b',
  darkmagenta: '#8b008b',
  darkolivegreen: '#556b2f',
  darkorange: '#ff8c00',
  darkorchid: '#9932cc',
  darkred: '#8b0000',
  darksalmon: '#e9967a',
  darkseagreen: '#8fbc8f',
  darkslateblue: '#483d8b',
  darkslategray: '#2f4f4f',
  darkslategrey: '#2f4f4f',
  darkturquoise: '#00ced1',
  darkviolet: '#9400d3',
  deeppink: '#ff1493',
  deepskyblue: '#00bfff',
  dimgray: '#696969',
  dimgrey: '#696969',
  dodgerblue: '#1e90ff',
  firebrick: '#b22222',
  floralwhite: '#fffaf0',
  forestgreen: '#228b22',
  fuchsia: '#ff00ff',
  gainsboro: '#dcdcdc',
  ghostwhite: '#f8f8ff',
  gold: '#ffd700',
  goldenrod: '#daa520',
  gray: '#808080',
  grey: '#808080',
  green: '#008000',
  greenyellow: '#adff2f',
  honeydew: '#f0fff0',
  hotpink: '#ff69b4',
  indianred: '#cd5c5c',
  indigo: '#4b0082',
  ivory: '#fffff0',
  khaki: '#f0e68c',
  lavender: '#e6e6fa',
  lavenderblush: '#fff0f5',
  lawngreen: '#7cfc00',
  lemonchiffon: '#fffacd',
  lightblue: '#add8e6',
  lightcoral: '#f08080',
  lightcyan: '#e0ffff',
  lightgoldenrodyellow: '#fafad2',
  lightgray: '#d3d3d3',
  lightgrey: '#d3d3d3',
  lightgreen: '#90ee90',
  lightpink: '#ffb6c1',
  lightsalmon: '#ffa07a',
  lightseagreen: '#20b2aa',
  lightskyblue: '#87cefa',
  lightslateblue: '#8470ff',
  lightslategray: '#778899',
  lightslategrey: '#778899',
  lightsteelblue: '#b0c4de',
  lightyellow: '#ffffe0',
  lime: '#00ff00',
  limegreen: '#32cd32',
  linen: '#faf0e6',
  magenta: '#ff00ff',
  maroon: '#800000',
  mediumaquamarine: '#66cdaa',
  mediumblue: '#0000cd',
  mediumorchid: '#ba55d3',
  mediumpurple: '#9370db',
  mediumseagreen: '#3cb371',
  mediumslateblue: '#7b68ee',
  mediumspringgreen: '#00fa9a',
  mediumturquoise: '#48d1cc',
  mediumvioletred: '#c71585',
  midnightblue: '#191970',
  mintcream: '#f5fffa',
  mistyrose: '#ffe4e1',
  moccasin: '#ffe4b5',
  navajowhite: '#ffdead',
  navy: '#000080',
  oldlace: '#fdf5e6',
  olive: '#808000',
  olivedrab: '#6b8e23',
  orange: '#ffa500',
  orangered: '#ff4500',
  orchid: '#da70d6',
  palegoldenrod: '#eee8aa',
  palegreen: '#98fb98',
  paleturquoise: '#afeeee',
  palevioletred: '#db7093',
  papayawhip: '#ffefd5',
  peachpuff: '#ffdab9',
  peru: '#cd853f',
  pink: '#ffc0cb',
  plum: '#dda0dd',
  powderblue: '#b0e0e6',
  purple: '#800080',
  rebeccapurple: '#663399',
  red: '#ff0000',
  rosybrown: '#bc8f8f',
  royalblue: '#4169e1',
  saddlebrown: '#8b4513',
  salmon: '#fa8072',
  sandybrown: '#f4a460',
  seagreen: '#2e8b57',
  seashell: '#fff5ee',
  sienna: '#a0522d',
  silver: '#c0c0c0',
  skyblue: '#87ceeb',
  slateblue: '#6a5acd',
  slategray: '#708090',
  slategrey: '#708090',
  snow: '#fffafa',
  springgreen: '#00ff7f',
  steelblue: '#4682b4',
  tan: '#d2b48c',
  teal: '#008080',
  thistle: '#d8bfd8',
  tomato: '#ff6347',
  transparent: '#000000',
  turquoise: '#40e0d0',
  violet: '#ee82ee',
  violetred: '#d02090',
  wheat: '#f5deb3',
  white: '#ffffff',
  whitesmoke: '#f5f5f5',
  yellow: '#ffff00',
  yellowgreen: '#9acd32'
};

function getColor(color) {
  return COLOR_MAP[color] || color;
}

function getEnvironmentInfo() {
  return {};
}

function traverseArr(arr, callback) {
  for (var i = 0; i < arr.length; i++) {
    var item = arr[i];
    var result = callback(item, i);

    if (!result) {
      break;
    }
  }
}

function makeMap(str) {
  var expectedLowerCase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectedLowerCase ? function (val) {
    return !!map[val.toLowerCase()];
  } : function (val) {
    return !!map[val];
  };
}

function makeMapByArr(list) {
  var expectedLowerCase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var map = Object.create(null);

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectedLowerCase ? function (val) {
    return !!map[val.toLowerCase()];
  } : function (val) {
    return !!map[val];
  };
}

var camelizeRE = /-(\w)/g;

function camelize(str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
}

var unitAttrs = ['font-size', 'placeholder-font-size', 'flex-basis', 'width', 'max-width', 'min-width', 'height', 'max-height', 'min-height', 'padding', 'padding-left', 'padding-right', 'padding-bottom', 'padding-top', 'margin', 'margin-left', 'margin-right', 'margin-bottom', 'margin-top', 'left', 'right', 'top', 'bottom', 'border-width', 'border-left-width', 'border-right-width', 'border-top-width', 'border-bottom-width', 'border-radius', 'border-top-left-radius', 'border-top-right-radius', 'border-bottom-left-radius', 'border-bottom-right-radius'];
var isNeedUnitTrasform = makeMapByArr(unitAttrs);
var isRemUnit = /rem$/;
var isVUnit = /v(h|w|min|max)$/;
var isCpxUnit = /cpx$/;

function transformUnit(style) {
  Object.keys(style).forEach(function (key) {
    if (isNeedUnitTrasform(key)) {
      var value = transformUnitValue(style[key]);
      style[key] = value;
    }
  });
  return style;
}

function transformUnitValue(value) {
  if (isRemUnit.test(value)) {
    return transfromRem(value);
  } else if (isVUnit.test(value)) {
    return transformVUnit(value);
  } else if (isCpxUnit.test(value)) {
    return transfromCpx(value);
  }

  return value;
}

function hexify(color) {
  var values = color.replace(/rgba?\(/, '').replace(/\)/, '').replace(/[\s+]/g, '').split(',');
  var a = parseFloat(values[3] || "1"),
      r = parseInt(values[0]),
      g = parseInt(values[1]),
      b = parseInt(values[2]),
      a = Math.floor(a * 255);
  return "#" + ("0" + r.toString(16)).slice(-2) + ("0" + g.toString(16)).slice(-2) + ("0" + b.toString(16)).slice(-2) + ("0" + a.toString(16)).slice(-2);
}

function transfromRem(value) {
  var num = (Number(value.replace(/rem/, '')) * 100).toFixed(2);
  return num + 'hm';
}

function transfromCpx(value) {
  var num = value.replace(/cpx/, 'hm');
  return num;
}

function transformVUnit(value) {
  return value;
}

var colorAttrs = "color,background-color,border-color,border-top-color,border-left-color,border-right-color,border-bottom-color,placeholder-color,cursor-color";
var isColorAttr = makeMap(colorAttrs);
var rgbaReg$1 = /rgba?/;

function transformColor(style) {
  Object.keys(style).forEach(function (key) {
    if (isColorAttr(key)) {
      var value = style[key];

      if (isRgba(value)) {
        style[key] = hexify(value);
      } else {
        style[key] = transformColorStyle(value);
      }
    }
  });
  return style;
}

function isRgba(color) {
  return rgbaReg$1.test(color);
}

function transformColorStyle(value) {
  if (/^#/.test(value) && value.length === 4) {
    return normalizeColor(value);
  } else {
    return getColor(value);
  }
}

function normalizeColor(value) {
  return value.replace(/(\w)/ig, function (match) {
    return "".concat(match).concat(match);
  });
}

var commonAttrs = ["margin", "padding"];
var borderAttrs = ["border-radius"];
var attrs$2 = commonAttrs.concat(borderAttrs);
var isDirectAttr = makeMapByArr(commonAttrs);
var isBorderDirectAttr = makeMapByArr(borderAttrs);

function transformBreakToken(style) {
  var tempStyle = Object.assign({}, style);
  attrs$2.forEach(function (attr) {
    if (!style[attr]) {
      return;
    }

    if (isDirectAttr(attr)) {
      delete tempStyle[attr];
      tempStyle = extend$1(breakDirectionAttr({
        attr: attr,
        value: style[attr]
      }), tempStyle);
    } else if (isBorderDirectAttr(attr)) {
      delete tempStyle[attr];
      tempStyle = extend$1(breakBorderRadiusAttr({
        attr: attr,
        value: style[attr]
      }, /\s+/), tempStyle);
    }
  });
  return tempStyle;
}

function breakDirectionAttr(_ref25) {
  var attr = _ref25.attr,
      value = _ref25.value;
  var splitReg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /\s/;
  var vals = value.split(splitReg).map(function (item) {
    return item.trim();
  });
  var top, right, bottom, left;

  switch (vals.length) {
    case 1:
      top = vals[0];
      right = vals[0];
      bottom = vals[0];
      left = vals[0];
      break;

    case 2:
      top = vals[0];
      right = vals[1];
      bottom = vals[0];
      left = vals[1];
      break;

    case 3:
      top = vals[0];
      right = vals[1];
      bottom = vals[2];
      left = vals[1];
      break;

    case 4:
      top = vals[0];
      right = vals[1];
      bottom = vals[2];
      left = vals[3];
      break;

    default:
      top = 0;
      bottom = 0;
      left = 0;
      right = 0;
      break;
  }

  return {
    [attr + '-top']: top,
    [attr + '-right']: right,
    [attr + '-bottom']: bottom,
    [attr + '-left']: left
  };
}

function breakBorderRadiusAttr(_ref26) {
  var attr = _ref26.attr,
      value = _ref26.value;
  var splitReg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /\s+/;
  var vals = value.split(splitReg).map(function (item) {
    return item.trim();
  });
  var topLeft, topRight, bottomLeft, bottomRight;

  if (vals.length === 1) {
    return {
      'border-radius': vals[0]
    };
  }

  switch (vals.length) {
    case 1:
      topLeft = vals[0];
      topRight = vals[0];
      bottomRight = vals[0];
      bottomLeft = vals[0];
      break;

    case 2:
      topLeft = vals[0];
      topRight = vals[1];
      bottomRight = vals[0];
      bottomLeft = vals[1];
      break;

    case 3:
      topLeft = vals[0];
      topRight = vals[1];
      bottomRight = vals[2];
      bottomLeft = vals[1];
      break;

    case 4:
      topLeft = vals[0];
      topRight = vals[1];
      bottomRight = vals[2];
      bottomLeft = vals[3];
      break;

    default:
      topLeft = 0;
      topRight = 0;
      bottomRight = 0;
      bottomLeft = 0;
      break;
  }

  return {
    ['border-top-left-radius']: topLeft,
    ['border-top-right-radius']: topRight,
    ['border-bottom-right-radius']: bottomRight,
    ['border-bottom-left-radius']: bottomLeft
  };
}

var rgbaReg = /rgba?\([\d\.\s,]+\)/;
var Keyword;

(function (Keyword) {
  Keyword["AUTO"] = "auto";
})(Keyword || (Keyword = {}));

var BorderStyle;

(function (BorderStyle) {
  BorderStyle["NONE"] = "none";
  BorderStyle["SOLID"] = "solid";
  BorderStyle["DASHED"] = "dashed";
  BorderStyle["DOTTED"] = "dotted";
})(BorderStyle || (BorderStyle = {}));

function isNumber(num) {
  return !isNaN(num);
}

function isLength(length) {
  var lengthReg = /^[\d\.]+(%|rem|hm|cpx|px|vw|vh)?$/;
  return lengthReg.test(length);
}

function isBorderStyle(value) {
  return [BorderStyle.NONE, BorderStyle.DASHED, BorderStyle.DOTTED, BorderStyle.SOLID].findIndex(function (borderStyle) {
    return value === borderStyle;
  }) !== -1;
}

function hasRgbaColor(value) {
  return rgbaReg.test(value);
}

function getRgbaColor(value) {
  if (!value) {
    return null;
  }

  var matches = value.match(rgbaReg);

  if (matches && matches.length > 0) {
    var matchStr = matches[0];
    return matchStr;
  } else {
    return null;
  }
}

var attrs$1 = ["border", "border-left", "border-right", "border-top", "border-bottom"];

function transformBorder(style) {
  var tempStyle = Object.assign({}, style);
  attrs$1.forEach(function (attr) {
    if (!style[attr]) {
      return;
    } else {
      delete tempStyle[attr];
      tempStyle = extend$1(transformBorderStyle(attr, style[attr]), tempStyle);
    }
  });
  return tempStyle;
}

function transformBorderStyle(attr, borderValue) {
  var tempStyle = {};

  if (!hasRgbaColor(borderValue)) {
    var values = borderValue.trim().split(/\s+/);
    tempStyle = traverseBorderValue(values, attr);
  } else {
    var rgbaColor = getRgbaColor(borderValue);

    if (rgbaColor) {
      borderValue = borderValue.split(rgbaColor).join("");

      var _values = borderValue.trim().split(/\s+/);

      tempStyle = traverseBorderValue(_values, attr);
      tempStyle[attr + '-color'] = rgbaColor;
    } else {
      var _values2 = borderValue.trim().split(/\s+/);

      tempStyle = traverseBorderValue(_values2, attr);
    }
  }

  return tempStyle;
}

function traverseBorderValue(values, attr) {
  var tempStyle = {};
  values.forEach(function (value) {
    if (isBorderStyle(value)) {
      tempStyle[attr + "-style"] = value;
    } else if (isLength(value)) {
      tempStyle[attr + "-width"] = value;
    } else {
      tempStyle[attr + "-color"] = value;
    }
  });
  return tempStyle;
}

var attrs = ["box-shadow"];

function transformShadow(style) {
  traverseArr(attrs, function (item, index) {
    if (style[item]) {
      style["shadow"] = getShadowValue(style[item]);
      delete style[item];
    }
  });
  return style;
}

function getShadowValue(value) {
  var values = value;

  if (!values) {
    return '';
  }

  var shadowItems = transformValue$1(value);

  if (shadowItems.length > 4) {
    values = [shadowItems[0], shadowItems[1], shadowItems[2], shadowItems[4]].join(' ');
  } else {
    values = shadowItems.join(' ');
  }

  return values;
}

function transformValue$1(value) {
  var rgbReg = /rgb?/,
      rgbaReg = /rgba?/;
  var values = value,
      shadowItems = new Array();

  if (rgbReg.test(values)) {
    shadowItems = [].concat((0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(values.slice(0, values.indexOf('rgb')).trim().split(/\s/)), [values.slice(values.indexOf('rgb'))]);
  } else {
    shadowItems = values.split(/\s/);
  }

  for (var i = 0; i < shadowItems.length; i++) {
    if (rgbaReg.test(shadowItems[i])) {
      shadowItems[i] = hexify(shadowItems[i]);
    } else {
      shadowItems[i] = transformUnitValue(shadowItems[i]);
    }
  }

  return shadowItems;
}

var borderRadius$1 = "border-radius,border-top-left-radius,border-top-right-radius,border-bottom-left-radius,border-bottom-right-radius";
var isBorderRadius$1 = makeMap(borderRadius$1);

function transformAdapter(style) {
  var tempStyle = Object.assign({}, style);
  tempStyle = hackForBorderRadius$1(tempStyle);
  tempStyle = hackForDefaultFlex(tempStyle);
  tempStyle = hackForWhiteSpace(tempStyle);
  return tempStyle;
}

function hackForWhiteSpace(style) {
  if (style['white-space'] === 'nowrap') {
    style['textLineClamp'] = "1";
  }

  return style;
}

function hackForDefaultFlex(style) {
  if (style['display'] === 'flex' && !style['flex-direction']) {
    style['flex-direction'] = 'row';
  }

  return style;
}

function hackForBorderRadius$1(style) {
  if (hasSpecialAttr$1(style, isBorderRadius$1)) {
    transformBorderRadius(style);
  }

  return style;
}

function hasSpecialAttr$1(obj, func) {
  return Object.keys(obj).some(function (key) {
    return func(key);
  });
}

function transformBorderRadius(style) {
  if (!style.width) {
    return;
  }

  var _style$width$split = style.width.split(/([\d\.]+)/),
      _style$width$split2 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_6__["default"])(_style$width$split, 3),
      width = _style$width$split2[1],
      unit = _style$width$split2[2];

  if (unit === '%') {
    return;
  }

  Object.keys(style).forEach(function (key) {
    if (isBorderRadius$1(key)) {
      style[key] = getBorderRadius(style[key], {
        width,
        unit
      });
    }
  });
}

function getBorderRadius(value, _ref27) {
  var width = _ref27.width,
      unit = _ref27.unit;

  var _value$split = value.split(/([\d\.]+)/),
      _value$split2 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_6__["default"])(_value$split, 3),
      bPercent = _value$split2[1],
      bUnit = _value$split2[2];

  if (bUnit === '%') {
    return (width * parseFloat(bPercent) / 100).toFixed(2) + unit;
  }

  return value;
}

var CLIP_LIST = ['border-box', 'padding-box', 'content-box', 'text'];
var REPEAT_LIST = ['repeat-x', 'repeat-y', 'repeat', 'space', 'round', 'no-repeat'];
var SIZE_LIST = ['contain', 'cover'];
var isUrl = /url\((?:"|')/;
var isImageBase64Reg = /url\(data:/;
var isLinearGradient = /linear\-gradient/;
var imageUrlReg = /url\((?:"|')?([\w\W]+)(?:"|')\)/;
var imageBase64Reg = /url\(([\w\W]+)\)/;
var linearReg = /linear\-gradient\(([\w\W]+)\)/;

function transformBackground(style) {
  var tempStyle = Object.assign({}, style);

  if (tempStyle['background-image']) {
    var value = tempStyle['background-image'];

    if (isLinearGradient.test(value.trim())) {
      delete tempStyle['background-image'];

      var _matches = value.match(linearReg);

      var linearValue = _matches && _matches[1] || '';
      tempStyle['background-color'] = 'linear-gradient(' + transformLinear(linearValue) + ')';
    } else {
      tempStyle['background-image'] = transformBackgroundImage(value);
    }
  }

  if (tempStyle['background']) {
    var _value = tempStyle['background'];
    delete tempStyle['background'];
    tempStyle = Object.assign(Object.assign({}, splitBackground(_value)), tempStyle);
  }

  return tempStyle;
}

function splitBackground(value) {
  var newBackgroundMap = {};
  var colorKeys = Object.keys(COLOR_MAP).join('|');
  var color = '(#\\w{3,8})|(rgba?\\(.+\\))';
  var isColor = new RegExp("(".concat(color, "|").concat(colorKeys, ")"));

  if (isColor.test(value)) {
    var match = isColor.exec(value);

    if (match) {
      newBackgroundMap['background-color'] = match[0];
    }
  }

  if (isUrl.test(value)) {
    var urlMatch = /url\(.+\)/;

    var _match = urlMatch.exec(value);

    var backgorundImage = _match && _match[0];

    if (backgorundImage) {
      newBackgroundMap['background-image'] = transformBackgroundImage(backgorundImage);
    }
  }

  var clipMatch = matchKeyList(CLIP_LIST, value);

  if (clipMatch) {
    newBackgroundMap['backgrond-clip'] = clipMatch;
  }

  var repeatMatch = matchKeyList(REPEAT_LIST, value);

  if (repeatMatch) {
    newBackgroundMap['background-repeat'] = repeatMatch;
  }

  var sizeMatch = matchKeyList(SIZE_LIST, value);

  if (sizeMatch) {
    newBackgroundMap['background-size'] = sizeMatch;
  }

  return newBackgroundMap;
}

function matchKeyList(list, value) {
  var matchList = list.join('|');
  var isList = new RegExp(matchList);

  if (isList.test(value)) {
    var match = isList.exec(value);

    if (match) {
      return match[0];
    }
  }

  return '';
}

function transformBackgroundImage(value) {
  var backgroundImage = value.trim();

  if (isUrl.test(backgroundImage)) {
    var _matches2 = backgroundImage.match(imageUrlReg);

    return _matches2 && _matches2[1] || '';
  } else if (isImageBase64Reg.test(backgroundImage)) {
    var _matches3 = backgroundImage.match(imageBase64Reg);

    return _matches3 && _matches3[1] || '';
  }

  return '';
}

function transformLinear(value) {
  var backgroundLinear = value.replace(/\s+/g, '');
  var isRgba = /rgba?/;
  var rgbaReg = /rgba\(\d+,\d+,\d+,[\d\.]+\)/g;

  if (isRgba.test(backgroundLinear)) {
    var matcheList = backgroundLinear.match(rgbaReg);

    for (var item in matcheList) {
      backgroundLinear = backgroundLinear.replace(matcheList[parseInt(item)], hexify(matcheList[parseInt(item)]));
    }
  }

  backgroundLinear = backgroundLinear.split(',').map(function (res) {
    return getColor(res);
  }).join(' ');
  return backgroundLinear;
}

function transformFlex(style) {
  var tempStyle = Object.assign({}, style);

  if (tempStyle['flex']) {
    var value = tempStyle['flex'];
    delete tempStyle['flex'];
    tempStyle = Object.assign(Object.assign(Object.assign({}, defaultFlexStyle), transformFlexStyle(value + "")), tempStyle);
  }

  return tempStyle;
}

var defaultFlexStyle = {
  "flex-grow": 0,
  "flex-shrink": 0,
  "flex-basis": 'auto'
};

function transformFlexStyle(flexStyleValue) {
  var tempStyle = {};
  var values = flexStyleValue.trim().split(/\s+/);

  switch (values.length) {
    case 1:
      tempStyle = handleFlexStyleBy1(values);
      break;

    case 2:
      tempStyle = handleFlexStyleBy2(values);
      break;

    case 3:
      tempStyle = handleFlexStyleBy3(values);
      break;
  }

  return tempStyle;
}

function handleFlexStyleBy1(values) {
  var value = values[0];
  var tempStyle = {};

  if (isNaN(parseInt(value))) {
    tempStyle["flex-basis"] = value;
  } else {
    if (value === "0") {
      tempStyle["flex-basis"] = 0;
    } else {
      tempStyle["flex-grow"] = Number(value);
      tempStyle["flex-shrink"] = Number(value);
    }
  }

  return tempStyle;
}

function handleFlexStyleBy2(values) {
  var tempStyle = {};

  var _values3 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_6__["default"])(values, 2),
      firstValue = _values3[0],
      secondValue = _values3[1];

  if (firstValue) {
    tempStyle["flex-grow"] = firstValue;
  }

  if (secondValue) {
    if (isNumber(secondValue)) {
      tempStyle["flex-shrink"] = Number(secondValue);
    } else {
      tempStyle["flex-basis"] = secondValue;
    }
  }

  return tempStyle;
}

function handleFlexStyleBy3(values) {
  var _values4 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_6__["default"])(values, 3),
      firstValue = _values4[0],
      secondValue = _values4[1],
      thirdValue = _values4[2];

  return {
    "flex-grow": firstValue,
    "flex-shrink": secondValue,
    "flex-basis": thirdValue
  };
}

function transformTransform(style) {
  var tempStyle = Object.assign({}, style);

  if (tempStyle['transform']) {
    var value = tempStyle['transform'];
    tempStyle = Object.assign(Object.assign({}, tempStyle), splitToArray(transTranslateUnit(replaceDeg(value))));
  }

  return tempStyle;
}

function splitToArray(params) {
  return {
    transform: params.trim().split(/\s+/g).join(',')
  };
}

function replaceDeg(str) {
  return str.replace(/deg/g, '');
}

function transTranslateUnit(str) {
  var arr = str.replace(/\s/g, '').match(/[a-zA-Z0-9]+\(.+?\)/g) || [];
  arr.map(function (item, index) {
    if (item.indexOf('translate') > -1 || item.indexOf('position') > -1) {
      var temp = item.match(/[^(][a-zA-Z0-9,]+(?=\))/g);
      var key = item.split('(')[0];
      var value = temp ? temp[0] : '0';
      value = value.split(',').map(function (v) {
        return transformUnitValue(v);
      }).join(',');
      arr[index] = "".concat(key, "(").concat(value, ")");
    }
  });
  return arr.join(' ');
}

var transitionFullProperty = ['transition-delay', 'transition-duration', 'transition-property', 'transition-timing-function'];

function transformTransition(style) {
  var tempStyle = Object.assign({}, style);
  transitionFullProperty.forEach(function (property) {
    if (tempStyle[property]) {
      var value = tempStyle[property];
      tempStyle = Object.assign(Object.assign({}, getHummerProp(property, value)), tempStyle);
      delete tempStyle[property];
    }
  });

  if (tempStyle['transition']) {
    var value = tempStyle['transition'];
    tempStyle = Object.assign(Object.assign({}, splitToFullProps(value)), tempStyle);
    delete tempStyle['transition'];
  }

  return tempStyle;
}

function getHummerProp(property, value) {
  var obj = {};
  obj[property] = isTime(value) ? value.replace('s', '') : value;
  return obj;
}

function splitToFullProps(params) {
  var transitionPropertyArray = [];
  var transitionDurationArray = [];
  var transitionTimingFunctionArray = [];
  var transitionDelayArray = [];
  var transitionArray = params.split(',');
  transitionArray.forEach(function (transition) {
    var transitonValues = transition.trim().split(/\s+/g);
    transitonValues = getFullValues(transitonValues);
    transitionPropertyArray.push(transitonValues[0]);
    transitionDurationArray.push(transitonValues[1].replace('s', ''));
    transitionTimingFunctionArray.push(transitonValues[2]);
    transitionDelayArray.push(transitonValues[3].replace('s', ''));
  });
  return {
    'transition-property': transitionPropertyArray.join(','),
    'transition-duration': transitionDurationArray.join(','),
    'transition-timing-function': transitionTimingFunctionArray[0],
    'transition-delay': transitionDelayArray[0]
  };
}

function getFullValues(transitonValues) {
  var tempArray = [];
  tempArray = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(transitonValues);

  if (transitonValues.length === 2) {
    tempArray = [].concat((0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(transitonValues), ['ease', '0s']);
  } else if (transitonValues.length === 3) {
    if (isTime(transitonValues[2])) {
      tempArray = [transitonValues[0], transitonValues[1], 'ease', transitonValues[2]];
    } else {
      tempArray = [].concat((0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(transitonValues), ['0s']);
    }
  }

  return tempArray;
}

function isTime(str) {
  return /^\d*[s]$/.test(str);
}

var NODE_VIEW = Symbol('NODE_VIEW');
var NODE_TEXT = Symbol('NODE_TEXT');
var NODE_IMAGE = Symbol('NODE_IMAGE');
var NODE_BUTTON = Symbol('NODE_BUTTON');
var NODE_TEXTAREA = Symbol('NODE_TEXTAREA');
var NODE_INPUT = Symbol('NODE_INPUT');
var NODE_SWITCH = Symbol('NODE_SWITCH');
var NODE_SCROLLER = Symbol('NODE_SCROLLER');
var NODE_VIEW_PAGER = Symbol('NODE_VIEW_PAGER');
var NODE_LIST = Symbol('NODE_LIST');
var NODE_DIALOG = Symbol('NODE_DIALOG');
var NODE_ANIMATION_VIEW = Symbol('NODE_ANIMATION_VIEW');
var NODE_COMMENT = Symbol('NODE_COMMENT');
var NODE_ANCHOR = Symbol('NODE_ANCHOR');
var NODE_REFRESH = Symbol('NODE_REFRESH');
var NODE_LOADMORE = Symbol('NODE_LOADMORE');
var ELEMNT_TAG_MAP = {
  [NODE_VIEW]: 'view',
  [NODE_TEXT]: 'text',
  [NODE_IMAGE]: 'image',
  [NODE_BUTTON]: 'button',
  [NODE_TEXTAREA]: 'textarea',
  [NODE_INPUT]: 'input',
  [NODE_SWITCH]: 'switch',
  [NODE_SCROLLER]: 'scroller',
  [NODE_VIEW_PAGER]: 'viewpager',
  [NODE_LIST]: 'list',
  [NODE_DIALOG]: 'dialog',
  [NODE_ANIMATION_VIEW]: 'animation',
  [NODE_ANCHOR]: 'anchor',
  [NODE_REFRESH]: 'refresh',
  [NODE_LOADMORE]: 'loadmore'
};
var borderRadius = 'borderRadius,borderTopLeftRadius,borderTopRightRadius,borderBottomLeftRadius,borderBottomRightRadius';
var isBorderRadius = makeMap(borderRadius);

function dynamicTransformAdapter(style, view) {
  var tempStyle = {};
  tempStyle = hackForBorderRadius(view, style);
  return tempStyle;
}

function hackForBorderRadius(view, style) {
  if (view && view.__NAME === NODE_IMAGE && hasSpecialAttr(style, isBorderRadius)) {
    style['overflow'] = 'hidden';
  }

  return style;
}

function hasSpecialAttr(obj, func) {
  return Object.keys(obj).some(function (key) {
    return func(key);
  });
}

var StyleTransformer = /*#__PURE__*/function () {
  function StyleTransformer() {
    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, StyleTransformer);

    this.middlewares = [];
    this.registerMiddleware();
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(StyleTransformer, [{
    key: "registerMiddleware",
    value: function registerMiddleware() {
      this.use(transformAdapter).use(transformBreakToken).use(transformBackground).use(transformTransform).use(transformTransition).use(transformFlex).use(transformBorder).use(transformShadow).use(transformColor).use(transformUnit).use(transformAttr);
    }
  }, {
    key: "use",
    value: function use(middleware) {
      if (typeof middleware !== 'function') {
        throw "middleware must be a function";
      }

      this.middlewares.push(middleware);
      return this;
    }
  }, {
    key: "transformStyle",
    value: function transformStyle() {
      var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var view = arguments.length > 1 ? arguments[1] : undefined;
      var tempStyle = style;
      this.middlewares.forEach(function (middleware) {
        var result = middleware(tempStyle, view);
        tempStyle = result ? result : tempStyle;
      });
      return tempStyle;
    }
  }]);

  return StyleTransformer;
}();

var StyleDynamicTransformer = /*#__PURE__*/function () {
  function StyleDynamicTransformer() {
    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, StyleDynamicTransformer);

    this.middlewares = [];
    this.registerMiddleware();
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(StyleDynamicTransformer, [{
    key: "registerMiddleware",
    value: function registerMiddleware() {
      this.use(dynamicTransformAdapter);
    }
  }, {
    key: "use",
    value: function use(middleware) {
      if (typeof middleware !== 'function') {
        throw "middleware must be a function";
      }

      this.middlewares.push(middleware);
      return this;
    }
  }, {
    key: "transformStyle",
    value: function transformStyle() {
      var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var view = arguments.length > 1 ? arguments[1] : undefined;
      var tempStyle = style;
      this.middlewares.forEach(function (middleware) {
        var result = middleware(tempStyle, view);
        tempStyle = result ? result : tempStyle;
      });
      return tempStyle;
    }
  }]);

  return StyleDynamicTransformer;
}();

var styleTransformer = new StyleTransformer();
var styleDynamicTransformer = new StyleDynamicTransformer();
var isNativeTagReg = /^ex-/;
var NativeTags = "view,text,image,input,textarea,button,scroller,switch,refresh,loadmore,list,viewpager";
var isNativeTags = makeMap(NativeTags);

var isCustomNativeTag = function isCustomNativeTag(tag) {
  return isNativeTagReg.test(tag);
};

var extend$1 = Object.assign;
var ELEMNT_TAG_MAP_1 = tenonUtils_cjs.ELEMNT_TAG_MAP = ELEMNT_TAG_MAP;
var NODE_ANCHOR_1 = tenonUtils_cjs.NODE_ANCHOR = NODE_ANCHOR;
tenonUtils_cjs.NODE_ANIMATION_VIEW = NODE_ANIMATION_VIEW;
var NODE_BUTTON_1 = tenonUtils_cjs.NODE_BUTTON = NODE_BUTTON;
var NODE_COMMENT_1 = tenonUtils_cjs.NODE_COMMENT = NODE_COMMENT;
tenonUtils_cjs.NODE_DIALOG = NODE_DIALOG;
var NODE_IMAGE_1 = tenonUtils_cjs.NODE_IMAGE = NODE_IMAGE;
var NODE_INPUT_1 = tenonUtils_cjs.NODE_INPUT = NODE_INPUT;
tenonUtils_cjs.NODE_LIST = NODE_LIST;
var NODE_LOADMORE_1 = tenonUtils_cjs.NODE_LOADMORE = NODE_LOADMORE;
var NODE_REFRESH_1 = tenonUtils_cjs.NODE_REFRESH = NODE_REFRESH;
var NODE_SCROLLER_1 = tenonUtils_cjs.NODE_SCROLLER = NODE_SCROLLER;
var NODE_SWITCH_1 = tenonUtils_cjs.NODE_SWITCH = NODE_SWITCH;
var NODE_TEXT_1 = tenonUtils_cjs.NODE_TEXT = NODE_TEXT;
var NODE_TEXTAREA_1 = tenonUtils_cjs.NODE_TEXTAREA = NODE_TEXTAREA;
var NODE_VIEW_1 = tenonUtils_cjs.NODE_VIEW = NODE_VIEW;
tenonUtils_cjs.NODE_VIEW_PAGER = NODE_VIEW_PAGER;
tenonUtils_cjs.NativeTags = NativeTags;
tenonUtils_cjs.camelize = camelize;
tenonUtils_cjs.extend = extend$1;
var getColor_1 = tenonUtils_cjs.getColor = getColor;
tenonUtils_cjs.getEnvironmentInfo = getEnvironmentInfo;
var isCustomNativeTag_1 = tenonUtils_cjs.isCustomNativeTag = isCustomNativeTag;
tenonUtils_cjs.isNativeTags = isNativeTags;
tenonUtils_cjs.makeMap = makeMap;
tenonUtils_cjs.makeMapByArr = makeMapByArr;
var parseStringStyle_1 = tenonUtils_cjs.parseStringStyle = parseStringStyle;
var styleDynamicTransformer_1 = tenonUtils_cjs.styleDynamicTransformer = styleDynamicTransformer;
var styleTransformer_1 = tenonUtils_cjs.styleTransformer = styleTransformer;
var transformUnitValue_1 = tenonUtils_cjs.transformUnitValue = transformUnitValue;
tenonUtils_cjs.traverseArr = traverseArr;
var ViewCache = new Map();
var FixedViewCache = new Map();

var setCacheNode = function setCacheNode(node) {
  ViewCache.set(node.__view_id, node);
};

var deleteCacheNode = function deleteCacheNode(node) {
  ViewCache.delete(node.__view_id);
};

var handleFixedNodeByStyle = function handleFixedNodeByStyle(node, newStyle) {
  var oldPosition = node.style.position;
  var newPosition = newStyle.position;

  if (newPosition === 'fixed') {
    registerFixedNode(node);
    return true;
  }

  if (oldPosition === 'fixed' && newPosition !== 'fixed') {
    unRegisterFixedNode(node);
    return false;
  }

  return false;
};

var registerFixedNode = function registerFixedNode(node) {
  var fixedNode = {
    id: node.__view_id,
    parents: node.parent ? getParentIds(node.__view_id) : null
  };
  FixedViewCache.set(node.__view_id, fixedNode);
};

var unRegisterFixedNode = function unRegisterFixedNode(node) {
  var id = node.__view_id;
  FixedViewCache.delete(id);
};

var removeChildWithFixed = function removeChildWithFixed(node) {
  var __view_id = node.__view_id;
  FixedViewCache.forEach(function (fixedNode) {
    var id = fixedNode.id,
        parents = fixedNode.parents;

    if (fixedNode.parents === null) {
      parents = fixedNode.parents = getParentIds(id);
    }

    if (parents && parents.has(__view_id)) {
      deleteNodeByViewId(id);
    }

    if (id === __view_id) {
      FixedViewCache.delete(id);
    }
  });
  deleteCacheNode(node);
};

function getParentIds(id) {
  var ids = new Set();
  var node = ViewCache.get(id);

  while (node) {
    if (node.parent) {
      ids.add(node.parent.__view_id);
    }

    node = node.parent;
  }

  return ids;
}

function deleteNodeByViewId(id) {
  var node = ViewCache.get(id);

  if (node && node.parent) {
    node.parent._removeChild(node);
  }

  FixedViewCache.delete(id);
}

var animationId = 0;
var EasingType;

(function (EasingType) {
  EasingType["LINEAR"] = "linear";
  EasingType["EASE"] = "ease";
  EasingType["EASE_IN"] = "ease-in";
  EasingType["EASE_OUT"] = "ease-out";
  EasingType["EASE_IN_OUT"] = "ease-in-out";
})(EasingType || (EasingType = {}));

var AnimationStyle;

(function (AnimationStyle) {
  AnimationStyle["POSITION"] = "position";
  AnimationStyle["SCALE"] = "scale";
  AnimationStyle["SCALEX"] = "scaleX";
  AnimationStyle["SCALEY"] = "scaleY";
  AnimationStyle["ROTATIONX"] = "rotationX";
  AnimationStyle["ROTATIONY"] = "rotationY";
  AnimationStyle["ROTATIONZ"] = "rotationZ";
  AnimationStyle["OPACITY"] = "opacity";
  AnimationStyle["BACKGROUND_COLOR"] = "backgroundColor";
  AnimationStyle["WIDTH"] = "width";
  AnimationStyle["HEIGHT"] = "height";
})(AnimationStyle || (AnimationStyle = {}));

function handleKeyframeAnimation(node, animation) {
  var id = animation.id,
      onEnd = animation.onEnd,
      onStart = animation.onStart,
      keyframes = animation.keyframes,
      _animation$repeatCoun = animation.repeatCount,
      repeatCount = _animation$repeatCoun === void 0 ? 1 : _animation$repeatCoun,
      duration = animation.duration,
      delay = animation.delay,
      _animation$easing = animation.easing,
      easing = _animation$easing === void 0 ? 'linear' : _animation$easing;
  var element = node.element;
  var styles = keyframes[0].styles;
  styles = transformStyle(styles);
  var len = Object.keys(styles).length;

  if (!id) {
    id = animationId++;
  }

  Object.keys(styles).forEach(function (key, index) {
    var ani = new __GLOBAL__.KeyframeAnimation(key);
    var tempKeyframes = [];
    keyframes.forEach(function (keyframe) {
      var transformedStyles = transformStyle(keyframe.styles);

      if (transformedStyles[key] !== undefined) {
        tempKeyframes.push({
          percent: keyframe.percent,
          value: transformedStyles[key]
        });
      }
    });
    ani.keyframes = tempKeyframes;
    easing && (ani.easing = easing);
    duration && (ani.duration = handleDuration(duration));
    delay && (ani.delay = handleDelay(delay));
    repeatCount && (ani.repeatCount = repeatCount);

    if (index === 0) {
      onStart && ani.on("start", function () {
        onStart && onStart();
      });
    }

    onEnd && ani.on("end", function () {
      if (--len <= 0) {
        onEnd && onEnd();
      }
    });
    element.addAnimation(ani, id + "_" + key);
  });
}

function handleBasicAnimation(node, animation) {
  var styles = animation.styles,
      id = animation.id,
      duration = animation.duration,
      delay = animation.delay,
      repeatCount = animation.repeatCount,
      easing = animation.easing,
      onStart = animation.onStart,
      onEnd = animation.onEnd;
  var element = node.element;
  styles = transformStyle(styles);

  if (!id) {
    id = animationId++;
  }

  var len = Object.keys(styles).length;
  Object.keys(styles).forEach(function (key, index) {
    var ani = new __GLOBAL__.BasicAnimation(key);
    ani.value = styles[key];
    easing && (ani.easing = easing);
    !isNaN(duration) && (ani.duration = handleDuration(duration));
    !isNaN(delay) && (ani.delay = handleDelay(delay));
    !isNaN(repeatCount) && (ani.repeatCount = repeatCount);

    if (index === 0) {
      onStart && ani.on("start", function () {
        onStart && onStart();
      });
    }

    onEnd && ani.on("end", function () {
      if (--len <= 0) {
        onEnd && onEnd();
      }
    });
    element.addAnimation(ani, id + "_" + key);
  });
}

function handleStepAnimation(node, animation) {
  var id = animation.id,
      onEnd = animation.onEnd,
      onStart = animation.onStart,
      steps = animation.steps;
  var current = Promise.resolve();
  steps && steps.forEach(function (step, index) {
    var _onStart;

    var _onEnd;

    current = current.then(function () {
      return new Promise(function (resolve) {
        if (index === 0) {
          _onStart = function _onStart() {
            step.onStart && step.onStart();
            onStart && onStart();
          };
        }

        if (index === steps.length - 1) {
          _onEnd = function _onEnd() {
            step.onEnd && step.onEnd();
            onEnd && onEnd();
          };
        } else {
          _onEnd = function _onEnd() {
            step.onEnd && step.onEnd();
            resolve();
          };
        }

        handleBasicAnimation(node, Object.assign(Object.assign({}, step), {
          id: id + "_" + index,
          onStart: _onStart,
          onEnd: _onEnd
        }));
      });
    });
  });
}

function transformStyle(styles) {
  Object.keys(styles).forEach(function (key) {
    switch (key) {
      case AnimationStyle.POSITION:
        var position = styles[key];
        styles[key] = {
          x: transformUnitValue_1(position.x),
          y: transformUnitValue_1(position.y)
        };
        break;

      case AnimationStyle.BACKGROUND_COLOR:
        styles[key] = getColor_1(styles[key]);
        break;

      case AnimationStyle.WIDTH:
        styles[key] = transformUnitValue_1(styles[key]);
        break;

      case AnimationStyle.HEIGHT:
        styles[key] = transformUnitValue_1(styles[key]);
        break;
    }
  });
  return styles;
}

function handleDuration(duration) {
  return duration / 1000;
}

function handleDelay(delay) {
  return delay / 1000;
}

var _handleAnimation = function handleAnimation(context, animation) {
  if (animation.keyframes) {
    handleKeyframeAnimation(context, animation);
  }

  if (animation.styles) {
    handleBasicAnimation(context, animation);
  }

  if (animation.steps) {
    handleStepAnimation(context, animation);
  }
};

var MatchType;

(function (MatchType) {
  MatchType[MatchType["Class"] = 0] = "Class";
  MatchType[MatchType["ID"] = 1] = "ID";
  MatchType[MatchType["Attr"] = 2] = "Attr";
  MatchType[MatchType["Tag"] = 3] = "Tag";
})(MatchType || (MatchType = {}));

var RuleKeyMap = {
  'tagList': 'tagMap',
  'classList': 'classMap',
  'idList': 'idMap'
};
var RelationType;

(function (RelationType) {
  RelationType[RelationType["Subselector"] = 0] = "Subselector";
  RelationType[RelationType["DescendantSpace"] = 1] = "DescendantSpace";
  RelationType[RelationType["Child"] = 2] = "Child";
  RelationType[RelationType["DirectAdjacent"] = 3] = "DirectAdjacent";
  RelationType[RelationType["IndirectAdjacent"] = 4] = "IndirectAdjacent";
})(RelationType || (RelationType = {}));

var collectStyle = function collectStyle(ruleSetMap) {
  if (!__GLOBAL__.CSSOM) {
    var defaultRuleSetGroup = {
      global: {
        tagMap: new Map(),
        classMap: new Map(),
        idMap: new Map()
      }
    };
    __GLOBAL__.CSSOM = defaultRuleSetGroup;
  }

  Object.keys(ruleSetMap).forEach(function (group) {
    var ruleSet = ruleSetMap[group];
    collectStyleGroup(ruleSet, group);
  });
};

var collectStyleGroup = function collectStyleGroup(ruleSet, group) {
  if (!__GLOBAL__.CSSOM[group]) {
    var defaultRuleSet = {
      tagMap: new Map(),
      classMap: new Map(),
      idMap: new Map()
    };
    __GLOBAL__.CSSOM[group] = defaultRuleSet;
  }

  Object.keys(ruleSet).forEach(function (ruleKey) {
    var ruleList = ruleSet[ruleKey];
    var key = RuleKeyMap[ruleKey];
    key && ruleList.forEach(function (rule) {
      if (rule) {
        var selectorMap = __GLOBAL__.CSSOM[group][key];
        var selectorKey = rule.selector;
        var styleList = selectorMap.get(selectorKey) || [];
        styleList.push(rule);

        __GLOBAL__.CSSOM[group][key].set(selectorKey, styleList);
      }
    });
  });
};

var getClassStyle = function getClassStyle(instance) {
  var className = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var scoped = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var scopedId = arguments.length > 3 ? arguments[3] : undefined;
  var elementStyle = {};
  var classList = className.split(/\s/);
  classList.forEach(function (item) {
    if (!item) {
      return;
    }

    var globalStyleArr = getGlobalStyle(MatchType.Class, item, filterStyle(classList));
    var scopeStylesArr = [];

    if (scoped && scopedId) {
      scopeStylesArr = getScopedStyle(MatchType.Class, item, scopedId, filterStyle(classList));
    }

    elementStyle = Object.assign.apply(Object, [{}, elementStyle].concat((0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(globalStyleArr), (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__["default"])(scopeStylesArr)));
  });
  return elementStyle;
};

function filterStyle() {
  var classList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return function (rule) {
    if (rule.relation === '') {
      return true;
    }

    var flag = true;
    var selector = rule.n_selector;

    if (!selector.next) {
      return true;
    }

    switch (selector.relation) {
      case RelationType.Subselector:
        while (selector) {
          if (classList.indexOf(selector.value) < 0) {
            flag = false;
            break;
          }

          selector = selector.next;
        }

        break;
    }

    return flag;
  };
}

function getGlobalStyle(type, key, filterFunc) {
  var styles = [];

  switch (type) {
    case MatchType.Class:
      styles = __GLOBAL__.CSSOM['global'].classMap.get(key) || [];
      break;
  }

  return styles.filter(function (item) {
    if (filterFunc) {
      return filterFunc(item);
    }

    return item;
  }).map(function (item) {
    return item === null || item === void 0 ? void 0 : item.style;
  });
}

function getScopedStyle(type, key, scopedId, filterFunc) {
  var styles = [];
  var _GLOBAL__ = __GLOBAL__,
      CSSOM = _GLOBAL__.CSSOM;

  if (CSSOM[scopedId]) {
    switch (type) {
      case MatchType.Class:
        styles = CSSOM[scopedId].classMap.get(key) || [];
        break;
    }
  }

  return styles.filter(function (item) {
    if (filterFunc) {
      return filterFunc(item);
    }

    return item;
  }).map(function (item) {
    return item === null || item === void 0 ? void 0 : item.style;
  });
}

var __view_id = 0;

var Base = /*#__PURE__*/function () {
  function Base() {
    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, Base);

    this._scopedIds = new Set();
    this.__NAME = null;
    this.element = null;
    this.dataset = {};
    this.children = new Set();
    this.parent = undefined;
    this.firstChild = null;
    this.lastChild = null;
    this.prevSibling = null;
    this.nextSibling = null;
    this.props = new Map();
    this.__view_id = 0;
    this._defaultStyle = {};
    this._style = {};
    this._baseStyle = {};
    this.__view_id = __view_id++;
    setCacheNode(this);
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(Base, [{
    key: "disabled",
    get: function get() {
      return !this.element.enabled;
    },
    set: function set(disabled) {
      this.element.enabled = !disabled;
    }
  }, {
    key: "style",
    get: function get() {
      return this._style || {};
    },
    set: function set(value) {
      this.setStyle(value, true);
    }
  }, {
    key: "className",
    get: function get() {
      return this.props.get('class');
    }
  }, {
    key: "setScopeId",
    value: function setScopeId(id) {
      this._scopedIds.add(id);

      this.updateStyle();
    }
  }, {
    key: "updateStyle",
    value: function updateStyle() {
      var _this3 = this;

      if (!this._scopedIds.size) {
        return;
      }

      var className = this.getAttribute('class');

      this._scopedIds.forEach(function (scopedId) {
        var elementStyle = getClassStyle(_this3, className, true, scopedId);

        if (Object.keys(elementStyle).length > 0) {
          _this3.setStyle(elementStyle);
        }
      });
    }
  }, {
    key: "_onMounted",
    value: function _onMounted() {
      this.onMounted();
    }
  }, {
    key: "onMounted",
    value: function onMounted() {}
  }, {
    key: "_onDestoryed",
    value: function _onDestoryed() {
      removeChildWithFixed(this);
      this.onDestoryed();
    }
  }, {
    key: "onDestoryed",
    value: function onDestoryed() {}
  }, {
    key: "_appendChild",
    value: function _appendChild(child) {
      child.unlinkSiblings();
      child.parent = this;
      this.children.add(child);

      if (!this.firstChild) {
        this.firstChild = child;
      }

      child.prevSibling = this.lastChild;
      child.nextSibling = null;

      if (this.lastChild) {
        this.lastChild.nextSibling = child;
      }

      this.lastChild = child;

      if (this.element && child.element) {
        this.element.appendChild(child.element);
      }

      child._onMounted();
    }
  }, {
    key: "unlinkSiblings",
    value: function unlinkSiblings() {
      if (this.parent && this.parent.firstChild === this) {
        this.parent.firstChild = this.nextSibling;
      }

      if (this.parent && this.parent.lastChild === this) {
        this.parent.lastChild = this.prevSibling;
      }

      if (this.prevSibling) {
        this.prevSibling.nextSibling = this.nextSibling;
      }

      if (this.nextSibling) {
        this.nextSibling.prevSibling = this.prevSibling;
      }

      this.prevSibling = null;
      this.nextSibling = null;
    }
  }, {
    key: "_removeChild",
    value: function _removeChild(child) {
      child._onDestoryed();

      child.unlinkSiblings();
      child.parent = undefined;
      this.children.delete(child);

      if (this.element && child.element) {
        this.element.removeChild(child.element);
      }
    }
  }, {
    key: "_insertBefore",
    value: function _insertBefore(child, anchor) {
      child.unlinkSiblings();
      child.parent = this;

      if (anchor.prevSibling) {
        child.prevSibling = anchor.prevSibling;
        anchor.prevSibling.nextSibling = child;
      }

      anchor.prevSibling = child;
      child.nextSibling = anchor;

      if (this.firstChild === anchor) {
        this.firstChild = child;
      }

      this.children.add(child);

      if (this.element && child.element && anchor.element) {
        this.element.insertBefore(child.element, anchor.element);

        child._onMounted();
      }
    }
  }, {
    key: "setElementText",
    value: function setElementText(text) {}
  }, {
    key: "setStyle",
    value: function setStyle(style) {
      var flag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var tempStyle = this.hackForStyle(style, this);
      flag && (this._baseStyle = tempStyle);
      var newStyle = Object.assign(Object.assign(Object.assign({}, this._defaultStyle), tempStyle), this._baseStyle);
      handleFixedNodeByStyle(this, newStyle);
      this.element.style = this._style = newStyle;
    }
  }, {
    key: "hackForStyle",
    value: function hackForStyle(style, base) {
      return styleDynamicTransformer_1.transformStyle(style, base);
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(key, value) {
      this.setCacheProp(key, value);

      switch (key) {
        case 'disabled':
          this.disabled = value !== false;
          break;

        case 'class':
          this.updateStyle();
          break;

        default:
          this._setAttribute(key, value);

          break;
      }
    }
  }, {
    key: "setCacheProp",
    value: function setCacheProp(key, value) {
      if (/^data/.test(key)) {
        var dataKey = key.slice(4).toLowerCase();

        if (dataKey) {
          this.dataset[dataKey] = value;
        }
      }

      this.props.set(key, value);
    }
  }, {
    key: "_setAttribute",
    value: function _setAttribute(key, value) {}
  }, {
    key: "getAttribute",
    value: function getAttribute(key) {
      switch (key) {
        case 'disabled':
          return this.disabled;

        default:
          return this.props.get(key);
      }
    }
  }, {
    key: "handleAnimation",
    value: function handleAnimation(animation) {
      _handleAnimation(this, animation);
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(event, func) {
      var _this4 = this;

      this.element.addEventListener(event, function (e) {
        e.target = {
          dataset: _this4.dataset
        };
        func.call(_this4, e);
      });
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(event, func) {
      this.element.removeEventListener(event, func);
    }
  }, {
    key: "getRect",
    value: function getRect(func) {
      var _this5 = this;

      this.element.getRect(function (rect) {
        func.call(_this5, rect);
      });
    }
  }]);

  return Base;
}();

var noFunc = function noFunc() {};

var RootViewComponent = /*#__PURE__*/function (_GLOBAL__$View) {
  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__["default"])(RootViewComponent, _GLOBAL__$View);

  var _super = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(RootViewComponent);

  function RootViewComponent() {
    var _this6;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, RootViewComponent);

    _this6 = _super.call(this);
    _this6._element = null;
    _this6._canScroll = true;
    var onLoad = options.onLoad,
        onShow = options.onShow,
        onHide = options.onHide,
        onUnload = options.onUnload,
        onBack = options.onBack,
        _options$canScroll = options.canScroll,
        canScroll = _options$canScroll === void 0 ? true : _options$canScroll,
        _options$pageStyle = options.pageStyle,
        pageStyle = _options$pageStyle === void 0 ? {} : _options$pageStyle;
    _this6._onCreate = onLoad || noFunc;
    _this6._onAppear = onShow || noFunc;
    _this6._onDisappear = onHide || noFunc;
    _this6._onDestroy = onUnload || noFunc;
    _this6._onBack = onBack || noFunc;
    _this6._canScroll = canScroll;
    _this6.style = Object.assign(Object.assign({}, pageStyle), {
      width: '100%',
      height: '100%'
    });

    if (_this6._canScroll) {
      _this6._element = new __GLOBAL__.Scroller();
      _this6._element.style = {
        width: "100%",
        height: "100%"
      };

      _this6.appendChild(_this6._element);
    }

    return _this6;
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(RootViewComponent, [{
    key: "element",
    get: function get() {
      return this._canScroll && this._element ? this._element : this;
    }
  }, {
    key: "onCreate",
    value: function onCreate() {
      this._onCreate();
    }
  }, {
    key: "onAppear",
    value: function onAppear() {
      this._onAppear();
    }
  }, {
    key: "onDisappear",
    value: function onDisappear() {
      this._onDisappear();
    }
  }, {
    key: "onDestroy",
    value: function onDestroy() {
      this._onDestroy();
    }
  }, {
    key: "onBack",
    value: function onBack() {
      var result = this._onBack();

      return result || false;
    }
  }]);

  return RootViewComponent;
}(__GLOBAL__.View);

var Page = /*#__PURE__*/function (_Base) {
  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__["default"])(Page, _Base);

  var _super2 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(Page);

  function Page(options) {
    var _this7;

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, Page);

    _this7 = _super2.call(this);
    _this7._rootView = new RootViewComponent(options);
    _this7.element = _this7._rootView.element;
    return _this7;
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(Page, [{
    key: "render",
    value: function render() {
      __GLOBAL__.Hummer.render(this._rootView);
    }
  }, {
    key: "onLoad",
    set: function set(load) {
      this._rootView._onCreate = load;
    }
  }, {
    key: "onShow",
    set: function set(show) {
      this._rootView._onAppear = show;
    }
  }, {
    key: "onHide",
    set: function set(hide) {
      this._rootView._onDisappear = hide;
    }
  }, {
    key: "onUnload",
    set: function set(destroy) {
      this._rootView._onDestroy = destroy;
    }
  }, {
    key: "onBack",
    set: function set(back) {
      this._rootView._onBack = back;
    }
  }]);

  return Page;
}(Base);

var View = /*#__PURE__*/function (_Base2) {
  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__["default"])(View, _Base2);

  var _super3 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(View);

  function View() {
    var _this8;

    var isView = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, View);

    _this8 = _super3.call(this);
    _this8.__NAME = NODE_VIEW_1;

    if (!isView) {
      return (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0__["default"])(_this8);
    }

    _this8.element = new __GLOBAL__.View();
    return _this8;
  }

  return View;
}(Base);

var Text = /*#__PURE__*/function (_Base3) {
  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__["default"])(Text, _Base3);

  var _super4 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(Text);

  function Text() {
    var _this9;

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, Text);

    _this9 = _super4.call(this);
    _this9.__NAME = NODE_TEXT_1;
    _this9._text = '';
    _this9.element = new __GLOBAL__.Text();
    return _this9;
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(Text, [{
    key: "setElementText",
    value: function setElementText(text) {
      this._text = text;
      this.element.text = text;
      this.parent && this.parent.__NAME === NODE_TEXT_1 && this.parent.setElementText(this.parent.getInnerText());
    }
  }, {
    key: "getInnerText",
    value: function getInnerText() {
      var innerText = '';
      this.children.forEach(function (child) {
        innerText += child && child._text || '';
      });
      return innerText;
    }
  }, {
    key: "_appendChild",
    value: function _appendChild(child) {
      child.unlinkSiblings();
      child.parent = this;
      this.children.add(child);

      if (!this.firstChild) {
        this.firstChild = child;
      }

      child.prevSibling = this.lastChild;
      child.nextSibling = null;

      if (this.lastChild) {
        this.lastChild.nextSibling = child;
      }

      this.lastChild = child;

      if (this.element && child.element) {
        this.setElementText(this.getInnerText());
      }

      child._onMounted();
    }
  }, {
    key: "_insertBefore",
    value: function _insertBefore(child, anchor) {
      child.unlinkSiblings();
      child.parent = this;

      if (anchor.prevSibling) {
        child.prevSibling = anchor.prevSibling;
        anchor.prevSibling.nextSibling = child;
      }

      anchor.prevSibling = child;
      child.nextSibling = anchor;

      if (this.firstChild === anchor) {
        this.firstChild = child;
      }

      this.children.add(child);

      if (this.element && child.element && anchor.element) {
        this.setElementText(this.getInnerText());

        child._onMounted();
      }
    }
  }, {
    key: "_removeChild",
    value: function _removeChild(child) {
      child._onDestoryed();

      child.unlinkSiblings();
      child.parent = undefined;
      this.children.delete(child);

      if (this.element && child.element) {
        this.setElementText(this.getInnerText());
      }
    }
  }, {
    key: "text",
    get: function get() {
      return this._text;
    },
    set: function set(text) {
      this._text = text;
      this.element.text = text;
    }
  }, {
    key: "richText",
    set: function set(value) {
      this.element.richText = value;
    }
  }, {
    key: "_setAttribute",
    value: function _setAttribute(key, value) {
      switch (key) {
        case 'richText':
          this.richText = value;
          break;
      }
    }
  }]);

  return Text;
}(Base);

var ImageAttr;

(function (ImageAttr) {
  ImageAttr["Src"] = "src";
  ImageAttr["GifCount"] = "gifRepeatCount";
  ImageAttr["Resize"] = "resize";
})(ImageAttr || (ImageAttr = {}));

var gifReg = /\.gif$/;

var Image = /*#__PURE__*/function (_Base4) {
  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__["default"])(Image, _Base4);

  var _super5 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(Image);

  function Image() {
    var _this10;

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, Image);

    _this10 = _super5.call(this);
    _this10.__NAME = NODE_IMAGE_1;
    _this10._src = '';
    _this10.element = new __GLOBAL__.Image();
    _this10.element.style = {
      resize: 'stretch'
    };
    return _this10;
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(Image, [{
    key: "src",
    set: function set(value) {
      if (gifReg.test(value)) {
        this.element.gifSrc = value;
      } else {
        this.element.src = value;
      }

      this._src = value;
    }
  }, {
    key: "_setAttribute",
    value: function _setAttribute(key, value) {
      switch (key) {
        case ImageAttr.Src:
          this.src = value;
          break;

        case ImageAttr.GifCount:
          this.element.gifRepeatCount = Number(value);
          this.src = this._src;
          break;

        case ImageAttr.Resize:
          this.style = {
            resize: value
          };
          break;
      }
    }
  }]);

  return Image;
}(Base);

var Input = /*#__PURE__*/function (_Base5) {
  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__["default"])(Input, _Base5);

  var _super6 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(Input);

  function Input() {
    var _this11;

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, Input);

    _this11 = _super6.call(this);
    _this11.__NAME = NODE_INPUT_1;
    _this11._input = null;
    _this11._change = null;
    _this11._focus = null;
    _this11._blur = null;
    _this11._confirm = null;
    _this11._hasInput = false;
    _this11.element = new __GLOBAL__.Input();
    return _this11;
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(Input, [{
    key: "value",
    get: function get() {
      return this.element.text || '';
    },
    set: function set(value) {
      this.element.text = value;
    }
  }, {
    key: "focused",
    get: function get() {
      return this.element.focused || false;
    },
    set: function set(value) {
      this.element.focused = value !== false;
    }
  }, {
    key: "placeholder",
    get: function get() {
      return this.element.placeholder || '';
    },
    set: function set(text) {
      this.element.placeholder = text;
    }
  }, {
    key: "type",
    set: function set(value) {
      this.element.style = {
        type: value
      };
    }
  }, {
    key: "returnKeyType",
    set: function set(value) {
      this.element.style = {
        returnKeyType: value
      };
    }
  }, {
    key: "maxLength",
    set: function set(value) {
      this.element.style = {
        maxLength: value
      };
    }
  }, {
    key: "_setAttribute",
    value: function _setAttribute(key, value) {
      switch (key) {
        case 'value':
          this.value = value;
          break;

        case 'placeholder':
          this.placeholder = value;
          break;

        case 'focused':
          this.focused = value;
          break;

        case 'type':
          this.type = value;
          break;

        case 'maxLength':
          this.maxLength = value;
          break;

        case 'returnKeyType':
          this.returnKeyType = value;
          break;
      }
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(event, func) {
      var _this12 = this;

      var handler = function handler(text) {
        func.call(_this12, text);
      };

      switch (event) {
        case 'input':
          this._input = handler;
          break;

        case 'change':
          this._change = handler;
          break;

        case 'focus':
          this._focus = handler;
          break;

        case 'blur':
          this._blur = handler;
          break;

        case 'confirm':
          this._confirm = handler;
          break;
      }

      this.initListener();
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(event) {
      switch (event) {
        case 'input':
          this._input = null;
          this._hasInput = false;
          break;

        case 'change':
          this._change = null;
          break;

        case 'focus':
          this._focus = null;
          break;

        case 'blur':
          this._blur = null;
          break;

        case 'confirm':
          this._confirm = null;
          break;
      }
    }
  }, {
    key: "initListener",
    value: function initListener() {
      var _this13 = this;

      if (this._hasInput) {
        return;
      }

      this.element.addEventListener('input', function (event) {
        var state = event.state,
            text = event.text;

        switch (state) {
          case 1:
            _this13._focus && _this13._focus(text);
            break;

          case 2:
            _this13._change && _this13._change(text);
            break;

          case 3:
            _this13._blur && _this13._blur(text);
            break;

          case 4:
            _this13._confirm && _this13._confirm(text);
            break;
        }

        _this13._input && _this13._input({
          value: text,
          text: text,
          state
        });
      });
      this._hasInput = true;
    }
  }]);

  return Input;
}(Base);

var TextArea = /*#__PURE__*/function (_Base6) {
  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__["default"])(TextArea, _Base6);

  var _super7 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(TextArea);

  function TextArea() {
    var _this14;

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, TextArea);

    _this14 = _super7.call(this);
    _this14.__NAME = NODE_TEXTAREA_1;
    _this14._input = null;
    _this14._change = null;
    _this14._focus = null;
    _this14._blur = null;
    _this14._confirm = null;
    _this14._hasInput = false;
    _this14.element = new __GLOBAL__.TextArea();
    return _this14;
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(TextArea, [{
    key: "value",
    get: function get() {
      return this.element.text || '';
    },
    set: function set(value) {
      this.element.text = value;
    }
  }, {
    key: "focused",
    get: function get() {
      return this.element.focused || false;
    },
    set: function set(value) {
      this.element.focused = value !== false;
    }
  }, {
    key: "placeholder",
    get: function get() {
      return this.element.placeholder || '';
    },
    set: function set(text) {
      this.element.placeholder = text;
    }
  }, {
    key: "type",
    set: function set(value) {
      this.element.style = {
        type: value
      };
    }
  }, {
    key: "returnKeyType",
    set: function set(value) {
      this.element.style = {
        returnKeyType: value
      };
    }
  }, {
    key: "maxLength",
    set: function set(value) {
      this.element.style = {
        maxLength: value
      };
    }
  }, {
    key: "rows",
    set: function set(value) {
      this.element.style = {
        textLineClamp: value
      };
    }
  }, {
    key: "_setAttribute",
    value: function _setAttribute(key, value) {
      switch (key) {
        case 'value':
          this.value = value;
          break;

        case 'placeholder':
          this.placeholder = value;
          break;

        case 'focused':
          this.focused = value;
          break;

        case 'type':
          this.type = value;
          break;

        case 'maxLength':
          this.maxLength = value;
          break;

        case 'returnKeyType':
          this.returnKeyType = value;
          break;

        case 'rows':
          this.rows = value;
          break;
      }
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(event, func) {
      var _this15 = this;

      var handler = function handler(text) {
        func.call(_this15, text);
      };

      switch (event) {
        case 'input':
          this._input = handler;
          break;

        case 'change':
          this._change = handler;
          break;

        case 'focus':
          this._focus = handler;
          break;

        case 'blur':
          this._blur = handler;
          break;

        case 'confirm':
          this._confirm = handler;
          break;
      }

      this.initListener();
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(event) {
      switch (event) {
        case 'input':
          this._input = null;
          this._hasInput = false;
          break;

        case 'change':
          this._change = null;
          break;

        case 'focus':
          this._focus = null;
          break;

        case 'blur':
          this._blur = null;
          break;

        case 'confirm':
          this._confirm = null;
          break;
      }
    }
  }, {
    key: "initListener",
    value: function initListener() {
      var _this16 = this;

      if (this._hasInput) {
        return;
      }

      this.element.addEventListener('input', function (event) {
        var state = event.state,
            text = event.text;

        switch (state) {
          case 1:
            _this16._focus && _this16._focus(text);
            break;

          case 2:
            _this16._change && _this16._change(text);
            break;

          case 3:
            _this16._blur && _this16._blur(text);
            break;

          case 4:
            _this16._confirm && _this16._confirm(text);
            break;
        }

        _this16._input && _this16._input({
          value: text,
          text: text,
          state
        });
      });
      this._hasInput = true;
    }
  }]);

  return TextArea;
}(Base);

var Button = /*#__PURE__*/function (_Base7) {
  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__["default"])(Button, _Base7);

  var _super8 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(Button);

  function Button() {
    var _this17;

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, Button);

    _this17 = _super8.call(this);
    _this17.__NAME = NODE_BUTTON_1;
    _this17._text = '';
    _this17.element = new __GLOBAL__.Button();
    return _this17;
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(Button, [{
    key: "setElementText",
    value: function setElementText(text) {
      this.text = text;
    }
  }, {
    key: "text",
    get: function get() {
      return this._text;
    },
    set: function set(text) {
      this._text = text;
      this.element.text = text;
    }
  }, {
    key: "pressedStyle",
    set: function set(style) {
      this.element.pressed = styleTransformer_1.transformStyle(style, this) || {};
    }
  }, {
    key: "disabledStyle",
    set: function set(style) {
      this.element.disabled = styleTransformer_1.transformStyle(style, this) || {};
    }
  }, {
    key: "_setAttribute",
    value: function _setAttribute(key, value) {
      switch (key) {
        case 'disabled':
          this.disabled = value;
          break;

        case 'disabledStyle':
          this.disabledStyle = value;
          break;

        case 'pressedStyle':
          this.pressedStyle = value;
          break;
      }
    }
  }]);

  return Button;
}(Base);

var Comment = /*#__PURE__*/function (_Base8) {
  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__["default"])(Comment, _Base8);

  var _super9 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(Comment);

  function Comment(comment) {
    var _this18;

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, Comment);

    _this18 = _super9.call(this);
    _this18.__NAME = NODE_COMMENT_1;
    _this18._comment = '';
    _this18.element = new __GLOBAL__.View();
    _this18.element.style = {
      display: 'none'
    };
    _this18._comment = comment;
    return _this18;
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(Comment, [{
    key: "comment",
    get: function get() {
      return this._comment;
    }
  }]);

  return Comment;
}(Base);

var Scroller = /*#__PURE__*/function (_Base9) {
  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__["default"])(Scroller, _Base9);

  var _super10 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(Scroller);

  function Scroller() {
    var _this19;

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, Scroller);

    _this19 = _super10.call(this);
    _this19.__NAME = NODE_SCROLLER_1;
    _this19.element = new __GLOBAL__.Scroller();
    return _this19;
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(Scroller, [{
    key: "_setAttribute",
    value: function _setAttribute(key, value) {
      switch (key) {
        case 'scrollDirection':
          if (value === 'horizontal' && this.element instanceof __GLOBAL__.Scroller) {
            var scroller = new __GLOBAL__.HorizontalScroller();
            scroller.style = this._style;

            var _iterator3 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_3__["default"])(this.children.values()),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var child = _step3.value;
                this.element.removeChild(child.element);
                scroller.appendChild(child.element);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }

            this.element = scroller;
          }

          break;

        case 'bounces':
          this.element.bounces = value !== false;
          break;

        case 'showScrollBar':
          this.element.showScrollBar = value !== false;
          break;
      }
    }
  }, {
    key: "_appendChild",
    value: function _appendChild(child) {
      child.unlinkSiblings();
      child.parent = this;
      this.children.add(child);

      if (!this.firstChild) {
        this.firstChild = child;
      }

      child.prevSibling = this.lastChild;
      child.nextSibling = null;

      if (this.lastChild) {
        this.lastChild.nextSibling = child;
      }

      this.lastChild = child;

      if (this.element && child.element) {
        if (child.__NAME === NODE_REFRESH_1) {
          this.element.refreshView = child.element;
        } else if (child.__NAME === NODE_LOADMORE_1) {
          this.element.loadMoreView = child.element;
        } else {
          this.element.appendChild(child.element);

          child._onMounted();
        }
      }
    }
  }, {
    key: "_insertBefore",
    value: function _insertBefore(child, anchor) {
      child.unlinkSiblings();
      child.parent = this;

      if (anchor.prevSibling) {
        child.prevSibling = anchor.prevSibling;
        anchor.prevSibling.nextSibling = child;
      }

      anchor.prevSibling = child;
      child.nextSibling = anchor;

      if (this.firstChild === anchor) {
        this.firstChild = child;
      }

      this.children.add(child);

      if (this.element && child.element && anchor.element) {
        if (child.__NAME === NODE_REFRESH_1) {
          this.element.refreshView = child.element;
        } else if (child.__NAME === NODE_LOADMORE_1) {
          this.element.loadMoreView = child.element;
        } else {
          this.element.appendChild(child.element);

          child._onMounted();
        }
      }
    }
  }, {
    key: "scrollTo",
    value: function scrollTo(x, y) {
      this.element.scrollTo(x, y);
    }
  }, {
    key: "scrollBy",
    value: function scrollBy(dx, dy) {
      this.element.scrolBy(dx, dy);
    }
  }, {
    key: "scrollToTop",
    value: function scrollToTop() {
      this.element.scrollToTop();
    }
  }, {
    key: "scrollToBottom",
    value: function scrollToBottom() {
      this.element.scrollToBottom();
    }
  }, {
    key: "stopPullRefresh",
    value: function stopPullRefresh() {
      this.element.stopPullRefresh();
    }
  }, {
    key: "stopLoadMore",
    value: function stopLoadMore(enable) {
      this.element.stopLoadMore(enable);
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(event, func) {
      var _this20 = this;

      switch (event) {
        case "scroll":
          this.element.addEventListener('scroll', function (e) {
            func.call(_this20, e);
          });
          break;

        case "scrolltotop":
          this.element.setOnScrollToTopListener(function () {
            func.call(_this20);
          });
          break;

        case "scrolltobottom":
          this.element.setOnScrollToBottomListener(function () {
            func.call(_this20);
          });
          break;

        case 'refresh':
          this.element.onRefresh = function (state) {
            func.call(_this20, state, _this20);
          };

          break;

        case 'loadmore':
          this.element.onLoadMore = function (state) {
            func.call(_this20, state, _this20);
          };

          break;

        default:
          this.element.addEventListener(event, function (e) {
            func.call(_this20, e);
          });
          break;
      }
    }
  }]);

  return Scroller;
}(Base);

var Anchor = /*#__PURE__*/function (_Base10) {
  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__["default"])(Anchor, _Base10);

  var _super11 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(Anchor);

  function Anchor() {
    var _this21;

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, Anchor);

    _this21 = _super11.call(this);
    _this21.__NAME = NODE_ANCHOR_1;
    _this21.element = new __GLOBAL__.View();
    _this21.element.style = {
      display: "none"
    };
    return _this21;
  }

  return Anchor;
}(Base);

var Switch = /*#__PURE__*/function (_Base11) {
  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__["default"])(Switch, _Base11);

  var _super12 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(Switch);

  function Switch() {
    var _this22;

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, Switch);

    _this22 = _super12.call(this);
    _this22.__NAME = NODE_SWITCH_1;
    _this22.element = new __GLOBAL__.Switch();
    return _this22;
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(Switch, [{
    key: "value",
    get: function get() {
      return this.element.checked;
    },
    set: function set(value) {
      this.element.checked = value !== false;
    }
  }, {
    key: "onColor",
    set: function set(value) {
      this.element.style = {
        onColor: value
      };
    }
  }, {
    key: "offColor",
    set: function set(value) {
      this.element.style = {
        offColor: value
      };
    }
  }, {
    key: "thumbColor",
    set: function set(value) {
      this.element.style = {
        thumbColor: value
      };
    }
  }, {
    key: "_setAttribute",
    value: function _setAttribute(key, value) {
      switch (key) {
        case 'value':
          this.value = value;
          break;

        case 'openColor':
          this.onColor = value;
          break;

        case 'closeColor':
          this.offColor = value;
          break;

        case 'thumbColor':
          this.thumbColor = value;
          break;
      }
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(event, func) {
      var _this23 = this;

      if (event === 'switch') {
        var invoker = function invoker(e) {
          var state = e.state;
          var value = state === 1 || state === true ? true : false;
          func.call(_this23, value);
        };

        this.element.addEventListener(event, invoker);
      }
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(event, func) {
      this.element.removeEventListener(event, func);
    }
  }]);

  return Switch;
}(Base);

var Refresh = /*#__PURE__*/function (_View) {
  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__["default"])(Refresh, _View);

  var _super13 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(Refresh);

  function Refresh() {
    var _this24;

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, Refresh);

    _this24 = _super13.apply(this, arguments);
    _this24.__NAME = NODE_REFRESH_1;
    return _this24;
  }

  return Refresh;
}(View);

var LoadMore = /*#__PURE__*/function (_View2) {
  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__["default"])(LoadMore, _View2);

  var _super14 = (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_2__["default"])(LoadMore);

  function LoadMore() {
    var _this25;

    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, LoadMore);

    _this25 = _super14.apply(this, arguments);
    _this25.__NAME = NODE_LOADMORE_1;
    return _this25;
  }

  return LoadMore;
}(View);

var components = new Map();

function register(component) {
  if (Array.isArray(component)) {
    component.forEach(function (component) {
      registerComponent(component);
    });
  } else {
    registerComponent(component);
  }
}

function registerComponent(component) {
  var name = component.name;
  components.set("ex-".concat(name), component);
}

function getComponent(tag) {
  var component = components.get(tag);
  return component.factory();
}

var Document = /*#__PURE__*/function () {
  function Document() {
    (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, Document);
  }

  (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(Document, [{
    key: "createElement",
    value: function createElement(tag) {
      var component = null;

      switch (tag) {
        case ELEMNT_TAG_MAP_1[NODE_VIEW_1]:
          component = new View();
          break;

        case ELEMNT_TAG_MAP_1[NODE_SCROLLER_1]:
          component = new Scroller();
          break;

        case ELEMNT_TAG_MAP_1[NODE_TEXT_1]:
          component = new Text();
          break;

        case ELEMNT_TAG_MAP_1[NODE_IMAGE_1]:
          component = new Image();
          break;

        case ELEMNT_TAG_MAP_1[NODE_INPUT_1]:
          component = new Input();
          break;

        case ELEMNT_TAG_MAP_1[NODE_TEXTAREA_1]:
          component = new TextArea();
          break;

        case ELEMNT_TAG_MAP_1[NODE_BUTTON_1]:
          component = new Button();
          break;

        case ELEMNT_TAG_MAP_1[NODE_SWITCH_1]:
          component = new Switch();
          break;

        case ELEMNT_TAG_MAP_1[NODE_LOADMORE_1]:
          component = new LoadMore();
          break;

        case ELEMNT_TAG_MAP_1[NODE_REFRESH_1]:
          component = new Refresh();
          break;

        default:
          if (isCustomNativeTag_1(tag)) {
            component = getComponent(tag) || new View();
          } else {
            component = new View();
          }

          break;
      }

      return component;
    }
  }, {
    key: "createText",
    value: function createText(text) {
      var component = null;

      if (!text) {
        component = new Anchor();
      } else {
        component = new Text();
        component.setElementText(text);
      }

      return component;
    }
  }, {
    key: "createComment",
    value: function createComment(comment) {
      return new Comment(comment);
    }
  }, {
    key: "createPageView",
    value: function createPageView(options) {
      var pageView = new Page(options);
      return pageView;
    }
  }]);

  return Document;
}();

var document$1 = new Document();

var insert = function insert(child, parent, anchor) {
  if (!parent) {
    return null;
  }

  if (anchor !== null) {
    parent._insertBefore(child, anchor);
  } else {
    parent._appendChild(child);
  }
};

var remove = function remove(child) {
  var parent = child.parent;

  if (parent !== null) {
    parent._removeChild(child);
  }
};

var createElement = function createElement(tag) {
  return document$1.createElement(tag);
};

var createText = function createText(text) {
  return document$1.createText(text);
};

var createComment = function createComment(comment) {
  return document$1.createComment(comment);
};

var setText = function setText(node, text) {
  node.setElementText(text);
};

var setElementText = function setElementText(node, text) {
  node.setElementText(text);
};

var parentNode = function parentNode(node) {
  return node.parent ? node.parent : null;
};

var nextSibling = function nextSibling(node) {
  return node.nextSibling;
};

var querySelector = function querySelector(selector) {
  return null;
};

var setScopeId = function setScopeId(el, id) {
  el.setScopeId(id);
};

var nodeOps = {
  insert,
  remove,
  createElement,
  createText,
  createComment,
  setText,
  setElementText,
  parentNode,
  nextSibling,
  querySelector,
  setScopeId
};

function patchClass(el, key, prevValue, nextValue) {
  el.setAttribute(key, nextValue);
}

function patchStyle(el, key, prevValue, nextValue) {
  var style = nextValue;

  if (typeof nextValue === 'string') {
    style = parseStringStyle_1(nextValue);
  }

  style = styleTransformer_1.transformStyle(style, el);
  el.setStyle(style, true);
}

function patchAttrs(el, key, prevValue, nextValue) {
  el.setAttribute(key, nextValue);
}

var LongPress = 'longpress';

function patchEvents(el, rawName, prevValue, nextValue) {
  var instance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var event = getStaticEventName(rawName);
  var value = nextValue;
  var invoker = prevValue && prevValue.invoker;

  if (nextValue && value) {
    if (invoker) {
      prevValue.invoker = null;
      invoker.value = value;
      nextValue.invoker = invoker;
    } else {
      addEventListener$1(el, event, createInvoker(value, instance));
    }
  } else if (invoker) {
    removeEventListener(el, event, invoker);
  }
}

function createInvoker(initialValue, instance) {
  var invoker = function invoker() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key14 = 0; _key14 < _len7; _key14++) {
      args[_key14] = arguments[_key14];
    }

    if (Array.isArray(initialValue)) {
      initialValue.forEach(function (func) {
        func.apply(instance, [].concat(args));
      });
    } else {
      initialValue.apply(instance, [].concat(args));
    }
  };

  invoker.value = initialValue;
  initialValue.invoker = invoker;
  return invoker;
}

function addEventListener$1(el, event, handler) {
  el.addEventListener(event, handler);
}

function removeEventListener(el, event, handler) {
  el.removeEventListener(event, handler);
}

function getStaticEventName(rawName) {
  var eventName = rawName.slice(2).toLowerCase();

  if (eventName === LongPress) {
    eventName = "longPress";
  }

  return eventName;
}

function patchProp(el, key, prevValue, nextValue) {
  var isSVG = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var prevChildren = arguments.length > 5 ? arguments[5] : undefined;
  var parentComponent = arguments.length > 6 ? arguments[6] : undefined;
  var parentSuspense = arguments.length > 7 ? arguments[7] : undefined;
  var unmountChildren = arguments.length > 8 ? arguments[8] : undefined;

  switch (key) {
    case 'class':
      patchClass(el, key, prevValue, nextValue);
      break;

    case 'style':
      patchStyle(el, key, prevValue, nextValue);
      break;

    default:
      if (isOn(key)) {
        patchEvents(el, key, prevValue, nextValue, parentComponent);
      } else {
        patchAttrs(el, key, prevValue, nextValue);
      }

      break;
  }
}

function isOn(key) {
  var onRE = /^on[^a-z]/;
  return onRE.test(key);
}

var context = {
  plugins: [],
  mixins: [],
  components: [],
  directives: []
};

var use = function use(plugin, options) {
  context.plugins.push({
    plugin: plugin,
    options: options
  });
};

var mixin = function mixin(_mixin) {
  context.mixins.push({
    mixin: _mixin
  });
};

var component = function component(name, _component) {
  context.components.push({
    name: name,
    component: _component
  });
};

var directive = function directive(name, _directive) {
  context.directives.push({
    name: name,
    directive: _directive
  });
};

var install = function install(app) {
  context.plugins.forEach(function (item) {
    app.use(item.plugin, item.options);
  });
  context.mixins.forEach(function (item) {
    app.mixin(item.mixin);
  });
  context.components.forEach(function (item) {
    app.component(item.name, item.component);
  });
  context.directives.forEach(function (item) {
    app.directive(item.name, item.directive);
  });
};

var LifeCycleEnum;

(function (LifeCycleEnum) {
  LifeCycleEnum["ONLOAD"] = "onLoad";
  LifeCycleEnum["ONSHOW"] = "onShow";
  LifeCycleEnum["ONHIDE"] = "onHide";
  LifeCycleEnum["ONUNLOAD"] = "onUnload";
  LifeCycleEnum["ONBACK"] = "onBack";
})(LifeCycleEnum || (LifeCycleEnum = {}));

var LIFECYCLE = [LifeCycleEnum.ONLOAD, LifeCycleEnum.ONSHOW, LifeCycleEnum.ONHIDE, LifeCycleEnum.ONUNLOAD, LifeCycleEnum.ONBACK];

var initPageLifeCycle = function initPageLifeCycle(container, instance, config) {
  var globalMixins = instance._.appContext.mixins;
  var mixins = config.mixins,
      extendOptions = config.extends;
  var lifeCycleMixins = {
    onLoad: [],
    onShow: [],
    onHide: [],
    onUnload: [],
    onBack: []
  };
  var globalLifeCycleMixins = {
    onLoad: [],
    onShow: [],
    onHide: [],
    onUnload: [],
    onBack: []
  };

  if (globalMixins) {
    globalLifeCycleMixins = applyPageMixin(globalMixins);
  }

  if (mixins) {
    lifeCycleMixins = applyPageMixin(mixins);
  }

  LIFECYCLE.forEach(function (lifecycle) {
    if (lifecycle === LifeCycleEnum.ONBACK) {
      container[lifecycle] = function () {
        for (var i = 0; i < globalLifeCycleMixins[lifecycle].length; i++) {
          if (applyLifeCycle(instance, globalLifeCycleMixins[lifecycle][i])) {
            return true;
          }
        }

        if (extendOptions) {
          if (applyLifeCycle(instance, extendOptions[lifecycle])) {
            return true;
          }
        }

        for (var _i4 = 0; _i4 < lifeCycleMixins[lifecycle].length; _i4++) {
          if (applyLifeCycle(instance, lifeCycleMixins[lifecycle][_i4])) {
            return true;
          }
        }

        return applyLifeCycle(instance, config[lifecycle]);
      };

      return true;
    }

    container[lifecycle] = function () {
      globalLifeCycleMixins[lifecycle].forEach(function (func) {
        applyLifeCycle(instance, func);
      });
      extendOptions && applyLifeCycle(instance, extendOptions[lifecycle]);
      lifeCycleMixins[lifecycle].forEach(function (func) {
        applyLifeCycle(instance, func);
      });
      applyLifeCycle(instance, config[lifecycle]);
    };
  });
};

function applyPageMixin(mixins) {
  var lifeCycleMixins = {
    onLoad: [],
    onShow: [],
    onHide: [],
    onUnload: [],
    onBack: []
  };

  if (!mixins || mixins.length === 0) {
    return lifeCycleMixins;
  }

  mixins.forEach(function (mixin) {
    var onLoad = mixin.onLoad,
        onShow = mixin.onShow,
        onHide = mixin.onHide,
        onUnload = mixin.onUnload,
        onBack = mixin.onBack;
    onLoad && lifeCycleMixins.onLoad.push(onLoad);
    onShow && lifeCycleMixins.onShow.push(onShow);
    onHide && lifeCycleMixins.onHide.push(onHide);
    onUnload && lifeCycleMixins.onUnload.push(onUnload);
    onBack && lifeCycleMixins.onBack.push(onBack);
  });
  return lifeCycleMixins;
}

function applyLifeCycle(instance, func) {
  return func && func.apply(instance);
}

var vAnimation = {
  mounted(el, _ref28) {
    var value = _ref28.value;
    value && el.handleAnimation(value);
  },

  updated(el, _ref29) {
    var value = _ref29.value,
        oldValue = _ref29.oldValue;

    if (!value || value === oldValue) {
      return;
    } else {
      el.handleAnimation(value);
    }
  },

  beforeUnmount(el, _ref30) {
    var value = _ref30.value;
  }

};
var DefaultDisplay = 'flex';
var vShow = {
  beforeMount(el, _ref31, _ref32) {
    var value = _ref31.value;
    var transition = _ref32.transition;

    if (el.style.display === 'none') {
      el._vod = '';
    } else {
      el._vod = el.style.display || DefaultDisplay;
    }

    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },

  mounted(el, _ref33, _ref34) {
    var value = _ref33.value;
    var transition = _ref34.transition;

    if (transition && value) {
      transition.enter(el);
    }
  },

  updated(el, _ref35, _ref36) {
    var value = _ref35.value,
        oldValue = _ref35.oldValue;
    var transition = _ref36.transition;
    if (!value === !oldValue) return;

    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, function () {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },

  beforeUnmount(el, _ref37) {
    var value = _ref37.value;
    setDisplay(el, value);
  }

};

function setDisplay(el, value) {
  el.setStyle({
    display: value ? el._vod : 'none',
    "flex-direction": el.style.flexDirection ? el.style.flexDirection : 'column'
  });
}

var InputEventState;

(function (InputEventState) {
  InputEventState[InputEventState["BEGIN"] = 1] = "BEGIN";
  InputEventState[InputEventState["CHANGED"] = 2] = "CHANGED";
  InputEventState[InputEventState["ENDED"] = 3] = "ENDED";
  InputEventState[InputEventState["CONFIRMED"] = 4] = "CONFIRMED";
})(InputEventState || (InputEventState = {}));

var SwitchEventState;

(function (SwitchEventState) {
  SwitchEventState[SwitchEventState["CLOSE"] = 0] = "CLOSE";
  SwitchEventState[SwitchEventState["OPEN"] = 1] = "OPEN";
})(SwitchEventState || (SwitchEventState = {}));

function addEventListener(el, event, handler) {
  el.addEventListener(event, handler);
}

var getModelAssigner = function getModelAssigner(vnode) {
  var fn = vnode.props['onUpdate:modelValue'];
  return isArray(fn) ? function (value) {
    return invokeArrayFns(fn, value);
  } : fn;
};

var vModelText = {
  beforeMount(el, _ref38, vnode) {
    var value = _ref38.value,
        _ref38$modifiers = _ref38.modifiers,
        lazy = _ref38$modifiers.lazy,
        trim = _ref38$modifiers.trim,
        number = _ref38$modifiers.number;
    el.value = value == null ? '' : value;
    el._assign = getModelAssigner(vnode);
    var castToNumber = !!number;
    addEventListener(el, 'input', function (e) {
      var domValue = e.text;

      if (lazy) {
        if (e.state === InputEventState.CONFIRMED || e.state === InputEventState.ENDED) {
          var _value2 = transformValue(trim, castToNumber, domValue);

          el._assign(_value2);
        }
      } else {
        if (e.state === InputEventState.CHANGED) {
          var _value3 = transformValue(trim, castToNumber, domValue);

          el._assign(_value3);
        }
      }
    });
  },

  beforeUpdate(el, _ref39, vnode) {
    var value = _ref39.value,
        _ref39$modifiers = _ref39.modifiers,
        trim = _ref39$modifiers.trim,
        number = _ref39$modifiers.number;
    el._assign = getModelAssigner(vnode);

    if (el.focused) {
      if (trim && el.value.trim() === value) {
        return;
      }

      if (number && toNumber(el.value) === value) {
        return;
      }
    }

    var newValue = value == null ? '' : value;

    if (el.value !== newValue) {
      el.value = newValue;
    }
  }

};

function transformValue(trim, castToNumber, value) {
  var domValue = value;

  if (trim) {
    domValue = domValue.trim();
  }

  if (castToNumber) {
    domValue = toNumber(domValue);
  }

  return domValue;
}

var vModelSwitch = {
  beforeMount(el, _ref40, vnode) {
    var value = _ref40.value;
    el.value = value == null ? '' : value;
    el._assign = getModelAssigner(vnode);
    addEventListener(el, 'switch', function (e) {
      var state = e.state;

      if (state === SwitchEventState.CLOSE) {
        el._assign(false);
      } else if (state === SwitchEventState.OPEN) {
        el._assign(true);
      }
    });
  },

  beforeUpdate(el, _ref41, vnode) {
    var value = _ref41.value,
        _ref41$modifiers = _ref41.modifiers,
        trim = _ref41$modifiers.trim,
        number = _ref41$modifiers.number;
    el._assign = getModelAssigner(vnode);

    if (el.value === value) {
      return;
    }

    el.value = value;
  }

};
var extend = Object.assign;

var _createRenderer = createRenderer(extend({
  patchProp
}, nodeOps)),
    baseRender = _createRenderer.render,
    baseCreateApp = _createRenderer.createApp;

var renderApp = baseRender;
var appContext = null;
var container = null;

var renderCustomSlot = function renderCustomSlot(vnode, container) {
  if (!isVNode(vnode)) {
    vnode = createVNode(vnode);
  }

  vnode.appContext = appContext;
  baseRender(vnode, container);
};

var createApp = function createApp() {
  var app = baseCreateApp.apply(void 0, arguments);
  var mount = app.mount;

  app.mount = function (container) {
    var proxy = mount(container);
    return proxy;
  };

  return app;
};

var createRootContainer = function createRootContainer(options) {
  return document$1.createPageView(options);
};

function render(App) {
  var pageConfig = App.pageConfig;
  var app = createApp(App);
  install(app);
  appContext = app._context;
  container = createRootContainer({
    canScroll: pageConfig && pageConfig.canScroll,
    pageStyle: pageConfig && pageConfig.pageStyle
  });
  var plugins = App.plugins;
  plugins && plugins.forEach(function (plugin) {
    app.use(plugin);
  });
  var instance = app.mount(container);
  initPageLifeCycle(container, instance, App);
  container.render();

  if (true) {
    __webpack_require__(/*! @hummer/tenon-dev-tool */ "./node_modules/@hummer/tenon-dev-tool/dist/tenon-dev-tool.cjs.js").run(container);
  }
}

var index = {
  render
};


/***/ }),

/***/ "./src/common/CommonColor.ts":
/*!***********************************!*\
  !*** ./src/common/CommonColor.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Color": () => (/* binding */ Color)
/* harmony export */ });
var Color = {
  hm_linear_gradient: 'linear-gradient(90deg #15D0B4 #E2ED00)',
  hm_yellow: '#E2ED00',
  hm_green: '#15D0B4',
  hm_blue: '#4A90E2',
  hm_orange: '#F1CA19',
  hm_purple: '#8484FF',
  transparent: '#00000000',
  black: '#000000',
  white: '#FFFFFF',
  red: '#FF0000',
  green: '#00FF00',
  blue: '#0000FF',
  grey: '#808080',
  light_grey: '#CCCCCC',
  dark_grey: '#333333',
  transparent_grey: '#00000060'
};

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/animation-basic/app.vue?vue&type=script&lang=js&":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/animation-basic/app.vue?vue&type=script&lang=js& ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/objectSpread2 */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/objectSpread2.js");
/* harmony import */ var _component_CommonPage_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/CommonPage.vue */ "./src/component/CommonPage.vue");

var baseAnimation = {
  duration: 3000,
  // 动画持续时间，单位 ms
  repeatCount: -1,
  // 重复的次数（-1 无限次，0 一次，1 两次）
  easing: "linear"
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  pageConfig: {
    canScroll: false
  },
  components: {
    CommonPage: _component_CommonPage_vue__WEBPACK_IMPORTED_MODULE_1__["default"]
  },

  data() {
    return {
      animFadeOut: (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])({}, baseAnimation), {}, {
        styles: {
          opacity: 0
        }
      }),
      animFadeIn: (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])({}, baseAnimation), {}, {
        styles: {
          opacity: 1
        }
      }),
      animRotation: (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])({}, baseAnimation), {}, {
        styles: {
          rotationZ: 180
        }
      }),
      animTranslate: (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])({}, baseAnimation), {}, {
        styles: {
          scale: 0.5,
          position: {
            x: "100hm",
            y: 0
          }
        }
      }),
      animScale: (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])({}, baseAnimation), {}, {
        styles: {
          scale: 0.5
        }
      }),
      animBackground: (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])({}, baseAnimation), {}, {
        styles: {
          backgroundColor: "black"
        }
      }),
      animWidth: (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])({}, baseAnimation), {}, {
        styles: {
          width: "1.5rem"
        }
      }),
      animHeight: (0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_Users_didi_Desktop_hummer_cli_hummer_cli_packages_plugin_build_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])({}, baseAnimation), {}, {
        styles: {
          height: "1.5rem"
        }
      })
    };
  },

  methods: {
    cons() {
      console.log(this.animFadeOut);
    }

  }
});

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/component/CommonPage.vue?vue&type=script&lang=js&":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!../../../cli/hummer-cli/packages/plugin-build/node_modules/@hummer/tenon-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./src/component/CommonPage.vue?vue&type=script&lang=js& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _common_CommonColor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/CommonColor */ "./src/common/CommonColor.ts");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: {
    titleText: String,
    showDisplayLayout: {
      type: Boolean,
      default: true
    },
    showOption: {
      type: Boolean,
      default: true
    },
    showDefaultOption: {
      type: Boolean,
      default: true
    },
    showDefaultLayout: {
      type: Boolean,
      default: true
    }
  },

  data() {
    return {
      bgColors: [_common_CommonColor__WEBPACK_IMPORTED_MODULE_0__.Color.hm_green, _common_CommonColor__WEBPACK_IMPORTED_MODULE_0__.Color.hm_yellow, _common_CommonColor__WEBPACK_IMPORTED_MODULE_0__.Color.hm_linear_gradient, _common_CommonColor__WEBPACK_IMPORTED_MODULE_0__.Color.transparent],
      cornerRadiuses: [0, 25, 50],
      borderStyles: ["none", "solid", "dashed", "dotted"],
      shadows: ["none", "2 2 5 #000000", "2 2 5 #FF0000", "2 2 5 #0000FF"],
      selectBackGroundIndex: 0,
      selectRadiusIndex: 0,
      selectBorderIndex: 0,
      selectShadowIndex: 0,
      displayViewBackground: null,
      displayViewRadius: null,
      displayViewBorder: null,
      displayViewShadow: null
    };
  },

  methods: {
    selectBackground(i) {
      this.selectBackGroundIndex = i;
      this.displayViewBackground = this.bgColors[i];
      this.$emit("selectBackGround", this.displayViewBackground);
    },

    selectRadius(i) {
      this.selectRadiusIndex = i;
      this.displayViewRadius = this.cornerRadiuses[i];
    },

    selectBorder(i) {
      this.selectBorderIndex = i;
      this.displayViewBorder = this.borderStyles[i];
    },

    selectShadow(i) {
      this.selectShadowIndex = i;
      this.displayViewShadow = this.shadows[i];
    },

    goBack() {
      Navigator.popPage();
    }

  }
});

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!*****************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _arrayLikeToArray)
/* harmony export */ });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js":
/*!***************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _arrayWithHoles)
/* harmony export */ });
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!******************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _arrayWithoutHoles)
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr);
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!**********************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _assertThisInitialized)
/* harmony export */ });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!***************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _classCallCheck)
/* harmony export */ });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _createClass)
/* harmony export */ });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js":
/*!**************************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _createForOfIteratorHelper)
/* harmony export */ });
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/createSuper.js":
/*!************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/createSuper.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _createSuper)
/* harmony export */ });
/* harmony import */ var _getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPrototypeOf.js */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isNativeReflectConstruct.js */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js");
/* harmony import */ var _possibleConstructorReturn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./possibleConstructorReturn.js */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");



function _createSuper(Derived) {
  var hasNativeReflectConstruct = (0,_isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__["default"])();
  return function _createSuperInternal() {
    var Super = (0,_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = (0,_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return (0,_possibleConstructorReturn_js__WEBPACK_IMPORTED_MODULE_2__["default"])(this, result);
  };
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!***************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _defineProperty)
/* harmony export */ });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":
/*!***************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _getPrototypeOf)
/* harmony export */ });
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/inherits.js":
/*!*********************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/inherits.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _inherits)
/* harmony export */ });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(subClass, superClass);
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js":
/*!*************************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _isNativeReflectConstruct)
/* harmony export */ });
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!****************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _iterableToArray)
/* harmony export */ });
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _iterableToArrayLimit)
/* harmony export */ });
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js":
/*!****************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _nonIterableRest)
/* harmony export */ });
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!******************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _nonIterableSpread)
/* harmony export */ });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/objectSpread2.js":
/*!**************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/objectSpread2.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _objectSpread2)
/* harmony export */ });
/* harmony import */ var _defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defineProperty.js */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/defineProperty.js");


function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        (0,_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js":
/*!**************************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _possibleConstructorReturn)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assertThisInitialized.js */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");


function _possibleConstructorReturn(self, call) {
  if (call && ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return (0,_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__["default"])(self);
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!***************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _setPrototypeOf)
/* harmony export */ });
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/slicedToArray.js":
/*!**************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/slicedToArray.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _slicedToArray)
/* harmony export */ });
/* harmony import */ var _arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithHoles.js */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js");
/* harmony import */ var _iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArrayLimit.js */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableRest.js */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js");




function _slicedToArray(arr, i) {
  return (0,_arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || (0,_iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arr, i) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(arr, i) || (0,_nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!******************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _toConsumableArray)
/* harmony export */ });
/* harmony import */ var _arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithoutHoles.js */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArray.js */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableSpread.js */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");




function _toConsumableArray(arr) {
  return (0,_arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || (0,_iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arr) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(arr) || (0,_nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!*******************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _typeof)
/* harmony export */ });
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

/***/ }),

/***/ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!***************************************************************************************************************************!*\
  !*** ../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _unsupportedIterableToArray)
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "../../../cli/hummer-cli/packages/plugin-build/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**************************************!*\
  !*** ./src/animation-basic/entry.js ***!
  \**************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hummer/tenon-vue */ "./node_modules/@hummer/tenon-vue/dist/tenon-vue.es.js");
/* harmony import */ var _app_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app.vue */ "./src/animation-basic/app.vue");


_hummer_tenon_vue__WEBPACK_IMPORTED_MODULE_0__.render(_app_vue__WEBPACK_IMPORTED_MODULE_1__["default"]);
})();

/******/ })()
;
//# sourceMappingURL=animation-basic.js.map